DAOInsufficient validation,20221021,OlympusDAO,https://web3sec.notion.site/Insufficient-validation-a593dd953d9f4bb692e1359acf052dc4?pvs=25,$292 K,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/README.md#20221021-bond-protocol---no-input-validation,,SolidityCopy/// @inheritdoc IBondFixedExpiryTeller
function redeem(ERC20BondToken token_, uint256 amount_) external override nonReentrant {//vulnerable point, insufficient validation
if (uint48(block.timestamp) < token_.expiry())
revert Teller_TokenNotMatured(token_.expiry());
        token_.burn(msg.sender, amount_);
        token_.underlying().transfer(msg.sender, amount_); //vulnerable point, custom contract return OHM.
}
​,Root cause:  insufficient validation
ERC20MiscalculationPricemanipulation,20221020,HEALTH,https://web3sec.notion.site/Incorrect-calculation-3628bf9f5a084c73bba1bb1ee4946c62?pvs=25,16 BNB,https://github.com/SunWeb3Sec/DeFiHackLabs#20221020-health---transfer-logic-flaw,,SolidityCopyfunction _transfer(address from, address to, uint256 value) private {
require(value <= _balances[from]);
require(to != address(0));
uint256 contractTokenBalance = balanceOf(address(this));
bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;
if (
            overMinTokenBalance &&
!inSwapAndLiquify &&
            to == uniswapV2Pair &&
            swapAndLiquifyEnabled
        ) {
            contractTokenBalance = numTokensSellToAddToLiquidity;
//add liquidity
swapAndLiquify(contractTokenBalance);
}
if (block.timestamp >= pairStartTime.add(jgTime) && pairStartTime != 0) {
if (from != uniswapV2Pair) {
uint256 burnValue = _balances[uniswapV2Pair].mul(burnFee).div(1000); //vulnerable point
                _balances[uniswapV2Pair] = _balances[uniswapV2Pair].sub(burnValue); //vulnerable point
                _balances[_burnAddress] = _balances[_burnAddress].add(burnValue); //vulnerable point
if (block.timestamp >= pairStartTime.add(jgTime)) {
                    pairStartTime += jgTime;
}
emit Transfer(uniswapV2Pair,_burnAddress, burnValue);
IPancakePair(uniswapV2Pair).sync();
}
​,Root cause:  incorrect calculation.
MetaverseInsufficient validation,20221020,BEGO,https://web3sec.notion.site/Insufficient-validation-04e0c2b7105c44e98dd2576e18f68835?pvs=25,12BNB,https://github.com/SunWeb3Sec/DeFiHackLabs#20221020-bego---incorrect-signature-verification,,SolidityCopymodifier isSigned(
string memory _txHash,
uint256 _amount,
bytes32[] memory _r,
bytes32[] memory _s,
uint8[] memory _v
    ) {
require(checkSignParams(_r, _s, _v), "bad-sign-params");
bytes32 _hash = keccak256(abi.encodePacked(bsc, msg.sender, _txHash, _amount));
address[] memory _signers = new address[](_r.length); //vulnerable point
for (uint8 i = 0; i < _r.length; i++) {
            _signers[i] = ecrecover(_hash, _v[i], _r[i], _s[i]);
}
require(isSigners(_signers), "bad-signers");
_;
}
function isSigners(address[] memory _signers) public view returns (bool){
for (uint8 i = 0; i < _signers.length; i++) { //vulnerable point
if (!_containsSigner(_signers[i])) {
return false;
}
}
return true; // null data will return true 
}
function mint(
uint256 _amount,
string memory _txHash,
address _receiver,
bytes32[] memory _r,
bytes32[] memory _s,
uint8[] memory _v
    ) isSigned(_txHash, _amount, _r, _s, _v) external returns (bool){ //trace isSigned
require(!txHashes[_txHash], "tx-hash-used");
        txHashes[_txHash] = true;
_mint(_receiver, _amount);
return true;
}
​,Root cause:  Insufficient validation
ERC20Access Control,20221018,HPAY,https://web3sec.notion.site/Incorrect-access-control-fb2894e0ae804b9fb9c35e76f55db4d0?pvs=25,115 BNB,https://github.com/SunWeb3Sec/DeFiHackLabs#20221018-hpay---access-control,fixed,SolidityCopyfunction setToken(address _addr) public { //vulnerable point
        configuration.stakingToken = ERC20(_addr);
        configuration.rewardsToken = ERC20(_addr);
}
​,Root cause:  Incorrect access control
ERC20Access Control,20221017,Uerii,https://web3sec.notion.site/Incorrect-access-control-3b0318547ef74808b56c9f1ed435f55d?pvs=25,$2.4 K,https://github.com/SunWeb3Sec/DeFiHackLabs#20221017-uerii-token---access-control,,SolidityCopyfunction mint() public returns (bool) { //vulnerable point
_mint( msg.sender, 100000000000000000 );
return true;
}
​,Root cause:  Incorrect access control
YieldFlashloansInsufficient validation,20221014,EFLeverVault,https://web3sec.notion.site/Insufficient-validation-6f07ce0ceae944f2baef2219b555b18b?pvs=25,750 ETH,https://github.com/SunWeb3Sec/DeFiHackLabs#20221014-eflevervault---verify-flashloan-callback,,SolidityCopyfunction receiveFlashLoan(
        IERC20[] memory tokens,
uint256[] memory amounts,
uint256[] memory feeAmounts,
bytes memory userData
    ) public payable {
require(msg.sender == balancer, "only flashloan vault");
//insufficient validation
uint256 loan_amount = amounts[0];
uint256 fee_amount = feeAmounts[0];
if (keccak256(userData) == keccak256("0x1")){
_deposit(loan_amount, fee_amount);
}
if (keccak256(userData) == keccak256("0x2")){
_withdraw(loan_amount, fee_amount);
}
}
//1. rapay aave with flashloaned amount,    mx
//2. withdraw steth with current ltv,  x
//3. change all steths to eths,    x         
//4. repay flashloan.   pay amx, left x-amx eth
function _withdraw(uint256 amount, uint256 fee_amount) internal{
uint256 steth_amount = amount.safeMul(IERC20(asteth).balanceOf(address(this))).safeDiv(getDebt());
if (IERC20(weth).allowance(address(this), aave) != 0) {IERC20(weth).safeApprove(aave, 0);}
IERC20(weth).safeApprove(aave, amount);
IAAVE(aave).repay(weth, amount, 2, address(this));
IAAVE(aave).withdraw(lido, steth_amount, address(this));
if (IERC20(lido).allowance(address(this), curve_pool) != 0) {IERC20(lido).safeApprove(curve_pool, 0);}
IERC20(lido).safeApprove(curve_pool, steth_amount);
ICurve(curve_pool).exchange(1, 0, steth_amount, 0);
(bool status, ) = weth.call.value(amount.safeAdd(fee_amount))("");
require(status, "transfer eth failed");
IERC20(weth).safeTransfer(balancer, amount.safeAdd(fee_amount));
}
...
function withdraw(uint256 _amount) public nonReentrant{
require(IERC20(ef_token).balanceOf(msg.sender) >= _amount, "not enough balance");
if (is_paused){
uint256 to_send = address(this).balance.safeMul(_amount).safeDiv(IERC20(ef_token).totalSupply());
(bool status, ) = msg.sender.call.value(to_send)("");
require(status, "transfer eth failed");
TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount);
return;
}
_earnReward();
uint256 loan_amount = getDebt().safeMul(_amount).safeDiv(IERC20(ef_token).totalSupply());
address[] memory tokens = new address[](1);
uint256[] memory amounts = new uint256[](1);
bytes memory userData = "0x2";
    tokens[0] = weth;
    amounts[0] = loan_amount;
//uint256 user_eth_before = msg.sender.balance;
IBalancer(balancer).flashLoan(address(this), tokens, amounts, userData);
// call flashloan first to make vault retain enough ETH.
uint256 to_send = address(this).balance; //vulnerable point
(bool status, ) = msg.sender.call.value(to_send)(""); //vulnerable point
require(status, "transfer eth failed");
TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount);
emit CFFWithdraw(msg.sender, to_send, _amount, getVirtualPrice());
}
​,Root cause: insufficient validation.
MEVFlashloansInsufficient validation,20221014,MEVBOTa47b,https://web3sec.notion.site/Insufficient-validation-f1b3a9f5d3914151b928a53b36741488?pvs=25,$241 k,https://github.com/SunWeb3Sec/DeFiHackLabs#20221014-mevbota47b---mevbot-a47b,,No Code,Root cause: insufficient validation.
ERC20Pricemanipulation,20221012,ATK,https://web3sec.notion.site/Incorrect-price-calculation-via-balanceOf-4dc3898d9dc549c79178174ba38a4bcf?pvs=25,$127 k,https://github.com/SunWeb3Sec/DeFiHackLabs#20221012-atk---flashloan-manipulate-price,,SolidityCopyfunction getPrice() public view returns(uint256){
uint256 UDPrice;
uint256 UDAmount  = balanceOf(_uniswapV2Pair); //vulnerable point
uint256 USDTAmount = USDT.balanceOf(_uniswapV2Pair); //vulnerable point
        UDPrice = UDAmount.mul(10**18).div(USDTAmount);
return UDPrice;
​,
swapArbitrary call,20221011,Rabby wallet,https://web3sec.notion.site/Arbitrary-call-via-functionCallWithValue-5303e22cf8694040b90d5a3fab7cd0c2?pvs=25,$200,000,https://github.com/SunWeb3Sec/DeFiHackLabs#20221011-rabby-wallet-swaprouter---arbitrary-external-call-vulnerability,,No Code,Root cause: arbitrary external call vulnerability.
YieldAccess Control,20221011,Templedao,https://web3sec.notion.site/Incorrect-access-control-3d5c3607c06a4727a44fe6b41b454f3f?pvs=25,$2.3 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20221011-templedao---insufficient-access-control,,SolidityCopy/**
      * @notice For migrations to a new staking contract:
      *         1. User/DApp checks if the user has a balance in the `oldStakingContract`
      *         2. If yes, user calls this function `newStakingContract.migrateStake(oldStakingContract, balance)`
      *         3. Staking balances are migrated to the new contract, user will start to earn rewards in the new contract.
      *         4. Any claimable rewards in the old contract are sent directly to the user's wallet.
      * @param oldStaking The old staking contract funds are being migrated from.
      * @param amount The amount to migrate - generally this would be the staker's balance
      */
function migrateStake(address oldStaking, uint256 amount) external {. //vulnerable point
StaxLPStaking(oldStaking).migrateWithdraw(msg.sender, amount);
_applyStake(msg.sender, amount);
}
​,
Dex/AMMEconomic,20221011,Mango,https://web3sec.notion.site/Economic-issue-8f2f61948c344594b01cd9b6f893c15d?pvs=25,$47 M,,,No Code,Root cause: Economic issue 
YieldArbitrary call,20221010,Carrot,https://web3sec.notion.site/Incorrect-access-control-eb09a10fb5be48edabd21daf3caee8e8?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20221010-carrot---public-functioncall,,SolidityCopyfunction transReward(bytes memory data) public { //data is controllable
        pool.functionCall(data); //vulnerable point
}
​,Root cause: public function call, call transferowner 0xbf699b4b. All wallets granted approvals are impacted.
GovernanceMaliciosProposal,20221009,Xave Finance,https://web3sec.notion.site/DaoModule-misconfiguration-68485c88e51f474d800137065ae9423c?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20221009-xave-finance---malicious-proposal-mint--transfer-ownership,,JavaScriptCopy"function": "mint(address,uint256)",
"params": [
"0x0f44f3489D17e42ab13A6beb76E57813081fc1E2",
"100000000000000000000000000000000"
]
{
"function": "transferOwnership(address)",
"params": [
"0x0f44f3489D17e42ab13A6beb76E57813081fc1E2"
]
}
​,Rroot cause: Gnosis Safe DAOModule compromised
ERC20FlashloansPricemanipulation,20221006,RES token,https://web3sec.notion.site/Incorrect-reward-calculation-74a98b419d2c4b949cdd6b49c0306ead?pvs=25,$290K,https://github.com/SunWeb3Sec/DeFiHackLabs#20221006-RES-Token---pair-manipulate,,SolidityCopy​,Root cause: thisAToB(), burn RES token to increase exchange ratio.
Dex/AMMInsufficient validation,20221002,Transit Swap,https://web3sec.notion.site/Incorrect-owner-address-validation-925ff7410bf74788960166798b41fecf?pvs=25,$21 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20221002-transit-swap---incorrect-owner-address-validation,,No Code,Root cause: Incorrect owner address validation
Dex/AMMInsufficient validation,20221001,BabySwap,https://web3sec.notion.site/Insufficient-validation-bcb846db6dd7474996c0ae6af98b125f?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20221001-babyswap---parameter-access-control,,SolidityCopyfunction swapExactTokensForTokens(
uint amountIn,
uint amountOutMin,
address[] memory path,
address[] memory factories,
uint[] memory fees,
address to,
uint deadline
    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {
        amounts = BabyLibrarySmartRouter.getAggregationAmountsOut(factories, fees, amountIn, path);
require(amounts[amounts.length - 1] >= amountOutMin, 'BabyRouter: INSUFFICIENT_OUTPUT_AMOUNT');
        amounts[0] = routerFee(factories[0], msg.sender, path[0], amounts[0]);
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, BabyLibrarySmartRouter.pairFor(factories[0], path[0], path[1]), amounts[0]
);
_swap(amounts, path, factories, to); //vulnerable point - Insufficient validation
}
​,Root cause: Insufficient validation
ERC20FlashloansPricemanipulation,20221001,RL Token,https://web3sec.notion.site/Incorrect-Reward-calculation-b0235d6bfc774a53a0129c8631abac33?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20221001-RL-Token---Incorrect-Reward-calculation,unfixed,SolidityCopy​,Root cause: Incorrect Reward calculation
ERC721reentrancy,20221001,Thunder Brawl,https://web3sec.notion.site/Reentrancy-in-claimReward-9d31f794db744f29997da3c0e2c6ee5d?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20221001-thunder-brawl---reentrancy,unfixed,SolidityCopyfunction claimReward(
uint256 _ID,
address payable _player,
uint256 _amount,
bool _rewardStatus,
uint256 _x,
string memory name,
address _add
    ) external {
require(gameMode);
bool checkValidity = guess(_x, name, _add);
if (checkValidity == true) {
if (winners[_ID][_player] == _amount) {
                _player.transfer(_amount * 2);
if (_rewardStatus == true) {
sendReward(); //vulnerable point
}
delete winners[_ID][_player];
} else {
if (_rewardStatus == true) {
sendRewardDys();
}
}
            rewardStatus = false;
}
}
function sendReward() public {
        thunderbrawlRoulette.reward(msg.sender, 1);
}
​,Root cause: claimReward() - rewards are being drained due to a reentrancy bug.
lendingDex/AMMFlashloansPricemanipulation,20220928,BXH,https://web3sec.notion.site/Incorrect-reward-calculation-ad19efe30a0c40cc8b74ac5a8d0b7853?pvs=25,$40,305,https://github.com/SunWeb3Sec/DeFiHackLabs#20220928-bxh---flashloan--price-oracle-manipulation,,SolidityCopy​,Root cause: Incorrect Reward calculation
ERC20Miscalculation,20220910,DPC,https://web3sec.notion.site/Incorrect-reward-calculation-a549ef3d16164ef5abe90c0b930fec63?pvs=25,$1.4 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220910-dpc---Incorrect-Reward-calculation,,SolidityCopyfunction claimStakeLp(address _from ,uint256 Amountwei) public {
require(Amountwei > 0,"Quantity error");
require(_from==msg.sender,"error");
require(dpcLp[_from] >= Amountwei ,"Insufficient authorization limit");
IERC20(LpContract).transfer(_from,Amountwei);

                oldClaimQuota[_from] = oldClaimQuota[_from].add(getClaimQuota(_from)); //vulnerable point

                dpcLp[_from] = dpcLp[_from].sub(Amountwei);

                time=currTimeStamp();
                dpcLpTime[_from] = time;

                dpcLpTotal = dpcLpTotal.sub(Amountwei);
}
function getClaimQuota(address addr) public view returns (uint256) {
uint256 ClaimQuota;
if(dpcAirdrop[addr] > 0 && dpcLp[addr]>0){
uint256 QuotastartTime;
uint256 limit = 50 * 10**18;
uint256 LpQuotaNum = dpcLp[addr].mul(getLpPrice()).mul(lpQuota).div(100);
uint256 secondQuota;
if(getDpcPrice()>0){
                        secondQuota = LpQuotaNum.div(24*60*60).div(getDpcPrice());
}
uint256 limitSecondQuota = limit.div(24*60*60);
if(secondQuota > limitSecondQuota){
                        secondQuota = limitSecondQuota;
}
uint256 nowTime = currTimeStamp();
if(dpcLpTime[addr]>ClaimQuotaTime[addr]){
                        QuotastartTime = dpcLpTime[addr];
}else{
                        QuotastartTime = ClaimQuotaTime[addr];
}
                    ClaimQuota = (nowTime.sub(QuotastartTime)).mul(secondQuota);
if(ClaimQuota > dpcAirdrop[addr]){
                        ClaimQuota = dpcAirdrop[addr];
}
}else{
                    ClaimQuota = 0;
}
               ClaimQuota = ClaimQuota.add(oldClaimQuota[addr]); //vulnerable point
return ClaimQuota;
}
​,Root cause: Incorrect Reward calculation
MEVArbitrary call,20220928,MEVBOT - Badc0de,https://web3sec.notion.site/Arbitrary-call-via-callFunction-d5772d187dfd4534b7b28bbb8c263839?pvs=25,$94,304,https://github.com/SunWeb3Sec/DeFiHackLabs#20220928-MEVBOT---Badc0de,,No Code,Root cause: Arbitrary call via callFunction.
ERC20FlashloansPricemanipulation,20220923,RADT-DAO,https://web3sec.notion.site/Front-running-c6a831e7fb9b4792a58f1655d36f159d?pvs=25,$94,304,https://github.com/SunWeb3Sec/DeFiHackLabs#20220923-RADT-DAO---pair-manipulate,,No Code,Root cause: front running
MEVAccess Control,20220913,MevBot private tx,https://web3sec.notion.site/Incorrect-access-control-62df718c5a0942baa0b6aa45080c8d90?pvs=25,$140 K,https://github.com/SunWeb3Sec/DeFiHackLabs#20220913-mevbot-private-tx,,JavaScriptCopyfunction 0x10a(uint256 varg0, uint256 varg1, uint256 varg2) private {
require(varg0.data + varg0.length - varg0.data >= 96);
require(MEM[varg0.data] == address(MEM[varg0.data]));
    v0 = v1 = MEM[varg0.data + 64];
if (0 == varg2) {
        v2, v3 = msg.sender.token1().gas(msg.gas);
require(v2); // checks call status, propagates error data on error
require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
require(v3 == address(v3));
        goto 0x214;
} else {
        v4, v3 = msg.sender.token0().gas(msg.gas);
require(v4); // checks call status, propagates error data on error
require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
require(v3 == address(v3));
}
if (varg2) {
}
    v5, v6 = address(v3).transfer(address(MEM[varg0.data]), varg1).gas(msg.gas); //vulnerable point
}
​,
ERC20FlashloansPricemanipulationreward,20220909,YYDS,https://web3sec.notion.site/Incorrect-price-calculation-via-balanceOf-bb8dc28a6a174e50996bed7d7f851eeb?pvs=25,$742,286,https://github.com/SunWeb3Sec/DeFiHackLabs#20220909-YYDS---pair-manipulate,,No Code,
Deflationary tokenFlashloansPricemanipulation,20220928,Ragnarok Online Invasion,https://web3sec.notion.site/Incorrect-access-control-d5e6d1a8b41e4a5d935dc0bf86e8375e?pvs=25,$44,000,https://github.com/SunWeb3Sec/DeFiHackLabs#20220908-ragnarok-online-invasion---broken-access-control,,SolidityCopyfunction transferOwnership(address newOwner) public virtual {
require(newOwner != address(0), "Ownable: new owner is the zero address");
emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
}
​,Root cause: Incorrect access control
ERC20FlashloansPricemanipulationreward,20220908,NewFreeDAO,https://web3sec.notion.site/Incorrect-reward-calculation-7f373b865943410ab75a405327461193?pvs=25,$125M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220908-newfreedao---flashloans-attack,,SolidityCopyfunction 0x6811e3b9() public nonPayable {
require(_isAirAddr.code.size);
    v0, v1 = _isAirAddr.balanceOf(msg.sender).gas(msg.gas);
require(v0); // checks call status, propagates error data on error
require(RETURNDATASIZE() >= 32);
require(v1 > 0, 'Amount can not be Zero');
if (owner_d[msg.sender] <= 0) {
        owner_d[msg.sender] = stor_6;
}
    v2 = _SafeDiv(stor_8, block.timestamp - owner_d[msg.sender]);
require(v2 > 0, 'The collection time was not reached');
    v3 = v4 = 0;
if (block.timestamp > stor_7) { //vulnerable point
if (v2 > 0) {
            v5 = 0x3182(stor_b, v1);
            v3 = v6 = _SafeDiv(0xf4240, v5);
}
} else if (v2 > 0) { //vulnerable point
        v7 = 0x3182(stor_b, v1);
        v8 = 0x3182(v2, v7);
        v3 = v9 = _SafeDiv(0xf4240, v8);
}
require(_isAirAddr.code.size);
    v10, v11 = _isAirAddr.transfer(msg.sender, v3).gas(msg.gas);
require(v10); // checks call status, propagates error data on error
require(RETURNDATASIZE() >= 32);
    owner_d[msg.sender] = block.timestamp;
}
​,Root cause: Incorrect reward calculation
ERC20FlashloansPricemanipulation,20220906,NXUSD,https://web3sec.notion.site/Incorrect-price-calculation-a4313a596d53407a80c25958fa3972fa?pvs=25,$50,000,https://github.com/SunWeb3Sec/DeFiHackLabs#20220906-NXUSD---flashloan-price-oracle-manipulation,fixed,SolidityCopyfunction _get() internal view returns (uint256) {
uint256 usdcPrice = uint256(USDC.latestAnswer());
uint256 avaxPrice = uint256(AVAX.latestAnswer());
(uint112 wavaxReserve, uint112 usdcReserve, ) = joePair.getReserves();
//vulnerable point
uint256 price = (wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply()); //vulnerable point
return 1e26 / price;
}
​,Root cause:  Incorrect price calculation 
FlashloansPricemanipulationInsufficient validation,20220905,ZoomproFinance,https://web3sec.notion.site/No-verification-of-token-authenticity-82cb415802fe47659fa3af0766496341?pvs=25,$61,160 USDT,https://github.com/SunWeb3Sec/DeFiHackLabs#20220905-zoomprofinance---flashloans--price-manipulation,unfixed?,No Code,Root cause: Insufficient validation
paymentAccess Control,20220902,ShadowFi,https://web3sec.notion.site/Incorrect-access-control-7244a94c84e440b5b2589328ef45901f?pvs=25,1,078 BNB,https://github.com/SunWeb3Sec/DeFiHackLabs#20220902-shadowfi---access-control,,SolidityCopyfunction burn(address account, uint256 _amount) public { //vulnerable point
_transferFrom(account, DEAD, _amount);
emit burnTokens(account, _amount);
}
​,Root cause: incorrect access control.
NFTInsufficient validation,20220902,Bad Guys by RPF,https://web3sec.notion.site/Missing-check-for-chosenAmount-in-the-WhiteListMint-function-d76a780fa38b4a6cab5425cea9469359?pvs=25,400 NFTs,https://github.com/SunWeb3Sec/DeFiHackLabs#20220902-bad-guys-by-rpf---business-logic-flaw--missing-check-for-number-of-nft-to-mint,,SolidityCopy​,Root cause: Insufficient validation
NFTBad randomness,20220824,LuckeyTiger ,https://web3sec.notion.site/Bad-randomness-b3416b46eedd43389d30ec8071e147b2?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20220824-luckeytiger-nft---predicting-random-numbers,,SolidityCopy​,Root cause: bad randomness.
StablecoinFlashloansPricemanipulationreward,20220810,XSTABLE Protocol,https://web3sec.notion.site/Incorrect-Logic-Check-get-rewards-over-skim-9b0f00c5bce6438882813e65a455dd58?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20220810-xstable-protocol---incorrect-logic-check,,JavaScriptCopyfunction _getTxType(address sender, address recipient, bool lpBurn) private returns(uint256) {
        uint256 txType = 2;
if (isSupportedPool(sender)) {
if (lpBurn) {
                txType = 3;
} else {
 txType = 1; //return 
}
} else if (sender == Constants.getRouterAdd()) {
            txType = 3;
}
return txType;
}
function _transfer(address sender, address recipient, uint256 amount) private pausable {
require(sender != address(0), "ERC20: transfer from the zero address");
require(recipient != address(0), "ERC20: transfer to the zero address");
require(amount > 0, "Amount must be greater than zero");
require(amount <= balanceOf(sender),"Amount exceeds balance");
require(amount <= unlockedBalanceOf(sender),"Amount exceeds unlocked balance");
require(isPresaleDone(),"Presale yet to close");
if (now > getCurrentEpoch().add(Constants.getEpochLength())) updateEpoch();
        uint256 currentFactor = getFactor();
        uint256 largeAmount = amount.mul(currentFactor);
        uint256 txType;
if (isTaxLess()) {
            txType = 3;
} else {
            bool lpBurn;
if (isSupportedPool(sender)) {
                lpBurn = syncPair(sender);
} else if (isSupportedPool(recipient)){
silentSyncPair(recipient);
} else {
silentSyncPair(_mainPool);
}
            txType = _getTxType(sender, recipient, lpBurn);
}
// Buy Transaction from supported pools - requires mint, no utility fee
if (txType == 1) {
_implementBuy(sender, recipient, amount, largeAmount, currentFactor); //vulnerable point
}
// Sells to supported pools or unsupported transfer - requires exit burn and utility fee
else if (txType == 2) {
_implementSell(sender, recipient, amount, largeAmount, currentFactor);
}
// Add Liquidity via interface or Remove Liquidity Transaction to supported pools - no fee of any sort
else if (txType == 3) {
            _largeBalances[sender] = _largeBalances[sender].sub(largeAmount);
            _largeBalances[recipient] = _largeBalances[recipient].add(largeAmount);
            emit Transfer(sender, recipient, amount);
}
}
​,Root cause: Incorrect Logic Check, get rewards over skim()
ERC20FlashloansrewardInsufficient validation,20220809,ANCH,https://web3sec.notion.site/Insufficient-validation-get-rewards-over-skim-f8b2f75dc14e4268b9252b48ae1a7473?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20220809-anch---skim-token-balance,,JavaScriptCopy//this method is responsible for taking all fee, if takeFee is true
function _transfer( //vulnerable point - recipient and sender can the same
        address sender,
        address recipient,
        uint256 tAmount
    ) private {
require(sender != address(0), "ERC20: transfer from the zero address");
require(recipient != address(0), "ERC20: transfer to the zero address");
require(tAmount > 0, "Transfer amount must be greater than zero");
// Insufficient validation. sender and recipient can be same.
if(sender == uniswapV2Pair) {
_tokenBuyTransferReward(sender, recipient, tAmount);
} else if(recipient == uniswapV2Pair) {
_tokenSellTransferReward(sender, recipient, tAmount);
} else{

            uint256 currentRate = _getRate();
            uint256 rAmount = tAmount.mul(currentRate);
            _rOwned[sender] = _rOwned[sender].sub(rAmount);
            _rOwned[recipient] = _rOwned[recipient].add(rAmount);
            
            emit Transfer(sender, recipient, tAmount);
}
​,Root cause: insufficient validation , get rewards over skim()
Dex/AMMFlashloansPricemanipulation,20220807,EGD Finance,https://web3sec.notion.site/Incorrect-price-calculation-via-balanceOf-a07d59bcb25b48b58e306f7bf9e353f1?pvs=25,$36,044,https://github.com/SunWeb3Sec/DeFiHackLabs#20220807-egd-finance---flashloans--price-manipulation,,JavaScriptCopyfunction claimAllReward() external {
require(userInfo[msg.sender].userStakeList.length > 0, 'no stake');
require(!black[msg.sender],'black');
        uint[] storage list = userInfo[msg.sender].userStakeList;
        uint rew;
        uint outAmount;
        uint range = list.length;
for (uint i = 0; i < range; i++) {
            UserSlot storage info = userSlot[msg.sender][list[i - outAmount]];
require(info.totalQuota != 0, 'wrong index');
            uint quota = (block.timestamp - info.claimTime) * info.rates;
if (quota >= info.leftQuota) {
                quota = info.leftQuota;
}
            rew += quota * 1e18 / getEGDPrice(); // check getEGDPrice()
            info.claimTime = block.timestamp;
            info.leftQuota -= quota;
            info.claimedQuota += quota;
if (info.leftQuota == 0) {
                userInfo[msg.sender].totalAmount -= info.totalQuota;
delete userSlot[msg.sender][list[i - outAmount]];
                list[i - outAmount] = list[list.length - 1];
                list.pop();
                outAmount ++;
}
}
function getEGDPrice() public view returns (uint){
        uint balance1 = EGD.balanceOf(pair); //vulnerable point
        uint balance2 = U.balanceOf(pair); //vulnerable point
return (balance2 * 1e18 / balance1);
}
​,Root cause: Incorrect price calculation by balanceOf
BridgeInsufficient validationuninitialized,20220802,Nomad Bridge,https://web3sec.notion.site/Incorrect-acceptable-merkle-root-checks-810dcc984f724255b8991ea797eb66b7?pvs=25,$152M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220802-nomad-bridge---business-logic-flaw--incorrect-acceptable-merkle-root-checks,fixed,JavaScriptCopy
function initialize(
uint32 _remoteDomain,
        address _updater,
        bytes32 _committedRoot,
        uint256 _optimisticSeconds
) public initializer {
__NomadBase_initialize(_updater);
// set storage variables
        entered = 1;
        remoteDomain = _remoteDomain;
        committedRoot = _committedRoot;
// pre-approve the committed root.
confirmAt[_committedRoot] = 1; 
_setOptimisticTimeout(_optimisticSeconds);
}
function process(bytes memory _message) public returns (bool _success) {
// ensure message was meant for this domain
        bytes29 _m = _message.ref(0);
require(_m.destination() == localDomain, "!destination");
// ensure message has been proven
        bytes32 _messageHash = _m.keccak();
// messages[_messageHash] 0x00 by default //vulnerable point
 require(acceptableRoot(messages[_messageHash]), "!proven");

​,
ERC4626Access Control,20220801,Reaper Farm,https://web3sec.notion.site/Incorrect-access-control-2fc3ef0f4fce4a2596bb3c9a8ca1c69e?pvs=25,$1.7M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220801-reaper-farm---business-logic-flaw--lack-of-access-control-mechanism,fixed,JavaScriptCopyfunction _withdraw(uint256 assets, uint256 shares, address receiver, address owner) internal returns (uint256) { //vulnerable point
_burn(owner, shares);
​,Root cause: without proper access control, allowing anyone to withdraw anyone else’s funds.
ERC20FlashloansInsufficient validation,20220725,LPC,https://web3sec.notion.site/Incorrect-recipient-balance-check-341979a8a0cd4f1aa8c8421a9eae618b?pvs=25,$45K,https://github.com/SunWeb3Sec/DeFiHackLabs#20220725-lpc---business-logic-flaw--incorrect-recipient-balance-check-did-not-check-senderrecipient-in-transfer,unfixed,JavaScriptCopyfunction _transfer(
...
totalHolders = totalHolders_;

        _balances[sender] = senderBalance.sub(amount);
        _balances[recipient] = recipientBalance.add(recipientAmount);
        emit Transfer(sender, recipient, recipientAmount);
_afterTokenTransfer(sender, recipient, amount);
}
​,Root cause: Incorrect recipient balance check, did not check sender!=recipient in transfer.
ERC20uninitializedGovernanceＳtorage collision,20220723,Audius,https://web3sec.notion.site/Storage-Collision-Malicious-Proposal-630c7104e4554aef966c5186d1336e29?pvs=25,$6M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220723-audius---storage-collision--malicious-proposal,fixed,SolidityCopy/**
   * @dev Modifier to use in the initializer function of a contract.
   */
modifier initializer() {
require(msg.sender == proxyAdmin, "Only proxy admin can initialize");
require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");
bool isTopLevelCall = !initializing;
if (isTopLevelCall) {
      initializing = true;
      initialized = true;
}
_;
if (isTopLevelCall) {
      initializing = false;
}
}
​,Root cause: Storage Collision & Malicious Proposal
ERC20FlashloansPricemanipulationAccess Control,20220713,SpaceGodzilla,https://web3sec.notion.site/Incorrect-access-control-d74bce69e67f4cb3bc49d38d76bc68b6?pvs=25,$26,000,https://github.com/SunWeb3Sec/DeFiHackLabs#20220713-spacegodzilla---flashloans--price-manipulation,,SolidityCopyfunction swapAndLiquifyStepv1() public { //vulnerable point
uint256 ethBalance = ETH.balanceOf(address(this));
uint256 tokenBalance = balanceOf(address(this));
addLiquidityUsdt(tokenBalance, ethBalance);
}
​,Root cause: incorrect access control.
ERC721Flashloansreentrancy,20220710,Omni NFT,https://web3sec.notion.site/Reentrancy-safeTransferFrom-in-burn-function-7dcaf8a7c9c34cf9b6b25d8a6f82fb55?pvs=25,$1.4M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220710-omni-nft---reentrancy,,SolidityCopyfunction executeWithdrawERC721(
mapping(address => DataTypes.ReserveData) storage reservesData,
mapping(uint256 => address) storage reservesList,
        DataTypes.UserConfigurationMap storage userConfig,
        DataTypes.ExecuteWithdrawERC721Params memory params
    ) external returns (uint256) {
        DataTypes.ReserveData storage reserve = reservesData[params.asset];
        DataTypes.ReserveCache memory reserveCache = reserve.cache();

        reserve.updateState(reserveCache);
uint256 amountToWithdraw = params.tokenIds.length;
bool withdrwingAllCollateral = INToken(reserveCache.xTokenAddress).burn(
            msg.sender,
            params.to,
            params.tokenIds,
            reserveCache.nextLiquidityIndex
        );
​,Root cause: safeTransferFrom in burn function. project without nonReentrant protection.
NFTMarketplaceInsufficient validationSignature,20220701,Quixotic,https://web3sec.notion.site/fillSellOrder-function-only-check-seller-signature-a82bc25031394e9c99fc3babcd6be026?pvs=25,$100K,https://github.com/SunWeb3Sec/DeFiHackLabs#20220701-quixotic---optimism-nft-marketplace,,SolidityCopy/*
    * @dev External trade function. This accepts the details of the sell order and signed sell
    * order (the signature) as a meta-transaction.
    *
    * Emits a {SellOrderFilled} event via `_fillSellOrder`.
    */
function fillSellOrder(
address payable seller,
address contractAddress,
uint256 tokenId,
uint256 startTime,
uint256 expiration,
uint256 price,
uint256 quantity,
uint256 createdAtBlockNumber,
address paymentERC20,
bytes memory signature,
address payable buyer
    ) external payable whenNotPaused nonReentrant {
// If the payment ERC20 is the zero address, we check that enough native ETH has been sent
// with the transaction. Otherwise, we use the supplied ERC20 payment token.
if (paymentERC20 == address(0)) {
require(msg.value >= price, "Transaction doesn't have the required ETH amount.");
} else {
_checkValidERC20Payment(buyer, price, paymentERC20);
}

        SellOrder memory sellOrder = SellOrder(
            seller,
            contractAddress,
            tokenId,
            startTime,
            expiration,
            price,
            quantity,
            createdAtBlockNumber,
            paymentERC20
        );
/* Make sure the order is not cancelled */
require(
            cancellationRegistry.getSellOrderCancellationBlockNumber(seller, contractAddress, tokenId) < createdAtBlockNumber,
"This order has been cancelled."
);
/* Check signature */
require(_validateSellerSignature(sellOrder, signature), "Signature is not valid for SellOrder."); //vulnerable point
// Check has started
require((block.timestamp > startTime), "SellOrder start time is in the future.");
// Check not expired
require((block.timestamp < expiration), "This sell order has expired.");
_fillSellOrder(sellOrder, buyer);
}
​,Root cause: fillSellOrder function only check seller signature.
ERC721Insufficient validation,20220626,XCarnival,https://web3sec.notion.site/Insufficient-validation-c4b453b1122e45118f542a95511a6f0b?pvs=25,$3.87M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220626-xcarnival---infinite-number-of-loans,,SolidityCopyfunction pledgeAndBorrow(address _collection, uint256 _tokenId, uint256 _nftType, address xToken, uint256 borrowAmount) external nonReentrant {
uint256 orderId = pledgeInternal(_collection, _tokenId, _nftType);
IXToken(xToken).borrow(orderId, payable(msg.sender), borrowAmount); //vulnerable point
}
​,Root cause:  call XToken contract's borrow(), there is no judgment that the NFT has been withdrawn.
BridgeKeyCompromised,20220627,Harmony's Horizon,https://web3sec.notion.site/Private-key-compromised-12b9206fb3d84b1e9d6723c4a7fab100?pvs=25,$100M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220624-harmonys-horizon-bridge---private-key-compromised,,No Code,Root cause: private key compromised
ERC777Insufficient validation,20220618,SNOOD,https://web3sec.notion.site/Miscalculation-on-_spendAllowance-38caa4b040664580bb2536db5ad848a8?pvs=25,104 ETH,https://github.com/SunWeb3Sec/DeFiHackLabs#20220618-snood---miscalculation-on-_spendallowance,,SolidityCopyfunction _spendAllowance(address owner, address spender, uint256 amount) internal override {
        super._spendAllowance(owner, spender, _getStandardAmount(amount)); //vulnerable point
}
​,Root cause: miscalculation on _spendAllowance
lendingFlashloansPricemanipulation,20220616,InverseFinance,https://web3sec.notion.site/Incorrect-price-calculation-via-balanceOf-dfa8e72225504461b10825fab7bffc1f?pvs=25,$1.26M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220616-inversefinance---flashloan--price-oracle-manipulation,,SolidityCopy​,Root cause: Incorrect LP price calculation via balanceOf.
ERC20Access Control,20220608,GYMNetwork,https://web3sec.notion.site/Incorrect-access-control-de8519db95d94b0eadc1f4b23c87ae54?pvs=25,$2M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220608-gymnetwork---access-control,fixed,SolidityCopy/**
     * @notice Deposit in given pool
     * @param _depositAmount: Amount of want token that user wants to deposit
     */
function depositFromOtherContract(
uint256 _depositAmount,
uint8 _periodId,
bool isUnlocked,
address _from
    ) external external { //vulnerable point
require(isPoolActive,'Contract is not running yet');
_autoDeposit(_depositAmount,_periodId,isUnlocked,_from);
​,Root cause: Incorrect access control.
BridgeSignature,20220608,Wintermute,https://web3sec.notion.site/Signature-replay-68fc27bc497e4c508839d93646eeabf1?pvs=25,$3M OP,https://github.com/SunWeb3Sec/DeFiHackLabs#20220608-optimism---wintermute---signature-replay,fixed,SolidityCopy/// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.
/// @param masterCopy Address of master copy.
/// @param data Payload for message call sent to new proxy contract.
function createProxy(address masterCopy, bytes memory data)
public
returns (Proxy proxy)
{
        proxy = new Proxy(masterCopy);
if (data.length > 0)
// solium-disable-next-line security/no-inline-assembly
assembly {
if eq(call(gas, proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }
}
emit ProxyCreation(proxy);
}
​,Root cause: contract does not use eip155 to prevent replay attacks
ERC20FlashloansPricemanipulation,20220606,Discover,https://web3sec.notion.site/Incorrect-price-calculation-via-balanceOf-a5476f8e675d488480c5156a37332e80?pvs=25,$49 BNB,https://github.com/SunWeb3Sec/DeFiHackLabs#20220606-discover---flashloan--price-oracle-manipulation,,SolidityCopyfunction getprice() public view returns (uint256 _price) {
uint256 lpusdtamount=usdt.balanceOf(_lpaddr); //vulnerable point 
uint256 lpotheramount=other.balanceOf(_lpaddr); //vulnerable point
       
        _price=lpusdtamount*10**18/lpotheramount;
}
​,Root cause: Incorrect price calculation via balanceOf.
Deflationary tokenFlashloansPricemanipulation,20220529,NOVO Protocol,https://web3sec.notion.site/No-sender-address-validation-1aedb1fa88da4a9e8dfe11128bbf653d?pvs=25,279 BNB,https://github.com/SunWeb3Sec/DeFiHackLabs#20220529-novo-protocol---flashloan--price-oracle-manipulation,,SolidityCopy​,Root cause:  No sender address validation.
DAOFlashloansPricemanipulationskim,20220524,HackDao,https://web3sec.notion.site/Incorrect-logic-in-_transfer-function-of-token-contract-74f17f2adf084fd5a493e03aadd761ac?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20220524-hackdao---skim-token-balance,,SolidityCopyfunction _transfer(
address sender,
address recipient,
uint256 amount
    ) internal override virtual {
require(sender != address(0), "ERC20: transfer from the zero address");
require(recipient != address(0), "ERC20: transfer to the zero address");
_beforeTokenTransfer(sender, recipient, amount);
uint256 senderBalance = _balances[sender];
require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
        unchecked {
            _balances[sender] = senderBalance - amount;
}
uint256 actualAmount = amount;
if(parentAddress[recipient] == address(0) && recipient != uniswapV2Pair){
if(sender == uniswapV2Pair){
                parentAddress[recipient] = _defaultAddress;
}else{
                parentAddress[recipient] = sender;
}
}
if(!isWhiteListed(sender) && !isWhiteListed(recipient)){
uint256 fee = calculationFeeNum(amount,_feeRatio);
//sell
if(recipient == uniswapV2Pair){
require(senderBalance >= amount.add(fee), "ERC20: There are not enough charges for the account balance");
                unchecked {
                    _balances[sender] -= fee;
}
}else{
                actualAmount = amount - fee;
}
​,Root cause: Incorrect logic in _transfer  function of token contract.
ERC20FlashloansclaimTokens,20220517,ApeCoin,https://web3sec.notion.site/Incorrect-airdrop-calculation-26b27cd245d5410b966e108115acd78f?pvs=25,$1.1 million,https://github.com/SunWeb3Sec/DeFiHackLabs#20220517-apecoin-ape---flashloan,,SolidityCopyfunction claimTokens() external whenNotPaused {
require(block.timestamp >= claimStartTime && block.timestamp < claimStartTime + claimDuration, "Claimable period is finished");
require((beta.balanceOf(msg.sender) > 0 || alpha.balanceOf(msg.sender) > 0), "Nothing to claim");
uint256 tokensToClaim;
uint256 gammaToBeClaim;
(tokensToClaim, gammaToBeClaim) = getClaimableTokenAmountAndGammaToClaim(msg.sender); //vulnerable point, check reward
for(uint256 i; i < alpha.balanceOf(msg.sender); ++i) {
uint256 tokenId = alpha.tokenOfOwnerByIndex(msg.sender, i);
if(!alphaClaimed[tokenId]) {
                alphaClaimed[tokenId] = true;
emit AlphaClaimed(tokenId, msg.sender, block.timestamp);
}
}
function getClaimableTokenAmountAndGammaToClaim(address _account) private view returns (uint256, uint256)
{
uint256 unclaimedAlphaBalance;
for(uint256 i; i < alpha.balanceOf(_account); ++i) {
uint256 tokenId = alpha.tokenOfOwnerByIndex(_account, i);
if(!alphaClaimed[tokenId]) {
++unclaimedAlphaBalance;
}
​,Root cause: Incorrect airdrop calculation
lendingMaliciosProposalPricemanipulation,20220508,Fortress Loans,https://web3sec.notion.site/Insufficient-validation-in-submit-in-chain-contract-b534c0a5bfac4228872899c6df940890?pvs=25,$3 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220508-fortress-loans---malicious-proposal--price-oracle-manipulation,,SolidityCopyfunction submit(
uint32 _dataTimestamp,
bytes32 _root,
bytes32[] memory _keys,
uint256[] memory _values,
uint8[] memory _v,
bytes32[] memory _r,
bytes32[] memory _s
  ) public {
...
...
require(i >= requiredSignatures, "not enough signatures");
// we turn on power once we have proper DPoS
// require(power * 100 / staked >= 66, "not enough power was gathered");
​,Root cause: Insufficient validation in submit() in chain contract.
lendingPayableFlashloansreentrancy,20220430,Rari Capital,https://web3sec.notion.site/Not-follow-check-effect-interaction-pattern-9ef4ea8abce04fe0acd92b983b7dceec?pvs=25,$80 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220430-rari-capitalfei-protocol---flashloan-attack--reentrancy,,SolidityCopyfunction borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
...
/////////////////////////
// EFFECTS & INTERACTIONS
// (No safe failures beyond this point)
/*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
doTransferOut(borrower, borrowAmount); //vulnerable point
/* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;
/* We emit a Borrow event */
emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);
​,Root cause: Not follow check-effect-interaction pattern.
DAOFlashloansPricemanipulation,20220428,DEUS DAO,https://web3sec.notion.site/Incorrect-price-calculation-via-balanceOf-b108cc53c77943f9b8a001d53ff8f599?pvs=25,$13 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220428-deus-dao---flashloan--price-oracle-manipulation,,SolidityCopy/// @notice returns on chain LP price
function getOnChainPrice() public view returns (uint256) {
return
((dei.balanceOf(address(pair)) * IBaseV1Pair(address(pair)).getAmountOut(1e18, address(dei)) * 1e12 / 1e18) + (usdc.balanceOf(address(pair)) * 1e12)) * 1e18 / pair.totalSupply();//vulnerable point
}
​,Root cause:  Incorrect price calculation via balanceOf.
Deflationary tokenFlashloans,20220424,Wiener DOGE,https://web3sec.notion.site/LPs-should-be-excluded-from-fees-and-token-burns-312959e4ffb54bd3ae723a89bfef4ca1?pvs=25,78 BNB,https://github.com/SunWeb3Sec/DeFiHackLabs#20220424-wiener-doge---flashloan,,SolidityCopyfunction _transfer(address sender, address recipient, uint256 amount) internal virtual returns (bool) {
require(_balances[sender].amount >= amount, "ERC20: transfer amount exceeds balance");
require(sender != address(0), "ERC20: transfer from the zero address");
require(recipient != address(0), "ERC20: transfer to the zero address");
if(block.timestamp >=  openingTime && block.timestamp <= closingTime)
{
            _balances[sender].amount -= amount;
            _balances[recipient].amount += amount;
emit Transfer(sender, recipient, amount);
}
else
{
uint256 onePercent = findOnePercent(amount);
uint256 tokensToBurn = onePercent *4; // deflationary
uint256 tokensToRedistribute = onePercent * 4;
uint256 toFeeWallet = onePercent*1;
uint256 todev = onePercent* 1;
uint256 tokensToTransfer = amount - tokensToBurn - tokensToRedistribute - toFeeWallet-todev;

            _balances[sender].amount -= amount;
            _balances[recipient].amount += tokensToTransfer;
            _balances[feeWallet].amount += toFeeWallet;
            _balances[dev].amount  += todev;
if (!_balances[recipient].exists){
                _balanceOwners.push(recipient);
                _balances[recipient].exists = true;
}
redistribute(sender, tokensToRedistribute);
_burn(sender, tokensToBurn); // burn
emit Transfer(sender, recipient, tokensToTransfer);
}
return true;
​,Root cause: LPs should be excluded from fees and token burns.
ERC721DoS,20220423,Akutar NFT,https://web3sec.notion.site/Incorrect-validation-and-External-calls-can-fail-deliberately-a6113455c79546a588ba7ce3dea04225?pvs=25,$34 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220423-akutar-nft---denial-of-service,,SolidityCopyfunction processRefunds() external {
require(block.timestamp > expiresAt, "Auction still in progress");
uint256 _refundProgress = refundProgress;
uint256 _bidIndex = bidIndex;
require(_refundProgress < _bidIndex, "Refunds already processed");
uint256 gasUsed;
uint256 gasLeft = gasleft();
uint256 price = getPrice();
for (uint256 i=_refundProgress; gasUsed < 5000000 && i < _bidIndex; i++) {
          bids memory bidData = allBids[i];
if (bidData.finalProcess == 0) {
uint256 refund = (bidData.price - price) * bidData.bidsPlaced;
uint256 passes = mintPassOwner[bidData.bidder];
if (passes > 0) {
                refund += mintPassDiscount * (bidData.bidsPlaced < passes ? bidData.bidsPlaced : passes);
}
            allBids[i].finalProcess = 1;
if (refund > 0) {
(bool sent, ) = bidData.bidder.call{value: refund}(""); // low-lecel call
require(sent, "Failed to refund bidder");
​,Root cause: Incorrect validation and External calls can fail deliberately.
lendingDex/AMMFlashloansreward,20220421,Zeed Finance,https://web3sec.notion.site/Incorrect-reward-calculation-6d7393fa230e498496350d3c6df74e1f?pvs=25,$1 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220421-zeed-finance---reward-distribution-flaw,,SolidityCopyfunction _takeReward(
address sender,
uint256 rewardFee
    ) private {
if (rewardFee == 0) return;
uint256 zeedReward = rewardFee.div(2);
uint256 hoReward = rewardFee.div(2).div(2);
uint256 usdtReward = rewardFee.sub(zeedReward).sub(hoReward);

        _balances[swapPair] = _balances[swapPair].add(rewardFee); //vulnerable point
emit Transfer(sender, swapPair, usdtReward);

        _balances[swapPairZeed] = _balances[swapPairZeed].add(rewardFee); //vulnerable point
emit Transfer(sender, swapPairZeed, zeedReward);

        _balances[swapPairHo] = _balances[swapPairHo].add(rewardFee); //vulnerable point
emit Transfer(sender, swapPairHo, hoReward);
}
​,Root cause: incorrect reward calculation.
StablecoinDAOFlashloansMaliciosProposal,20220416,BeanstalkFarms,https://web3sec.notion.site/Insufficient-validation-6b5e9346852f4ad3832f3b9ac7786148?pvs=25,$182 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220416-beanstalkfarms---dao--flashloan,fixed,No Code,Root cause: insufficient validation
lendingAccess ControlPricemanipulation,20220415,Rikkei Finance,https://web3sec.notion.site/Incorrect-access-control-650d981609f749adbb52a390009b2804?pvs=25,$1.1 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220415-rikkei-finance---access-control--price-oracle-manipulation,,SolidityCopyfunction setOracleData(address rToken, oracleChainlink _oracle) external { //vulnerable point
        oracleData[rToken] = _oracle;
}
​,Root cause: incorrect access control
YieldArbitrary call,20220326,Auctus,https://web3sec.notion.site/Arbitrary-call-via-write-db8960d37be44af4aa7efc3a9d35d0e0?pvs=25,$726 K,https://github.com/SunWeb3Sec/DeFiHackLabs#20220326-auctus,,SolidityCopyfunction write(
address acoToken,
uint256 collateralAmount,
address exchangeAddress,
bytes memory exchangeData 
    ) 
        nonReentrant 
        setExchange(exchangeAddress)
public
payable
{
require(msg.value > 0, "ACOWriter::write: Invalid msg value");
require(collateralAmount > 0, "ACOWriter::write: Invalid collateral amount");
address _collateral = IACOToken(acoToken).collateral();
if (_isEther(_collateral)) {
IACOToken(acoToken).mintToPayable{value: collateralAmount}(msg.sender);
} else {
_transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);
_approveERC20(_collateral, acoToken, collateralAmount);
IACOToken(acoToken).mintTo(msg.sender, collateralAmount);
}
_sellACOTokens(acoToken, exchangeData);
}
/**
     * @dev Internal function to sell the ACO tokens and transfer the premium to the transaction sender.
     * @param acoToken Address of the ACO token.
     * @param exchangeData Data to be sent to the exchange.
     */
function _sellACOTokens(address acoToken, bytes memory exchangeData) internal {
uint256 acoBalance = _balanceOfERC20(acoToken, address(this));
_approveERC20(acoToken, erc20proxy, acoBalance);
(bool success,) = _exchange.call{value: address(this).balance}(exchangeData); //vulnerable point
require(success, "ACOWriter::_sellACOTokens: Error on call the exchange");
​,Root cause: arbitrary call via write().
lendingInsufficient validation,20220322,Compound,https://web3sec.notion.site/Insufficient-validation-d3d6bc6d348d43b39f7a6fb9acd3c40a?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20220322-compoundtusdsweeptokenbypass,,SolidityCopyfunction sweepToken(EIP20NonStandardInterface token) override external {
require(address(token) != underlying, "CErc20::sweepToken: can not sweep underlying token");
uint256 balance = token.balanceOf(address(this));
    token.transfer(admin, balance);
}
​,Root cause: Insufficient validation.
YieldFlashloansPricemanipulation,20220321,OneRing Finance,https://web3sec.notion.site/Incorrect-price-calculation-via-reverse-da622e54aadc477c94163943b597ebe2?pvs=25,$1.45 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220321-onering-finance---flashloan--price-oracle-manipulation,,SolidityCopyfunction getUSDBalanceFromUnderlyingBalance(uint256 _bal)
public
view
returns (uint256 _amount)
{
if (_bal > 0) {
address _token0 = IUniswapV2Pair(underlying).token0();
address _token1 = IUniswapV2Pair(underlying).token1();
(uint256 _reserves0, uint256 _reserves1, ) = IUniswapV2Pair(
                underlying
            ).getReserves();
uint256 _totalSupply = IERC20(underlying).totalSupply();
//vulnerable point
uint256 _amount0 = _reserves0.mul(_bal).div(_totalSupply); //vulnerable point
uint256 _amount1 = _reserves1.mul(_bal).div(_totalSupply); //vulnerable point
uint256 _vaultDecimals = ERC20(vault).decimals();
uint256 _vaultUnit = uint256(10)**uint256(_vaultDecimals);
uint256 _token0Unit = uint256(10) **
uint256(ERC20(_token0).decimals());
uint256 _token1Unit = uint256(10) **
uint256(ERC20(_token1).decimals());

            _amount =
                _amount0.mul(_vaultUnit).div(_token0Unit) +
                _amount1.mul(_vaultUnit).div(_token1Unit);
}
}
​,Root cause: Incorrect price calculation via reverse.
CrossChainBridgeAggregation,20220320,Li.Fi,https://web3sec.notion.site/Arbitrary-call-via-swap-726aa49cff9e4d15bdbb868cd0091428?pvs=25,$570 K,https://github.com/SunWeb3Sec/DeFiHackLabs#20220320-lifi---bridges,,SolidityCopyfunction swap(bytes32 transactionId, SwapData calldata _swapData) internal {
uint256 fromAmount = _swapData.fromAmount;
uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);
address fromAssetId = _swapData.sendingAssetId;
if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {
            LibAsset.transferFromERC20(_swapData.sendingAssetId, msg.sender, address(this), fromAmount);
}
if (!LibAsset.isNativeAsset(fromAssetId)) {
            LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);
}
// solhint-disable-next-line avoid-low-level-calls
(bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData); //vulnerable point
if (!success) {
string memory reason = LibUtil.getRevertMsg(res);
revert(reason);
}

        toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;
emit AssetSwapped(
            transactionId,
            _swapData.callTo,
            _swapData.sendingAssetId,
            _swapData.receivingAssetId,
            fromAmount,
            toAmount,
            block.timestamp
        );
}
​,Root cause: Arbitrary call via swap
OraclestakingUnder/Overflow,20220320,Umbrella Network,https://web3sec.notion.site/Arithmetic-Overflow-e344c6b2a9a14e8083892dcdc6a02e86?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20220320-umbrella-network---underflow,,SolidityCopy/// @param amount tokens to withdraw
/// @param user address
/// @param recipient address, where to send tokens, if we migrating token address can be zero
function _withdraw(uint256 amount, address user, address recipient) internal nonReentrant updateReward(user) {
require(amount != 0, "Cannot withdraw 0");
// not using safe math, because there is no way to overflow if stake tokens not overflow
        _totalSupply = _totalSupply - amount;
        _balances[user] = _balances[user] - amount; //vulnerable point, overflow
// not using safe transfer, because we working with trusted tokens
require(stakingToken.transfer(recipient, amount), "token transfer failed");
emit Withdrawn(user, amount);
}
​,Root cause: Arithmetic Overflow
lendingERC667reentrancy,20220313,Hundred Finance,https://web3sec.notion.site/Reentrancy-e4eb32be4f3a4a5d873b31901c07ceb1?pvs=25,$1.7 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220313-hundred-finance---erc667-reentrancy,,SolidityCopyfunction transfer(address _to, uint256 _value) public returns (bool) {
require(superTransfer(_to, _value));
callAfterTransfer(msg.sender, _to, _value); //vulnerable point
return true;
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
require(super.transferFrom(_from, _to, _value));
callAfterTransfer(_from, _to, _value); //vulnerable point
return true;
}
​,Root cause: Reentrancy
Dex/AMMFlashloansreentrancyInsufficient validation,20220313,Paraluni,https://web3sec.notion.site/Reentrancy-insufficient-validation-fb15aebd9db34279a3e1cacf27349f8b?pvs=25,$1.7 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220313-paraluni---flashloan--reentrancy,,SolidityCopyfunction depositByAddLiquidity(uint256 _pid, address[2] memory _tokens, uint256[2] memory _amounts) external{
require(_amounts[0] > 0 && _amounts[1] > 0, "!0");
address[2] memory tokens;
uint256[2] memory amounts;
(tokens[0], amounts[0]) = _doTransferIn(msg.sender, _tokens[0], _amounts[0]);
(tokens[1], amounts[1]) = _doTransferIn(msg.sender, _tokens[1], _amounts[1]);
depositByAddLiquidityInternal(msg.sender, _pid, tokens,amounts);
}
function depositByAddLiquidityInternal(address _user, uint256 _pid, address[2] memory _tokens, uint256[2] memory _amounts) internal {
        PoolInfo memory pool = poolInfo[_pid];
require(address(pool.ticket) == address(0), "T:E");
uint liquidity = addLiquidityInternal(address(pool.lpToken), _user, _tokens, _amounts);
_deposit(_pid, liquidity, _user);
}
​,Root cause: reentrancy & insufficient validation
SyntheticMiscalculation,20220309,Fantasm Finance,https://web3sec.notion.site/Incorrect-calculation-due-to-wrong-decimal-4d02bd9ebe9e43b08b52871e9967f53c?pvs=25,$2.6 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220309-fantasm-finance---business-logic-in-mint,,SolidityCopyfunction mint(uint256 _fantasmIn, uint256 _minXftmOut) external payable nonReentrant {
require(!mintPaused, "Pool::mint: Minting is paused");
uint256 _ftmIn = msg.value;
address _minter = msg.sender;
(uint256 _xftmOut, , uint256 _minFantasmIn, uint256 _ftmFee) = calcMint(_ftmIn, _fantasmIn); //vulnerable point
require(_minXftmOut <= _xftmOut, "Pool::mint: slippage");
require(_minFantasmIn <= _fantasmIn, "Pool::mint: Not enough Fantasm input");
require(maxXftmSupply >= xftm.totalSupply() + _xftmOut, "Pool::mint: > Xftm supply limit");
...
/// @param _ftmIn Amount of FTM input.
/// @param _fantasmIn Amount of FSM input.
/// @return _xftmOut : the amount of XFTM output.
/// @return _minFtmIn : the required amount of FSM input.
/// @return _minFantasmIn : the required amount of FSM input.
/// @return _fee : the fee amount in FTM.
function calcMint(uint256 _ftmIn, uint256 _fantasmIn)
public
view
returns (
uint256 _xftmOut,
uint256 _minFtmIn,
uint256 _minFantasmIn,
uint256 _fee
        )
{
uint256 _fantasmPrice = oracle.getFantasmPrice();
require(_fantasmPrice > 0, "Pool::calcMint: Invalid Fantasm price");
if (collateralRatio == COLLATERAL_RATIO_MAX || (collateralRatio > 0 && _ftmIn > 0)) {
            _minFtmIn = _ftmIn;
            _minFantasmIn = (_ftmIn * (COLLATERAL_RATIO_MAX - collateralRatio) * PRICE_PRECISION) / collateralRatio / _fantasmPrice;
            _xftmOut = (_ftmIn * COLLATERAL_RATIO_MAX * (PRECISION - mintingFee)) / collateralRatio / PRECISION;
            _fee = (_ftmIn * mintingFee) / PRECISION;
} else {
            _minFantasmIn = _fantasmIn;
_xftmOut = (_fantasmIn * _fantasmPrice * COLLATERAL_RATIO_MAX * (PRECISION - mintingFee)) / PRECISION / (COLLATERAL_RATIO_MAX - collateralRatio) / PRICE_PRECISION; //vulnerable point
            _minFtmIn = (_fantasmIn * _fantasmPrice * collateralRatio) / (COLLATERAL_RATIO_MAX - collateralRatio) / PRICE_PRECISION;
            _fee = (_fantasmIn * _fantasmPrice * collateralRatio * mintingFee) / PRECISION / (COLLATERAL_RATIO_MAX - collateralRatio) / PRICE_PRECISION;
}
}
​,Root cause:  Incorrect calculation due to wrong decimal
ERC777lendingreentrancy,20220305,Bacon Protocol,https://web3sec.notion.site/Reentrancy-via-ERC777-hook-f04031dead164a79921637382d939faa?pvs=25,$1 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220305-bacon-protocol---reentrancy,fixed,SolidityCopy/**
    *   @dev Function lend moves assets on the (probably usdc) contract to our own balance
    *   - Before calling: an approve(address _spender (proxy), uint256 _value (0xffff)) function call must be made on remote contract
    *   @param amount The amount of USDC to be transferred
    *   @return the amount of poolTokens created
    */
function lend(
uint256 amount
    ) public nonReentrant returns (uint256) {
IERC20Upgradeable(ERCAddress).transferFrom(msg.sender, address(this), amount);

        poolLent = poolLent.add(amount);

        super._mint(msg.sender, amount);
return amount;
}
​,Root cause:  reentrancy in lend()
DAOInsufficient validation,20220303,TreasureDAO,https://web3sec.notion.site/Insufficient-validation-8c7aeca11e514333ab79843b3f32af6d?pvs=25,$470 k,https://github.com/SunWeb3Sec/DeFiHackLabs#20220303-treasuredao---zero-fee,,SolidityCopy​,Root cause:  Insufficient validation
DAOMaliciosProposal,20220214,BuildFinance,https://web3sec.notion.site/Malicious-proposal-1ed5b712eac64eaa8924b72da4174f86?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20220214-buildfinance---dao,,No Code,Root cause:  Malicious proposal
MetaverseAccess Control,20220208,Sandbox LAND,https://web3sec.notion.site/Incorrect-access-control-3c36741d1a784763bad5f8811cb0150f?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20220208-sandbox-land---access-control,,SolidityCopyfunction _burn(address from, address owner, uint256 id) public { //vulnerable point
require(from == owner, "not owner");
        _owners[id] = 2**160; // cannot mint it again
        _numNFTPerAddress[from]--;
emit Transfer(from, address(0), id);
}
​,Root cause:  incorrect access control.
CrossChainBridgeInsufficient validation,20220206,Meter,https://web3sec.notion.site/Insufficient-validation-4c37dc926acd40beb7ac5416d97add1b?pvs=25,$4.3 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220206-meter---bridge,,No Code,Root cause:  insufficient validation
CrossChainBridgelendingInsufficient validation,20220128,Qubit Finance,https://web3sec.notion.site/Insufficient-validation-802622a9c2ab4e40ae1af3ecc7e19b3a?pvs=25,$80 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20220128-qubit-finance---bridge-address0safetransferfrom-does-not-revert,fixed,JavaScriptCopyfunction deposit(uint8 destinationDomainID, bytes32 resourceID, bytes calldata data) external payable notPaused {
require(msg.value == fee, "QBridge: invalid fee");

        address handler = resourceIDToHandlerAddress[resourceID];
require(handler != address(0), "QBridge: invalid resourceID");

        uint64 depositNonce = ++_depositCounts[destinationDomainID];
IQBridgeHandler(handler).deposit(resourceID, msg.sender, data);
        emit Deposit(destinationDomainID, resourceID, depositNonce, msg.sender, data);
}

QBridgeHandler
function deposit(bytes32 resourceID, address depositer, bytes calldata data) external override onlyBridge {
        uint option;
        uint amount;
(option, amount) = abi.decode(data, (uint, uint));

        address tokenAddress = resourceIDToTokenContractAddress[resourceID]; //without any tokenAddress check
require(contractWhitelist[tokenAddress], "provided tokenAddress is not whitelisted");
if (burnList[tokenAddress]) {
require(amount >= withdrawalFees[resourceID], "less than withdrawal fee");
QBridgeToken(tokenAddress).burnFrom(depositer, amount);
} else {
require(amount >= minAmounts[resourceID][option], "less than minimum amount");
            tokenAddress.safeTransferFrom(depositer, address(this), amount); //vulnerable point
}
}
/*
"input":{
"token":"0x0000000000000000000000000000000000000000"
"from":"0xd01ae1a708614948b2b5e0b7ab5be6afa01325c7"
"to":"0x17b7163cf1dbd286e262ddc68b553d899b93f526"
"value":"190000000000000000000"
}
*/
SafeToken.sol
function safeTransferFrom(. //vulnerable point
        address token,
        address from,
        address to,
        uint value
    ) internal {
// bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
require(success && (data.length == 0 || abi.decode(data, (bool))), "!safeTransferFrom");
}
​,Root cause:  Insufficient validation
CrossChainBridgeInsufficient validation,20220118,Multichain (Anyswap),https://web3sec.notion.site/Insufficient-validation-e0c33f8732b34ffbb263634a189dc016?pvs=25,$1.4 million,https://github.com/SunWeb3Sec/DeFiHackLabs#20220118-multichain-anyswap---insufficient-token-validation,,SolidityCopyfunction anySwapOutUnderlyingWithPermit(
address from,
address token, // without validation
address to,
uint amount,
uint deadline,
uint8 v,
bytes32 r,
bytes32 s,
uint toChainID
    ) external {
address _underlying = AnyswapV1ERC20(token).underlying();
IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s); //vulnerable point
        TransferHelper.safeTransferFrom(_underlying, from, token, amount);
AnyswapV1ERC20(token).depositVault(amount, from);
_anySwapOut(from, token, to, amount, toChainID);
}
​,Root cause:  insufficient validation
Dex/AMMreentrancyInsufficient validation,20211221,Visor Finance,https://web3sec.notion.site/Insufficient-validation-Reentrancy-31bc421a413b4da8bb6aed84875bd496?pvs=25,$8.2 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20211221-visor-finance---reentrancy,,SolidityCopy// @param visr Amount of VISR transfered from sender to Hypervisor
// @param to Address to which liquidity tokens are minted
// @param from Address from which tokens are transferred 
// @return shares Quantity of liquidity tokens minted as a result of deposit
function deposit(
uint256 visrDeposit,
address payable from,
address to
    ) external returns (uint256 shares) {
require(visrDeposit > 0, "deposits must be nonzero");
require(to != address(0) && to != address(this), "to");
require(from != address(0) && from != address(this), "from");

        shares = visrDeposit;
if (vvisr.totalSupply() != 0) {
uint256 visrBalance = visr.balanceOf(address(this));
          shares = shares.mul(vvisr.totalSupply()).div(visrBalance);
}
if(isContract(from)) {
require(IVisor(from).owner() == msg.sender); //vulnerable point
IVisor(from).delegatedTransferERC20(address(visr), address(this), visrDeposit);
}
else {
          visr.safeTransferFrom(from, address(this), visrDeposit);
}

        vvisr.mint(to, shares);
}
​,Root cause:  Insufficient validation & Reentrancy
YieldreentrancyInsufficient validation,20211218,Grim Finance,https://web3sec.notion.site/Insufficient-validation-Reentrancy-vulnerable-point-57ee417431d740ebb469238a2087b3d0?pvs=25,$30 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20211218-grim-finance---flashloan--reentrancy,,SolidityCopyfunction depositFor(address token, uint _amount,address user ) public {
uint256 _pool = balance();
IERC20(token).safeTransferFrom(msg.sender, address(this), _amount); //vulnerable point
earn();
uint256 _after = balance();
        _amount = _after.sub(_pool); // Additional check for deflationary tokens
uint256 shares = 0;
if (totalSupply() == 0) {
            shares = _amount;
} else {
            shares = (_amount.mul(totalSupply())).div(_pool);
}
_mint(user, shares);
}
​,Root cause:  Insufficient validation & Reentrancy
Dex/AMMPricemanipulation,20211130,MonoX Finance,https://web3sec.notion.site/Insufficient-validation-1b6aa25dc829494f93ad46bd6c4be7df?pvs=25,$31 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20211130-monox-finance---price-manipulation,,SolidityCopy// actually removes liquidity
function removeLiquidity (address _token, uint256 liquidity, address to,
uint256 minVcashOut,
uint256 minTokenOut) external returns(uint256 vcashOut, uint256 tokenOut) {
(vcashOut, tokenOut) = _removeLiquidityHelper (_token, liquidity, to, minVcashOut, minTokenOut, false);
}
// actually removes liquidity
function _removeLiquidityHelper (address _token, uint256 liquidity, address to,
uint256 minVcashOut,
uint256 minTokenOut,
bool isETH) lockToken(_token) internal returns(uint256 vcashOut, uint256 tokenOut) {
require (tokenPoolStatus[_token]==1, "MonoX:NO_TOKEN");
    PoolInfo memory pool = pools[_token];
uint256 poolValue;
uint256 liquidityIn;
(poolValue, liquidityIn, vcashOut, tokenOut) = _removeLiquidity(_token, liquidity, to);//vulnerable point
_mintFee(pool.pid, pool.lastPoolValue, poolValue);
require (vcashOut>=minVcashOut, "MonoX:INSUFF_vCash");
require (tokenOut>=minTokenOut, "MonoX:INSUFF_TOKEN");
if (vcashOut>0){
      vCash.mint(to, vcashOut);
}
if (!isETH) {
      monoXPool.safeTransferERC20Token(_token, to, tokenOut);
} else {
      monoXPool.withdrawWETH(tokenOut);
      monoXPool.safeTransferETH(to, tokenOut);
}

    monoXPool.burn(to, pool.pid, liquidityIn);
_syncPoolInfo(_token, 0, vcashOut);
emit RemoveLiquidity(to, 
      pool.pid,
      _token,
      liquidityIn, 
      vcashOut, tokenOut, pool.price);
}
​,Root cause:  Insufficient validation
Dex/AMMInsufficient validation,20210916,SushiSwap,https://web3sec.notion.site/Insufficient-validation-7c665aa03d4645d780aff4243b4fd5df?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20210916-sushiswap-miso,,SolidityCopy/// @notice Allows batched call to self (this contract).
/// @param calls An array of inputs for each call.
/// @param revertOnFail If True then reverts after a failed call and stops doing further calls.
/// @return successes An array indicating the success of a call, mapped one-to-one to `calls`.
/// @return results An array with the returned data of each function call, mapped one-to-one to `calls`.
// F1: External is ok here because this is the batch function, adding it to a batch makes no sense
// F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value
// C3: The length of the loop is fully under user control, so can't be exploited
// C7: Delegatecall is only used on the same contract, so it's safe
function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {
        successes = new bool[](calls.length);
        results = new bytes[](calls.length);
for (uint256 i = 0; i < calls.length; i++) {
(bool success, bytes memory result) = address(this).delegatecall(calls[i]); //vulnerable point
require(success || !revertOnFail, _getRevertMsg(result));
            successes[i] = success;
            results[i] = result;
}
}
}
function commitEth(
address payable _beneficiary,
bool readAndAgreedToMarketParticipationAgreement
    )
public payable
{
...
​,Root cause:  Insufficient validation
Dex/AMMMiscalculation,20210915,NowSwap,https://web3sec.notion.site/Incorrect-calculation-10000-vs-1000-df5682965a684a6c82152215ca82b130?pvs=25,$1 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20210915-nowswap-platform,,No Code,Root cause:  Incorrect calculation
YieldMiscalculation,20210915,Nimbus Platform,https://web3sec.notion.site/Incorrect-calculation-10000-vs-1000-f2da18099fe842f688187515932212a3?pvs=25,1.45 ETH,https://github.com/SunWeb3Sec/DeFiHackLabs#20210915-nimbus-platform,,SolidityCopy// this low-level function should be called from a contract which performs important safety checks
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock {
require(amount0Out > 0 || amount1Out > 0, 'Nimbus: INSUFFICIENT_OUTPUT_AMOUNT');
(uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
require(amount0Out < _reserve0 && amount1Out < _reserve1, 'Nimbus: INSUFFICIENT_LIQUIDITY');
uint balance0;
uint balance1;
{ // scope for _token{0,1}, avoids stack too deep errors
address _token0 = token0;
address _token1 = token1;
require(to != _token0 && to != _token1, 'Nimbus: INVALID_TO');
if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
if (data.length > 0) INimbusCallee(to).NimbusCall(msg.sender, amount0Out, amount1Out, data);
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));
}
uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
require(amount0In > 0 || amount1In > 0, 'Nimbus: INSUFFICIENT_INPUT_AMOUNT');
{
address referralProgram = INimbusFactory(factory).nimbusReferralProgram();
if (amount0In > 0) {
address _token0 = token0;
uint refFee = amount0In.mul(3)/ 1994;
_safeTransfer(_token0, referralProgram, refFee);
INimbusReferralProgram(referralProgram).recordFee(_token0, to, refFee);
            balance0 = balance0.sub(refFee);
}
if (amount1In > 0) {
uint refFee = amount1In.mul(3) / 1994;
address _token1 = token1;
_safeTransfer(_token1, referralProgram, refFee);
INimbusReferralProgram(referralProgram).recordFee(_token1, to, refFee);
            balance1 = balance1.sub(refFee);
}
}
{ // scope for reserve{0,1}Adjusted, avoids stack too deep errors
uint balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(15)); //vulnerable point
uint balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(15)); //vulnerable point
require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'Nimbus: K'); //vulnerable
}
_update(balance0, balance1, _reserve0, _reserve1);
emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
}
​,Root cause:  Incorrect calculation
YieldDeflationary tokenInsufficient validation,20210912,ZABU Finance,https://web3sec.notion.site/Incorrect-calculation-Deflationary-token-uncompatible-912600553607478e8282d5f700c86dc3?pvs=25,$3.2 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20210912-zabu-finance---deflationary-token-uncompatible,,SolidityCopyfunction _transfer(address sender, address recipient, uint256 amount) private {
require(sender != address(0), "ERC20: transfer from the zero address");
require(recipient != address(0), "ERC20: transfer to the zero address");
require(amount > 0, "Transfer amount must be greater than zero");
if (block.timestamp < allowTradeAt + 24 hours && amount >= 10**6 * 10**9 ) {
revert("You cannot transfer more than 1 billion now"); }
if (_isExcluded[sender] && !_isExcluded[recipient]) {
_transferFromExcluded(sender, recipient, amount);
} else if (!_isExcluded[sender] && _isExcluded[recipient]) {
_transferToExcluded(sender, recipient, amount);
} else if (!_isExcluded[sender] && !_isExcluded[recipient]) {
_transferStandard(sender, recipient, amount);
} else if (_isExcluded[sender] && _isExcluded[recipient]) {
_transferBothExcluded(sender, recipient, amount);
} else {
_transferStandard(sender, recipient, amount);
}
}
function _transferStandard(address sender, address recipient, uint256 tAmount) private {
(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
_reflectFee(rFee, tFee);
emit Transfer(sender, recipient, tTransferAmount);
}
function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {
(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
_reflectFee(rFee, tFee);
emit Transfer(sender, recipient, tTransferAmount);
}
function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {
(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);
        _tOwned[sender] = _tOwned[sender].sub(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
_reflectFee(rFee, tFee);
emit Transfer(sender, recipient, tTransferAmount);
}
function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {
(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);
        _tOwned[sender] = _tOwned[sender].sub(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
_reflectFee(rFee, tFee);
emit Transfer(sender, recipient, tTransferAmount);
}
​,Root cause:  Incorrect calculation
DAOAccess Control,20210903,DAO Maker,https://web3sec.notion.site/Incorrect-access-control-d9e36d9c644741d3a726652f464a7f2f?pvs=25,$4 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20210903-dao-maker---bad-access-controal,,SolidityCopyfunction emergencyExit(address varg0) public payable { //vulnerable point
require(msg.data.length - 4 >= 32);
require(msg.sender == _owner, 'Ownable: caller is not the owner');
require((address(_hasInitialized >> 8)).code.size);
    v0, v1 = address(_hasInitialized >> 8).balanceOf(address(this)).gas(msg.gas);
require(v0); // checks call status, propagates error data on error
require(RETURNDATASIZE() >= 32);
    MEM[MEM[64]] = 68;
if (this.balance >= 0) {
if ((address(_hasInitialized >> 8)).code.size) {
            v2 = v3 = MEM[64];
            v4 = v5 = MEM[MEM[64]];
            v6 = v7 = 32 + MEM[64];
while (v4 >= 32) {
                MEM[v2] = MEM[v6];
                v4 = v4 + ~31;
                v2 += 32;
                v6 += 32;
}
            MEM[v2] = MEM[v6] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;
            v8, v9, v10, v11 = address(_hasInitialized >> 8).transfer(varg0, v1).gas(msg.gas);
if (RETURNDATASIZE() == 0) {
                v12 = v13 = 96;
} else {
                v12 = v14 = new bytes[](RETURNDATASIZE());
RETURNDATACOPY(v14.data, 0, RETURNDATASIZE());
}
if (!v8) {
require(!MEM[v12], v11, MEM[v12]);
                v15 = new array[](v16.length);
                v17 = v18 = 0;
while (v17 < v16.length) {
                    MEM[v17 + v15.data] = MEM[v17 + v16.data];
                    v17 += 32;
}
                v19 = v20 = v16.length + v15.data;
if (0) {
                    MEM[v20 - 0] = ~0x0 & MEM[v20 - 0];
}
revert(v15, v21, 'SafeERC20: low-level call failed');
} else {
if (MEM[v12]) {
require(MEM[v12] >= 32);
require(MEM[32 + v12], 'SafeERC20: ERC20 operation did not succeed');
}
                exit;
}
} else {
            MEM[MEM[64] + 4] = 32;
revert('Address: call to non-contract');
}
} else {
        MEM[4 + MEM[64]] = 32;
revert('Address: insufficient balance for call');
}
}
​,Root cause:  incorrect access control
lendingERC777reentrancy,20210830,Cream Finance,https://web3sec.notion.site/Reentrancy-via-ERC777-hook-79221a1100fc4475b67780913f6b0740?pvs=25,$18 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20210830-cream-finance---flashloan-attack--reentrancy,,SolidityCopy​,Root cause:  Reentrancy via ERC777 hook
StablecoinFlashloansreentrancy,20210817,XSURGE,https://web3sec.notion.site/Reentrancy-7b07f200fd6443cb8e7c7ba6209adab4?pvs=25,$5 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20210817-xsurge---flashloan-attack--reentrancy,,SolidityCopy /** Sells SURGE Tokens And Deposits the BNB into Seller's Address */
function sell(uint256 tokenAmount) public nonReentrant returns (bool) {
address seller = msg.sender;
// make sure seller has this balance
require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');
// calculate the sell fee from this transaction
uint256 tokensToSwap = tokenAmount.mul(sellFee).div(10**2);
// how much BNB are these tokens worth?
uint256 amountBNB = tokensToSwap.mul(calculatePrice());
// send BNB to Seller
(bool successful,) = payable(seller).call{value: amountBNB, gas: 40000}(""); //vulnerable point
if (successful) {
// subtract full amount from sender
            _balances[seller] = _balances[seller].sub(tokenAmount, 'sender does not have this amount to sell');
// if successful, remove tokens from supply
            _totalSupply = _totalSupply.sub(tokenAmount); //vulnerable point
} else {
revert();
}
emit Transfer(seller, address(this), tokenAmount);
return true;
}
/** Returns the Current Price of the Token */
function calculatePrice() public view returns (uint256) {
return ((address(this).balance).div(_totalSupply));
}
/** Mints Tokens to the Receivers Address */
function mint(address receiver, uint amount) internal {
        _balances[receiver] = _balances[receiver].add(amount);
        _totalSupply = _totalSupply.add(amount);
}
/** Amount of BNB in Contract */
function getBNBQuantityInContract() public view returns(uint256){
return address(this).balance;
}
/** Returns the value of your holdings before the 6% sell fee */
function getValueOfHoldings(address holder) public view returns(uint256) {
return _balances[holder].mul(calculatePrice());
}
receive() external payable {
uint256 val = msg.value;
address buyer = msg.sender;
purchase(buyer, val);
}
​,Root cause:  Reentrancy
CrossChainBridgeInsufficient validation,20210811,Poly Network,https://web3sec.notion.site/Insufficient-validation-df5b1100785148468e1fd323a35b7bf4?pvs=25,$611 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20210811-poly-network---bridge-getting-around-modifier-through-cross-chain-message,fixed,No Code,Root cause:  Insufficient validation
Dex/AMMFlashloansPricemanipulation,20210804,WaultFinace,https://web3sec.notion.site/Incorrect-logic-0a4d0c33db114398b3a6a7ceed21a129?pvs=25,390 ETH,https://github.com/SunWeb3Sec/DeFiHackLabs#20210804-waultfinace---flashloan-price-manipulation,,SolidityCopyfunction stake(uint256 amount) external nonReentrant {
require(amount <= maxStakeAmount, 'amount too high');
        usdt.safeTransferFrom(msg.sender, address(this), amount);
if(feePermille > 0) {
uint256 feeAmount = amount * feePermille / 1000;
            usdt.safeTransfer(treasury, feeAmount);
            amount = amount - feeAmount;
}
uint256 wexAmount = amount * wexPermille / 1000;
        usdt.approve(address(wswapRouter), wexAmount);
        wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( //vulnerable point, incorrect logic
            wexAmount,
0,
            swapPath,
address(this),
            block.timestamp
        );
        wusd.mint(msg.sender, amount);
emit Stake(msg.sender, amount);
}
​,Root cause:  incorrect logic
CrossChainBridgeIncorrect logic,20210710,Chainswap,https://web3sec.notion.site/Incorrect-logic-3eb0a0b7703444dcbfb8fcc5e3e0d74a?pvs=25,$8 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20210710-chainswap---bridge-logic-flaw,fixed,No Code,Root cause:  incorrect logic
CrossChainBridgeIncorrect logic,20210702,Chainswap,https://web3sec.notion.site/Insufficient-validation-935968909600491b90ceb64e5a320cb2?pvs=25,$0.8 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20210702-chainswap---bridge-logic-flaw,fixed,SolidityCopyfunction receive(uint256 fromChainId, address to, uint256 nonce, uint256 volume, Signature[] memory signatures) virtual external payable {
_chargeFee();
require(received[fromChainId][to][nonce] == 0, 'withdrawn already');
uint N = signatures.length;
require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');
for(uint i=0; i<N; i++) {
for(uint j=0; j<i; j++)
require(signatures[i].signatory != signatures[j].signatory, 'repetitive signatory');
bytes32 structHash = keccak256(abi.encode(RECEIVE_TYPEHASH, fromChainId, to, nonce, volume, signatures[i].signatory));
bytes32 digest = keccak256(abi.encodePacked("\x19\x01", _DOMAIN_SEPARATOR, structHash));
address signatory = ecrecover(digest, signatures[i].v, signatures[i].r, signatures[i].s);
require(signatory != address(0), "invalid signature");
require(signatory == signatures[i].signatory, "unauthorized");
_decreaseAuthQuota(signatures[i].signatory, volume);
emit Authorize(fromChainId, to, nonce, volume, signatory);
}
        received[fromChainId][to][nonce] = volume;
_receive(to, volume);
emit Receive(fromChainId, to, nonce, volume);
}
function authQuotaOf(address signatory) virtual public view returns (uint quota) {
        quota = _authQuotas[signatory]; //vulnerable point, no validation
uint ratio  = autoQuotaRatio  != 0 ? autoQuotaRatio  : Factory(factory).getConfig(_autoQuotaRatio_);
uint period = autoQuotaPeriod != 0 ? autoQuotaPeriod : Factory(factory).getConfig(_autoQuotaPeriod_);
if(ratio == 0 || period == 0 || period == uint(-1))
return quota;
uint quotaCap = cap().mul(ratio).div(1e18);
uint delta = quotaCap.mul(now.sub(lasttimeUpdateQuotaOf[signatory])).div(period);
return Math.max(quota, Math.min(quotaCap, quota.add(delta)));
}
​,Root cause:  insufficient validation
StablecoinDeflationary tokenMiscalculation,20210628,SafeDollar,https://web3sec.notion.site/Incorrect-calculation-Deflationary-token-uncompatible-3d2e164ed3044083b920dcaae7a5ecb8?pvs=25,$0.2 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20210628-safedollar---deflationary-token-uncompatible,,SolidityCopyfunction transfer(address recipient, uint256 amount) public virtual override returns (bool) {
require(recipient != address(0), "ERC777: transfer to the zero address");
address from = _msgSender();
_callTokensToSend(from, from, recipient, amount, "", "");
_move(from, from, recipient, amount, "", "");
_callTokensReceived(from, from, recipient, amount, "", "", false);
return true;
}
function _move(
address _operator,
address from,
address to,
uint256 amount,
bytes memory userData,
bytes memory operatorData
    ) internal override returns (uint256 _amountSent) {
_beforeTokenTransfer(_operator, from, to, amount);
uint256 _amount = amount;
if (!_isExcludedFromFee[from] && !_isExcludedToFee[to]) {
{
uint256 _jackpotRate = jackpotRate;
if (_jackpotRate > 0) {
uint256 _jackpotAmount = amount.mul(_jackpotRate).div(10000);
address _jackpotFund = jackpotFund;
                    _balances[from] = _balances[from].sub(_jackpotAmount, "MTokenERC777: transfer amount exceeds balance");
                    _balances[_jackpotFund] = _balances[_jackpotFund].add(_jackpotAmount);
                    _amount = _amount.sub(_jackpotAmount);
                    _totalJackpotAdded = _totalJackpotAdded.add(_jackpotAmount);
emit Transfer(from, _jackpotFund, _jackpotAmount);
}
}
{
uint256 _burnAmount = 0;
uint256 _burnRate = burnRate;
if (_burnRate > 0) {
                    _burnAmount = amount.mul(_burnRate).div(10000);
                    _amount = _amount.sub(_burnAmount);
}
uint256 _addLiquidityRate = addLiquidityRate;
if (_addLiquidityRate > 0) {
uint256 _addLiquidityAmount = amount.mul(_addLiquidityRate).div(10000);
                    _burnAmount = _burnAmount.add(_addLiquidityAmount);
                    _amount = _amount.sub(_addLiquidityAmount);
                    addLiquidityAccumulated = addLiquidityAccumulated.add(_addLiquidityAmount);
uint256 _addLiquidityAccumulated = addLiquidityAccumulated;
if (_addLiquidityAccumulated >= minAmountToAddLiquidity) {
_mint(liquidityFund, _addLiquidityAccumulated, "", "");
                        _totalLiquidityAdded = _totalLiquidityAdded.add(_addLiquidityAccumulated);
ILiquidityFund(liquidityFund).addLiquidity(_addLiquidityAccumulated);
emit AddLiquidity(_addLiquidityAccumulated);
                        addLiquidityAccumulated = 0;
}
}
if (_burnAmount > 0) {
 _burn(from, _burnAmount, "", ""); //vulnerable point, burn token
}
}
}
​,Root cause:  Incorrect calculation & Deflationary token uncompatible
YieldIncorrect logic,20210622,Eleven Finance,https://web3sec.notion.site/Incorrect-logic-flow-d3c1ae9fd8d1450ca511697b6599134b?pvs=25,$4.5 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20210622-eleven-finance---doesnt-burn-shares,,SolidityCopyfunction emergencyBurn() public { //vulnerable point
uint balan = balanceOf(msg.sender);
uint avai = available();
if(avai<balan) IMasterMind(mastermind).withdraw(nrvPid, (balan.sub(avai)));
        token.safeTransfer(msg.sender, balan);
emit Withdrawn(msg.sender, balan, block.number);
}
​,Root cause:  Incorrect logic flow
Dex/AMMAccess Control,20200618,Bancor Protocol,https://web3sec.notion.site/Incorrect-access-control-7e28f1c2a7e24d02976faa8adcace8d5?pvs=25,$545,000,https://github.com/SunWeb3Sec/DeFiHackLabs#20200618-bancor-protocol---access-control,fixed,SolidityCopyfunction safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) public { //vulnerable point
execute(_token, abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));
}
​,Root cause:  incorrect access control
ERC721Access Control,20210607,88mph,https://web3sec.notion.site/Incorrect-access-control-e0bb50ab452246ca9288da3d26c50143?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20210607-88mph-nft---access-control,fixed,SolidityCopyfunction init( //vulnerable point, without modifier check
address newOwner,
string calldata tokenName,
string calldata tokenSymbol
    ) external {
_transferOwnership(newOwner);
        _tokenName = tokenName;
        _tokenSymbol = tokenSymbol;
// register the supported interfaces to conform to ERC721 via ERC165
_registerInterface(_INTERFACE_ID_ERC721_METADATA);
// Derived contracts need only register support for their own interfaces,
// we register support for ERC165 itself here
_registerInterface(_INTERFACE_ID_ERC165);
// register the supported interfaces to conform to ERC721 via ERC165
_registerInterface(_INTERFACE_ID_ERC721);
}
​,Root cause:  incorrect access control
YieldMiscalculation,20210603,PancakeHunny,https://web3sec.notion.site/Incorrect-profit-calculation-via-balanceOf-14c7d1b8ee2c4ac490b182bd8ddc4526?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20210603-pancakehunny---incorrect-calculation,fixed,SolidityCopyfunction getReward() override public nonReentrant updateReward(msg.sender) {
uint256 reward = rewards[msg.sender];
if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardsToken.withdraw(reward);
uint cakeBalance = IBEP20(CAKE).balanceOf(address(this));
if (address(minter) != address(0) && minter.isMinter(address(this))) {
uint performanceFee = minter.performanceFee(cakeBalance);
                minter.mintFor(CAKE, 0, performanceFee, msg.sender, depositedAt[msg.sender]); //check mintFor
                cakeBalance = cakeBalance.sub(performanceFee);
}
IBEP20(CAKE).safeTransfer(msg.sender, cakeBalance);
emit RewardPaid(msg.sender, cakeBalance);
}
}
function mintFor(address flip, uint _withdrawalFee, uint _performanceFee, address to, uint) override external onlyMinter {
uint feeSum = _performanceFee.add(_withdrawalFee);
IBEP20(flip).safeTransferFrom(msg.sender, address(this), feeSum);
uint hunnyBNBAmount = tokenToHunnyBNB(flip, IBEP20(flip).balanceOf(address(this))); //vulnerable point
address flipToken = hunnyBNBFlipToken();
....
function tokenToHunnyBNB(address token, uint amount) internal returns(uint flipAmount) {
if (token == cake) {
            flipAmount = _cakeToHunnyBNBFlip(amount);
} else {
// flip
            flipAmount = _flipToHunnyBNBFlip(token, amount);
}
}
function _cakeToHunnyBNBFlip(uint amount) private returns(uint flipAmount) {
swapToken(cake, amount.div(2), _hunny);
swapToken(cake, amount.sub(amount.div(2)), _wbnb);
  flipAmount = generateFlipToken(); 
}
function generateFlipToken() private returns(uint liquidity) {
uint amountADesired = IBEP20(_hunny).balanceOf(address(this));
uint amountBDesired = IBEP20(_wbnb).balanceOf(address(this));
IBEP20(_hunny).safeApprove(address(ROUTER), 0);
IBEP20(_hunny).safeApprove(address(ROUTER), amountADesired);
IBEP20(_wbnb).safeApprove(address(ROUTER), 0);
IBEP20(_wbnb).safeApprove(address(ROUTER), amountBDesired);
(,,liquidity) = ROUTER.addLiquidity(_hunny, _wbnb, amountADesired, amountBDesired, 0, 0, address(this), block.timestamp);
​,Root cause:  Incorrect profit calculation via balanceOf
YieldFlashloansMiscalculation,20210519,PancakeBunny,https://web3sec.notion.site/Incorrect-profit-calculation-via-balanceOf-b0175b0d87174b498016ee4a06819c1c?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20210519-pancakebunny---price-oracle-manipulation,fixed,SolidityCopy// @dev profits only (underlying + bunny) + no withdraw fee + perf fee
function getReward() external override {
uint amount = earned(msg.sender);
uint shares = Math.min(amount.mul(totalShares).div(balance()), _shares[msg.sender]);
        totalShares = totalShares.sub(shares);
        _shares[msg.sender] = _shares[msg.sender].sub(shares);
_cleanupIfDustShares();

        amount = _withdrawTokenWithCorrection(amount);
uint depositTimestamp = _depositedAt[msg.sender];
uint performanceFee = canMint() ? _minter.performanceFee(amount) : 0;
if (performanceFee > DUST) {
            _minter.mintForV2(address(_stakingToken), 0, performanceFee, msg.sender, depositTimestamp);//check mintForV2
            amount = amount.sub(performanceFee);
}

        _stakingToken.safeTransfer(msg.sender, amount);
emit ProfitPaid(msg.sender, amount, performanceFee);
}
​,Root cause:  Incorrect profit calculation via balanceOf
Dex/AMMERC20Miscalculation,20210428,Uranium,https://web3sec.notion.site/Incorrect-calculation-10000-vs-1000-01bd84db62e04de0acb685e6c9e80c56?pvs=25,$50 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20210428-uranium---miscalculation,,SolidityCopyfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
require(amount0Out > 0 || amount1Out > 0, 'UraniumSwap: INSUFFICIENT_OUTPUT_AMOUNT');
(uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UraniumSwap: INSUFFICIENT_LIQUIDITY');
uint balance0;
uint balance1;
{ // scope for _token{0,1}, avoids stack too deep errors
address _token0 = token0;
address _token1 = token1;
require(to != _token0 && to != _token1, 'UraniumSwap: INVALID_TO');
if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
if (data.length > 0) IUraniumCallee(to).pancakeCall(msg.sender, amount0Out, amount1Out, data);
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));
}
uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
require(amount0In > 0 || amount1In > 0, 'UraniumSwap: INSUFFICIENT_INPUT_AMOUNT');
{ // scope for reserve{0,1}Adjusted, avoids stack too deep errors
uint balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(16)); //vulnerable point
uint balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(16)); //vulnerable point
require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UraniumSwap: K'); //vulnerable
}
​,Root cause:  Incorrect calculation
Dex/AMMAccess Control,20210308,DODO,https://web3sec.notion.site/Incorrect-access-control-d05984ddba4340e2b0fa92cfb594ddd5?pvs=25,$700,000,https://github.com/SunWeb3Sec/DeFiHackLabs#20210308-dodo---flashloan-attack,,SolidityCopyfunction init(
address maintainer,
address baseTokenAddress,
address quoteTokenAddress,
uint256 lpFeeRate,
address mtFeeRateModel,
uint256 i,
uint256 k,
bool isOpenTWAP
    ) external { //vulnerable point
require(baseTokenAddress != quoteTokenAddress, "BASE_QUOTE_CAN_NOT_BE_SAME");
        _BASE_TOKEN_ = IERC20(baseTokenAddress);
        _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);
require(i > 0 && i <= 10**36);
        _I_ = i;
require(k <= 10**18);
        _K_ = k;

        _LP_FEE_RATE_ = lpFeeRate;
        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);
        _MAINTAINER_ = maintainer;

        _IS_OPEN_TWAP_ = isOpenTWAP;
if(isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32);
string memory connect = "_";
string memory suffix = "DLP";

        name = string(abi.encodePacked(suffix, connect, addressToShortString(address(this))));
        symbol = "DLP";
        decimals = _BASE_TOKEN_.decimals();
// ============================== Permit ====================================
uint256 chainId;
assembly {
            chainId := chainid()
}
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
// keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,
keccak256(bytes(name)),
keccak256(bytes("1")),
                chainId,
address(this)
)
);
// ==========================================================================
}
​,Root cause:  Incorrect access control
Miscalculation,20201229,Cover Protocol,https://web3sec.notion.site/Incorrect-calculation-via-cached-data-2d22fc73ce514e519cca96aaa61d2eec?pvs=25,,https://github.com/SunWeb3Sec/DeFiHackLabs#20201229-cover-protocol,,SolidityCopyfunction deposit(address _lpToken, uint256 _amount) external override {
require(block.timestamp >= START_TIME , "Blacksmith: not started");
require(_amount > 0, "Blacksmith: amount is 0");
    Pool memory pool = pools[_lpToken]; //vulnerable point, data cached.
require(pool.lastUpdatedAt > 0, "Blacksmith: pool does not exists");
require(IERC20(_lpToken).balanceOf(msg.sender) >= _amount, "Blacksmith: insufficient balance");
updatePool(_lpToken);

    Miner storage miner = miners[_lpToken][msg.sender];
    BonusToken memory bonusToken = bonusTokens[_lpToken];
_claimCoverRewards(pool, miner); //old cached data used
_claimBonus(bonusToken, miner);

    miner.amount = miner.amount.add(_amount);
// update writeoff to match current acc rewards/bonus per token
    miner.rewardWriteoff = miner.amount.mul(pool.accRewardsPerToken).div(CAL_MULTIPLIER); //vulnerable point, old cached data used
    miner.bonusWriteoff = miner.amount.mul(bonusToken.accBonusPerToken).div(CAL_MULTIPLIER); //vulnerable point, old cached data used
IERC20(_lpToken).safeTransferFrom(msg.sender, address(this), _amount);
emit Deposit(msg.sender, _lpToken, _amount);
}
/// @notice update pool's rewards & bonus per staked token till current block timestamp
function updatePool(address _lpToken) public override {
    Pool storage pool = pools[_lpToken]; // storage
if (block.timestamp <= pool.lastUpdatedAt) return;
uint256 lpTotal = IERC20(_lpToken).balanceOf(address(this));
if (lpTotal == 0) {
      pool.lastUpdatedAt = block.timestamp;
return;
}
// update COVER rewards for pool
uint256 coverRewards = _calculateCoverRewardsForPeriod(pool);
    pool.accRewardsPerToken = pool.accRewardsPerToken.add(coverRewards.div(lpTotal));
    pool.lastUpdatedAt = block.timestamp;
// update bonus token rewards if exist for pool
    BonusToken storage bonusToken = bonusTokens[_lpToken]; // storage
if (bonusToken.lastUpdatedAt < bonusToken.endTime && bonusToken.startTime < block.timestamp) {
uint256 bonus = _calculateBonusForPeriod(bonusToken);
      bonusToken.accBonusPerToken = bonusToken.accBonusPerToken.add(bonus.div(lpTotal));
      bonusToken.lastUpdatedAt = block.timestamp <= bonusToken.endTime ? block.timestamp : bonusToken.endTime;
}
}
function claimRewards(address _lpToken) public override {
updatePool(_lpToken);

    Pool memory pool = pools[_lpToken]; //vulnerable point, data cached.
    Miner storage miner = miners[_lpToken][msg.sender];
    BonusToken memory bonusToken = bonusTokens[_lpToken];
_claimCoverRewards(pool, miner);
_claimBonus(bonusToken, miner);
// update writeoff to match current acc rewards & bonus per token
    miner.rewardWriteoff = miner.amount.mul(pool.accRewardsPerToken).div(CAL_MULTIPLIER); //vulnerable point, old cached data used
    miner.bonusWriteoff = miner.amount.mul(bonusToken.accBonusPerToken).div(CAL_MULTIPLIER); //vulnerable point, old cached data used
}
function _claimCoverRewards(Pool memory pool, Miner memory miner) private nonReentrant {
if (miner.amount > 0) {
uint256 minedSinceLastUpdate = miner.amount.mul(pool.accRewardsPerToken).div(CAL_MULTIPLIER).sub(miner.rewardWriteoff);
if (minedSinceLastUpdate > 0) {
        cover.mint(msg.sender, minedSinceLastUpdate); // mint COVER tokens to miner
}
}
}
​,Root cause:  Incorrect calculation via cached data.
YieldInsufficient validation,20201121,Pickle Finance,https://web3sec.notion.site/Insufficient-validation-43fdf8910a0b43d5b73ccc295a4c3b40?pvs=25,$20 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20201121-pickle-finance,,SolidityCopy// Function to swap between jars
function swapExactJarForJar(
address _fromJar, // From which Jar
address _toJar, // To which Jar
uint256 _fromJarAmount, // How much jar tokens to swap
uint256 _toJarMinAmount, // How much jar tokens you'd like at a minimum
address payable[] calldata _targets,
bytes[] calldata _data
    ) external returns (uint256) {
require(_targets.length == _data.length, "!length");
// Only return last response
for (uint256 i = 0; i < _targets.length; i++) {
require(_targets[i] != address(0), "!converter");
require(approvedJarConverters[_targets[i]], "!converter");
}
address _fromJarToken = IJar(_fromJar).token();
address _toJarToken = IJar(_toJar).token();
// Get pTokens from msg.sender
IERC20(_fromJar).safeTransferFrom(
            msg.sender,
address(this),
            _fromJarAmount
        );
// Calculate how much underlying
// is the amount of pTokens worth
uint256 _fromJarUnderlyingAmount = _fromJarAmount
            .mul(IJar(_fromJar).getRatio())
.div(10**uint256(IJar(_fromJar).decimals()));
// Call 'withdrawForSwap' on Jar's current strategy if Jar
// doesn't have enough initial capital.
// This has moves the funds from the strategy to the Jar's
// 'earnable' amount. Enabling 'free' withdrawals
uint256 _fromJarAvailUnderlying = IERC20(_fromJarToken).balanceOf(
            _fromJar
        );
if (_fromJarAvailUnderlying < _fromJarUnderlyingAmount) {
IStrategy(strategies[_fromJarToken]).withdrawForSwap(
                _fromJarUnderlyingAmount.sub(_fromJarAvailUnderlying)
);
}
// Withdraw from Jar
// Note: this is free since its still within the "earnable" amount
//       as we transferred the access
IERC20(_fromJar).safeApprove(_fromJar, 0);
IERC20(_fromJar).safeApprove(_fromJar, _fromJarAmount);
 IJar(_fromJar).withdraw(_fromJarAmount); //vulnerable point
// Calculate fee
uint256 _fromUnderlyingBalance = IERC20(_fromJarToken).balanceOf(
address(this)
);
uint256 _convenienceFee = _fromUnderlyingBalance.mul(convenienceFee).div(
            convenienceFeeMax
        );
if (_convenienceFee > 1) {
IERC20(_fromJarToken).safeTransfer(devfund, _convenienceFee.div(2));
IERC20(_fromJarToken).safeTransfer(treasury, _convenienceFee.div(2));
}
// Executes sequence of logic
for (uint256 i = 0; i < _targets.length; i++) {
_execute(_targets[i], _data[i]);
}
// Deposit into new Jar
uint256 _toBal = IERC20(_toJarToken).balanceOf(address(this));
IERC20(_toJarToken).safeApprove(_toJar, 0);
IERC20(_toJarToken).safeApprove(_toJar, _toBal);
IJar(_toJar).deposit(_toBal);
// Send Jar Tokens to user
uint256 _toJarBal = IJar(_toJar).balanceOf(address(this));
if (_toJarBal < _toJarMinAmount) {
revert("!min-jar-amount");
}
IJar(_toJar).transfer(msg.sender, _toJarBal);
return _toJarBal;
}
​,Root cause:  Insufficient validation
YieldFlashloansPricemanipulationEconomic,20201026,Harvest Finance,https://web3sec.notion.site/Economic-issue-d6fefdcce70d48299c31ecf145b60fbe?pvs=25,$33.8 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20201026-harvest-finance---flashloan-attack,,SolidityCopyfunction _deposit(uint256 amount, address sender, address beneficiary) internal {
require(amount > 0, "Cannot deposit 0");
require(beneficiary != address(0), "holder must be defined");
if (address(strategy()) != address(0)) {
require(IStrategy(strategy()).depositArbCheck(), "Too much arb");
}
uint256 toMint = totalSupply() == 0
? amount
        : amount.mul(totalSupply()).div(underlyingBalanceWithInvestment());
_mint(beneficiary, toMint);
IERC20(underlying()).safeTransferFrom(sender, address(this), amount);
// update the contribution amount for the beneficiary
emit Deposit(beneficiary, amount);
}
/* Returns the current underlying (e.g., DAI's) balance together with
   * the invested amount (if DAI is invested elsewhere by the strategy).
  */
function underlyingBalanceWithInvestment() view public returns (uint256) {
if (address(strategy()) == address(0)) {
// initial state, when not set
return underlyingBalanceInVault();
}
return underlyingBalanceInVault().add(IStrategy(strategy()).investedUnderlyingBalance());
}
​,Root cause:  Economic issue
ERC20Under/Overflow,20180422,Beauty Chain,https://web3sec.notion.site/Arithmetic-Overflow-3ffaf1044ef046c8b9456244f3623432?pvs=25,$900 M,https://github.com/SunWeb3Sec/DeFiHackLabs#20180422-beauty-chain---integer-overflow,,SolidityCopyfunction batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
uint cnt = _receivers.length;
 uint256 amount = uint256(cnt) * _value; //vulnerable point
require(cnt > 0 && cnt <= 20);
require(_value > 0 && balances[msg.sender] >= amount);

    balances[msg.sender] = balances[msg.sender].sub(amount);
for (uint i = 0; i < cnt; i++) {
        balances[_receivers[i]] = balances[_receivers[i]].add(_value);
Transfer(msg.sender, _receivers[i], _value);
}
return true;
}
​,Root cause:  Arithmetic Overflow
walletAccess Control,20171106,Parity,https://web3sec.notion.site/Incorrect-access-control-a6ecc97e554945d6a779a7f14e10cd22?pvs=25,514k ETH,https://github.com/SunWeb3Sec/DeFiHackLabs#20171106-parity---accidentally-killed-it,,SolidityCopy// constructor - just pass on the owner array to the multiowned and
// the limit to daylimit
function initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized { //vulnerable point
initDaylimit(_daylimit);
initMultiowned(_owners, _required);
}
​,Root cause:  Incorrect access control
Miscalculation,20230601,Cellframenet,https://web3sec.notion.site/Miscalculation-during-liquidity-migration-d4be7cafe1e541a1985cbcce5c0f13fb?pvs=25,$76k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Cellframe_exp.sol,JavaScriptCopyfunction migrate(uint amountLP) external  {
(uint token0,uint token1) = migrateLP(amountLP);
(uint eth,uint cell, ) = IUniswapV2Router01(LP_NEW).getReserves();     

        uint resoult = cell/eth;              
        token1 = resoult * token0;
IERC20(CELL).approve(ROUTER_V2,token1);
IERC20(WETH).approve(ROUTER_V2,token0);
(uint tokenA, , ) = IUniswapV2Router01(ROUTER_V2).addLiquidity(
WETH,
CELL,
            token0,
            token1,
0,
0,
            msg.sender,
            block.timestamp + 5000
);

        uint balanceOldToken = IERC20(OLD_CELL).balanceOf(address(this));
IERC20(OLD_CELL).transfer(marketingAddress,balanceOldToken);
if (tokenA < token0) {
            uint256 refund0 = token0 - tokenA;
IERC20(WETH).transfer(msg.sender,refund0);
}
}
function migrateLP(uint amountLP) internal returns(uint256 token0,uint256 token1) {
IERC20(LP_OLD).transferFrom(msg.sender,address(this),amountLP);
IERC20(LP_OLD).approve(ROUTER_V2,amountLP);
return IUniswapV2Router01(ROUTER_V2).removeLiquidity(
WETH,
OLD_CELL,
            amountLP,
0,
0,
address(this),
            block.timestamp + 5000
);
}
​,Root cause:
Price Manipulation,20230531,ERC20TokenBank,https://web3sec.notion.site/Price-manipulation-3f5479aa208e4cfd9ecdc6f7c20c217e?pvs=25,$111k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/ERC20TokenBank_exp.sol,JavaScriptCopyfunction doExchange(uint256 amount) public returns(bool){
require(amount >= minimum_amount, "invalid amount");
require(amount <= ERC20TokenBankInterface(from_bank).balance(), "too much amount");
ERC20TokenBankInterface(from_bank).issue(address(this), amount); //vulnerable point

    uint256 camount = usdc.balanceOf(address(this));
    usdc.safeApprove(address(curve), camount);
    curve.exchange_underlying(1, 2, camount, 0);

    uint256 namount = usdt.balanceOf(address(this));
    usdt.safeTransfer(to_bank, namount);
return true;
}
}
​,Root cause:
Price Manipulation,20230529,Jimbo,https://web3sec.notion.site/Protocol-Specific-Price-Manipulation-4e3c752119df448791a656ebf445789e?pvs=25,$8M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Jimbo_exp.sol,JavaScriptCopyfunction shift() public returns (bool) { //vulnerable point
if (canShift()) {
// Let the token know the protocol is rebalancing
            jimbo.setIsRebalancing(true);
// Get the active bin
            uint24 activeBin = pair.getActiveId();
// Remove all non-floor bin liquidity (max bin -> anchor bin)
_removeNonFloorLiquidity();
// Remove all floor bin liquidity
_removeFloorLiquidity();
// Count the total JIMBO and ETH in the contract after liquidity removal
            uint256 totalJimboInPool = jimbo.balanceOf(address(this));
            uint256 totalEthInContract = weth.balanceOf(address(this));
// Floor is based on total eth / circulating supply
            uint256 totalCirculatingJimbo = jimbo.totalSupply() -
                jimbo.balanceOf(address(0)) -
                totalJimboInPool;
// Calculate the new target floor bin
            uint24 newFloorBin = _calculateNewFloorBin(
                totalEthInContract,
                totalCirculatingJimbo
            );
// Calculate new anchor bin id
// Make sure you use the new floor bin and not the stale one
            uint24 newAnchorBin = activeBin - newFloorBin > NUM_ANCHOR_BINS
? activeBin - NUM_ANCHOR_BINS
: activeBin - 1;
// Set internal bin state
_setBinState({
floorBin_: newFloorBin,
anchorBin_: newAnchorBin, // this is not always true
triggerBin_: activeBin + NUM_ANCHOR_BINS,
maxBin_: activeBin + NUM_LIQ_BINS - 1 // decrement because we are adding inclusive of active bin
});
// Deploy all the JIMBO liquidity first
_deployJimboLiquidity(); //vulnerable point
// Deploy floor bin liquidity with 90% of all ETH in the contract
_deployFloorLiquidity((weth.balanceOf(address(this)) * 90) / 100); //vulnerable point
// Use entire remaining weth balance in the contract to deploy anchors
_deployAnchorLiquidity(weth.balanceOf(address(this))); //vulnerable point
// Let the token know we are done rebalancing to apply taxes
            jimbo.setIsRebalancing(false);
return true;
} else return false;
}
​,Root cause:
Slippage,20230529,BabyDogeCoin,https://web3sec.notion.site/Lack-Slippage-Protection-1828cba4d0cb43dda50b6c1e7f14ea57?pvs=25,$135k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BabyDogeCoin_exp.sol,JavaScriptCopy/*
     * @notice Swaps input token to ERC20 token and deposits on behalf of msg.sender to specified farm
     * @param farm Farm address, where tokens should be deposited
     * @param amountIn Amount of input tokens
     * @param amountOutMin Minimum amount of tokens to receive
     * @param path Address path to swap input token
     * @return Received token amount
     * @dev Last element of path must be stake token
     * @dev First element of path must be input token
     */
function buyTokensAndDepositOnBehalf(
IFarm farm,
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path
) external payable returns(uint256) {
if (msg.value > 0) {
require(address(WBNB) == path[0], "Input token != WBNB");
require(amountIn == msg.value, "Invalid msg.value");
WBNB.deposit{value: amountIn}();
} else {
IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);
}
        address tokenOut = path[path.length - 1];
require(tokenOut == farm.stakeToken(), "Not a stake token");
_approveIfRequired(path[0], address(router), amountIn);
        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            amountIn,
            amountOutMin,
            path,
address(this),
            block.timestamp + 1200
);
        uint256 received = IERC20(tokenOut).balanceOf(address(this));
_approveIfRequired(tokenOut, address(farm), received);
        farm.depositOnBehalf(received, msg.sender);

        emit TokensBoughtAndDeposited (
address(farm),
            msg.sender,
            path[0],
            tokenOut,
            amountIn,
            received
        );
return received;
}
​,Root cause:
Business Logic Flaw,20230529,FAPEN,https://web3sec.notion.site/Function-abused-to-get-rewards-7629f02b87bd465b9d612b204460b83c?pvs=25,$600,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/FAPEN_exp.sol,SolidityCopyfunction register(address neighbor) external initialized {
address user = msg.sender;
require(villages[user].timestamp == 0, "just new users"); //vulnerable points
uint256 gems;
    totalVillages++;
if (villages[neighbor].sheeps[0] > 0 && neighbor != manager) {
        gems += GEM_BONUS * 2;
} else{
        neighbor = manager;
        gems += GEM_BONUS;
}
    villages[neighbor].neighbors++;
    villages[user].neighbor = neighbor;
    villages[user].gems += gems;
emit Newbie(msg.sender, gems);
}
​,It does not update the timestamp after the registration. In this case, the attacker can invoke the function register for multiple times.
Access Control,20230529,NOON (NO),https://web3sec.notion.site/Public-_transfer-0dfa1c852f6a424c8b4a4baf8ba92d75?pvs=25,$2K,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/NOON_exp.sol,JavaScriptCopyfunction _transfer(address varg0, address varg1, uint256 varg2) public payable {  //vulnerable point
require(msg.data.length - 4 >= 96);
require(varg1);
require(varg2 <= _balanceOf[varg0]);
require(_balanceOf[varg1] + varg2 > _balanceOf[varg1]);
    _balanceOf[varg0] = _balanceOf[varg0] - varg2;
    _balanceOf[varg1] += varg2;
    emit Transfer(varg0, varg1, varg2);
assert(_balanceOf[varg1] + _balanceOf[varg0] == _balanceOf[varg0] + _balanceOf[varg1]);
}
​,Incorrect function visibility
skimIncorrect logic,20230525,GPT Token,https://web3sec.notion.site/Fee-Mechanism-Exploitation-7cb328590042406faff8098d1dfa9c09?pvs=25,$42k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/GPT_exp.sol,No Code,Root cause: 
Access Control,20230524,Local Trade LCT,https://web3sec.notion.site/Improper-Access-Control-of-Close-source-contract-47145d8753ed45e4bd83a7ff8ab21840?pvs=25,384 BNB,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/LocalTrader2_exp.sol,No Code,Root cause: 
Miscalculation,20230524,CS Token,https://web3sec.notion.site/Outdated-global-variable-sellAmount-for-calculating-burnAmount-367e398d4fb144fb9c89228216eb3176?pvs=25,714K USD,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/CS_exp.sol,JavaScriptCopyfunction _transfer(
address from,
        address to,
        uint256 amount
) private {
require(from != address(0), "ERC20: transfer from the zero address");
require(to != address(0), "ERC20: transfer to the zero address");
require(amount > 0, "Transfer amount must be greater than zero");
require(!blackList[from], "black account");
require(!blackList[to], "black account");
if (!canContract && _isContract(msg.sender) && !exPairs[from]) {
require(whiteContractList[msg.sender], "not allowed contract trade");
}
if (!canBuy &&  exPairs[from]){
require(whiteList[to], "not allow trade");
}
if (!canSell &&  exPairs[to]){
require(whiteList[from], "not allow trade");
}        

        bool takeTransFee = isTransFee && !feeWhiteList[from] && !feeWhiteList[to] && !exPairs[from] && !exPairs[to] && !_isLiquidity(from,to) ;
        bool takeSellFee = isSellFee && !feeWhiteList[from] &&  exPairs[to] && !_isLiquidity(from,to);
        bool takeBuyFee = isBuyFee && !feeWhiteList[to] &&  exPairs[from] && !_isLiquidity(from,to);
if (_isLiquidity(from,to) && exPairs[to]){
updateLiquidityInfo(amount);
}

        bool canSell =  sellAmount >= 1;
if(canSell &&from != address(this) &&from != uniswapV2Pair &&from != owner() && to != owner() && !_isLiquidity(from,to)){
sync();
}

        FeeParam memory param;
if (takeBuyFee){
require(amount <= limitBuy,"exceeds buying limit!");
            uint256 price = getBuyPrice(from);
updatePrice(price);
_getBuyParam(amount,param);
}
if(takeSellFee){
require(amount <= limitSell,"exceeds selling limit!");
            uint256 price = getSellPrice(to);
updatePrice(price);
_getSellParam(amount,param);
            sellAmount = amount;  //vulnerable point
            uint256 contractTokenBalance = balanceOf(address(this));
            bool canSwap = contractTokenBalance >= minTokenNumberToSell;
if (
                canSwap &&
!inSwapAndLiquify &&
                from != uniswapV2Pair
            ) {
                inSwapAndLiquify = true;
swapAndLiquify(contractTokenBalance);

                inSwapAndLiquify = false;
}
}
if (takeTransFee){
_getTransferParam(amount,param);
}
if (param.tTransferAmount == 0) {
            param.tTransferAmount = amount;
}
_tokenTransfer(from,to,amount,param);
}
function sync() private lockTheSync{
if (totalBurnAmount>=maxBurnAmount){
return;
}
        uint256 burnAmount = sellAmount.mul(800).div(1000); //vulnerable point
        sellAmount = 0;
​,Root cause: 
Business Logic Flaw,20230523,LFI Token,https://web3sec.notion.site/Lack-of-time-lock-protect-e387e603ba374f948884d4a2e8945317?pvs=25,36K USD,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/LFI_exp.sol,SolidityCopy​,Root cause:
Lack of permission control,20230514,landNFT,https://web3sec.notion.site/Lack-of-permission-control-a4c262e03b1b4293a86e58ae72d8a9ec?pvs=25,149,616 $BUSD,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/landNFT_exp.sol,SolidityCopy
function mint(address player,uint256 amount) external whenNotPaused() onlyMiner{
uint256 _tokenId = totalSupply();
require(_tokenId.add(amount)<=MAX_SUPPLY,"MAX_SUPPLY err");
_safeMint(player, amount);
}
​,Root cause:
Unchecked User Input,20230514,SellToken03,https://web3sec.notion.site/Not-properly-validate-the-input-parameters-3ab225f27a1c437b801726c2ee499d91?pvs=25,unclear,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SELLC02_exp.sol,SolidityCopy​,Root cause:
Business Logic Flaw,20230513,Bitpaidio,https://web3sec.notion.site/Did-not-properly-update-the-lock-times-22603416025743a4b5c94a87302c47c8?pvs=25,$30K,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Bitpaidio_exp.sol,SolidityCopy
if(sixMonth[msg.sender].reinvest == 0) {
uint256 startTime = block.timestamp;
uint256 endTime = block.timestamp + 180 days;

          sixMonth[msg.sender] = TimeLock_Six_Month(msg.sender,total,startTime,endTime,1);
}
else {
uint256 startTime = sixMonth[msg.sender].start_time;
uint256 endTime = sixMonth[msg.sender].end_time;

              sixMonth[msg.sender] = TimeLock_Six_Month(msg.sender,total,startTime,endTime,1);
}

​,Root cause:
Price Manipulation,20230513,SellToken02,https://web3sec.notion.site/Incorrect-use-AMM-getReserves-to-get-price-38212d7512ab40d0b586407b793e2f51?pvs=25,$197k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SellToken_exp.sol,SolidityCopyfunction ShortStart(address coin,address addr,uint terrace)payable public {
address bnbOrUsdt=mkt.getPair(coin);
require(terraces[terrace]!=address(0) && tokenPrice[addr][coin] > 0);
require(coin != address(0));
require(bnbOrUsdt == _WBNB || bnbOrUsdt==_USDT);
require(!getNewTokenPrice(addr,coin,bnbOrUsdt) && block.timestamp > tokenPriceTime[addr][coin]);
uint bnb=msg.value;
uint tos=getToken2Price(coin,bnbOrUsdt,mkt.balanceOf(coin))/10; //vulnerable point
require(Short[addr][coin].bnb+bnb <= tos);
        Short[addr][coin].token=bnbOrUsdt;
        Short[addr][coin].coin=coin;
        Short[addr][coin].bnb+=bnb*98/100;
        tokenPrice[addr][coin]=0;
uint newTokenValue=getTokenPrice(coin,bnbOrUsdt,bnb*98/100);
        Short[addr][coin].tokenPrice+=newTokenValue;
        Short[addr][coin].time=block.timestamp;
address[] memory add=mySells[addr].coin;
bool isCoin;
for(uint i=0;i<add.length;i++){
if(add[i]==coin){
               isCoin=true;
}
}
if(!isCoin){
           mySells[addr].mnu++;
           mySells[addr].coin.push(coin);
}
        sum+=bnb;
payable(mkt).transfer(bnb*97/100);
if(bnbOrUsdt ==_USDT){
uint usdts=IERC20(_USDT).balanceOf(address(mkt));
           mkt.buy(_WBNB,_USDT,bnb*97/100);
if(IERC20(_USDT).balanceOf(address(mkt))>usdts){
uint ut=IERC20(_USDT).balanceOf(address(mkt))-usdts;
             mkt.buy(_USDT,coin,ut);
}
}else{
            mkt.buy(bnbOrUsdt,coin,bnb*97/100);
}
payable (owner()).transfer(bnb*2/100);
payable (terraces[terrace]).transfer(bnb/100);
}
function getToken2Price(address token,address bnbOrUsdt,uint bnb) view public returns(uint){
if(token == address(0) || bnbOrUsdt == address(0)) return 0;
address isbnb;
if(bnbOrUsdt == _WBNB){
            isbnb=_WBNB;
address[] memory routePath = new address[](2);
            routePath[0] = token;
            routePath[1] = isbnb;
return IRouter(_router).getAmountsOut(bnb,routePath)[1]; //vulnerable point
}else {
            isbnb=_USDT;
address[] memory routePath = new address[](3);
            routePath[0] = token;
            routePath[1] = isbnb;
            routePath[2] = _WBNB;
return IRouter(_router).getAmountsOut(bnb,routePath)[2]; //vulnerable point
}
}
/*
getAmountsOut
Given an input asset amount and an array of token addresses, 
calculates all subsequent maximum output token amounts by calling getReserves 
for each pair of token addresses in the path in turn, and using these to call getAmountOut.
*/
​,Root cause:
Sandwich,20230512,LW,https://web3sec.notion.site/FlashLoan-Price-Manipulation-0c52a77ad60843d08e52a1c6392c6cdd?pvs=25,$50k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/LW_exp.sol,SolidityCopyreceive() external payable {
if(thanPrice==0) return;
if(IERC20(_token).balanceOf(_marketAddr ) >=3000e18 ){
IERC20(_token).transferFrom(_marketAddr,address(this),3000e18);
swapTokensForDead(3000e18); //vulnerable point
            thanPrice-=1;
}
}
​,Root cause:
Access Control,20230511,SellToken01,https://web3sec.notion.site/Public-addLiquidity-c30d3fce9e13476ea116137aefcf3a10?pvs=25,$95k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SELLC_exp.sol,SolidityCopyfunction addLiquidity(address _token, address token1, uint amount1) public { // @audit: pass in fake _token 
uint lp=IERC20(_token).totalSupply()*90/100;
uint miner=IERC20(_token).totalSupply()*10/100;
bool isok=IERC20(_token).transferFrom(msg.sender, address(this), IERC20(_token).totalSupply());
        isok=IERC20(token1).transferFrom(msg.sender, address(this), amount1);
require(isok);
IERC20(_token).approve(address(address(IRouters)), 2 ** 256 - 1);
        IRouters.addLiquidity(_token,token1,lp,amount1,0, 0,address(this),block.timestamp+100);
address pair=ISwapFactory(IRouters.factory()).getPair(_token,token1);
if(pairs(pair).IRouter()==address(0)){
pairs(pair).setIRouter(0xBDDFA43dbBfb5120738C922fa0212ef1E4a0850B);
}
if(myReward[_token]== address(0)){
          myReward[_token]=token1;
}
        listToken[_token]=true; //vulnerable point
        users[_token][0x2F98Fa813Ced7Aa9Fd6788aB624b2F3F292B9239].tz+= 100 ether;
}
​,Root cause:
RewardFlashloans,20230510,SNK,https://web3sec.notion.site/Use-spot-staked-balances-of-child-to-calculate-rewards-6a42382ca9714f79919a5e47cb2fe58f?pvs=25,$197k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SNK_exp.sol,SolidityCopy​,Root cause:
Access Control,20230506,Melo,https://web3sec.notion.site/Public-mint-c26e99d8419a4fca930183100b0a32f6?pvs=25,$90k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Melo_exp.sol,SolidityCopyfunction mint(address account, uint256 amount, string memory txId) public returns (bool) { //vulnerable point
_mint(acccount, amount);  
return true;
}
​,Root cause:
Incorrect logic,20230505,DEI,https://web3sec.notion.site/Fetch-allowance-of-msg-sender-for-account-instead-of-reverse-0f28c9e40a4349e893f8452bbf5f7035?pvs=25,$5.4M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DEI_exp.sol,SolidityCopyfunction burnFrom(address account, uint256 amount) public virtual {
uint256 currentAllowance = _allowances[_msgSender()][account]; // @audit: shoud be _allowances[account][_msgSender()]
_approve(account, _msgSender(), currentAllowance - amount);
_burn(account, amount);
}
​,Root cause:
Sandwich,20230503,NeverFall,https://web3sec.notion.site/No-slippage-protection-when-interacting-with-AMM-Pair-db4319144ade4696a03e2402eb6bddce?pvs=25,$74K,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/NeverFall_exp.sol,SolidityCopy​,Root cause:
Incorrect logic,20230502,Level,https://web3sec.notion.site/Use-assign-instead-of-accumulate-7c13407d4a574a93a1bd59288ba23a14?pvs=25,$1M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Level_exp.sol,SolidityCopyfunction claimMultiple(uint256[] calldata _epoches, address _to) external {
uint256 totalReward;
for (uint256 i; i < _epoches.length; ++i) {
uint256 epoch = _epoches[i];
if (epoch < currentEpoch) {
uint256 reward = claimable(epoch, msg.sender);
			users[epoch][msg.sender].claimed = reward;  // @audit: vulnerable, should be +=
			totalReward += reward;
}
}
	LVL.safeTransfer(_to, totalReward);
}
​,Root cause:
OracleDonate,20230428,0vix,https://web3sec.notion.site/Use-spot-balanceOf-to-calculate-exchangeRate-03eec0b41ba941a997a56201c942a5b3?pvs=25,$2M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/0vix_exp.sol,SolidityCopyfunction totalGHST(address _user) public view returns (uint _totalGHST) {
uint totalGHSTheld = GHST.balanceOf(_user); //vulnerable point
	_totalGHST = totalGHSTheld + totalGHSTStaked + totalwapGHSTheld;
}
function convertVGHST(uint _share) public view returns (uint _ghst) {
uint totalTokenLocked = totalGHST(address(this)); //vulnerable point
	_ghst = _share * totalTokenLocked / totalShares;
}
​,Root cause:
MathDonateUnder/Overflow,20230427,Silo finance,https://web3sec.notion.site/Utilization-rate-is-not-bounded-7662a6266b7141c28f59549659190a37?pvs=25,-,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/silo_finance.t.sol,JavaScriptCopy function calculateCurrentInterestRate(
Config memory _c,
        uint256 _totalDeposits,
        uint256 _totalBorrowAmount,
        uint256 _interestRateTimestamp,
        uint256 _blockTimestamp
) public pure override returns (uint256 rcur) {
if (_interestRateTimestamp > _blockTimestamp) revert InvalidTimestamps();
// struct for local vars to avoid "Stack too deep"
        LocalVarsRCur memory _l = LocalVarsRCur(0,0,0,0,0,0,false);
(,,,_l.overflow) = calculateCompoundInterestRateWithOverflowDetection(
            _c,
            _totalDeposits,
            _totalBorrowAmount,
            _interestRateTimestamp,
            _blockTimestamp
        );
if (_l.overflow) {
return 0;
}
// There can't be an underflow in the subtraction because of the previous check
        unchecked {
// T := t1 - t0 # length of time period in seconds
            _l.T = (_blockTimestamp - _interestRateTimestamp).toInt256();
}

        _l.u = EasyMath.calculateUtilization(DP, _totalDeposits, _totalBorrowAmount).toInt256();
        _l.DP = int256(DP);
if (_l.u > _c.ucrit) {
// rp := kcrit *(1 + Tcrit + beta *T)*( u0 - ucrit )
            _l.rp = _c.kcrit * (_l.DP + _c.Tcrit + _c.beta * _l.T) / _l.DP * (_l.u - _c.ucrit) / _l.DP;
} else {
// rp := min (0, klow * (u0 - ulow ))
            _l.rp = _min(0, _c.klow * (_l.u - _c.ulow) / _l.DP);
}
// rlin := klin * u0 # lower bound between t0 and t1
        _l.rlin = _c.klin * _l.u / _l.DP;
// ri := max(ri , rlin )
        _l.ri = _max(_c.ri, _l.rlin);
// ri := max(ri + ki * (u0 - uopt ) * T, rlin )
        _l.ri = _max(_l.ri + _c.ki * (_l.u - _c.uopt) * _l.T / _l.DP, _l.rlin);
// rcur := max (ri + rp , rlin ) # current per second interest rate
        rcur = (_max(_l.ri + _l.rp, _l.rlin)).toUint256();
        rcur *= 365 days;
}
​,Root cause: 
Arbitrage,20230424,Axioma,https://web3sec.notion.site/Presale-is-cheaper-than-PancakeSwap-ac1b886afbb4436c8c40c2eae5bb4d9b?pvs=25,21 WBNB,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Axioma_exp.sol,SolidityCopyfunction buyToken() public payable {
uint256 bnbAmountToBuy = msg.value;
uint256 tokenAmount = bnbAmountToBuy.mul(rate).div(10**9);
require(token.balanceOf(address(this)) >= tokenAmount, "INSUFFICIENT_BALANCE_IN_CONTRACT");
payable(PresaleOwner).transfer(bnbAmountToBuy);
uint256 taxAmount = tokenAmount.mul(buyTax).div(100);
      token.transfer(PresaleOwner, taxAmount);
(bool sent) = token.transfer(msg.sender, tokenAmount.sub(taxAmount));
require(sent, "FAILED_TO_TRANSFER_TOKENS_TO_BUYER");
}
​,Root cause:
Deflationary token,20230419,OLIFE,https://web3sec.notion.site/deliver-decreases-supply-93b832531cc54b38b2e95df8abc98131?pvs=25,32 WBNB,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/OLIFE_exp.sol,SolidityCopyfunction deliver(uint256 tAmount) public {
address sender = _msgSender();
require(!_isExcluded[sender], "Excluded addresses cannot call this function");
(uint256 rAmount,,,,,,) = _getValues(tAmount);
    _rOwned[sender] = _rOwned[sender].sub(rAmount);
    _rTotal = _rTotal.sub(rAmount);
    _tFeeTotal = _tFeeTotal.add(tAmount);
}
​,Root cause:
Math,20230416,Swapos V2,https://web3sec.notion.site/Incorrect-K-check-84008aa2e24840be92b1ecf156c24d0a?pvs=25,$468k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Swapos_exp.sol,SolidityCopyfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
(uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');
uint balance0;
uint balance1;
{ // scope for _token{0,1}, avoids stack too deep errors
address _token0 = token0;
address _token1 = token1;
require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');
if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));
}
uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
{ // scope for reserve{0,1}Adjusted, avoids stack too deep errors
uint balance0Adjusted = balance0.mul(10000).sub(amount0In.mul(3));
uint balance1Adjusted = balance1.mul(10000).sub(amount1In.mul(3));
require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');  // @audit: should be 10_000 as above
}
_update(balance0, balance1, _reserve0, _reserve1);
emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
}
​,Root cause:
MathDonateUnder/Overflow,20230415,HundredFinance,https://web3sec.notion.site/cToken-redeem-is-rounded-down-e7c51d4fa49f45d59222e8822d2d4f13?pvs=25,$7M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/HundredFinance_2_exp.sol,SolidityCopyfunction redeemFresh(address redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
...
else
(vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp(vars.exchangeRateMantissa)); // rounded down from 1.9999 -> 1 (should be rounded up to 2)
uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens)
}
​,Root cause:
Misconfiguration,20230413,yearnFinance,https://web3sec.notion.site/Set-bZxUSDC-address-instead-of-bZxUSDT-ddcdbbbd9c1e4a389d36446162cf7182?pvs=25,$11.6M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/YearnFinance_exp.sol,SolidityCopyconstructor() public ERC20Detailed("iearn USDT", "yUSDT", 6) {
	fulcrum = address(0xF013406A0B1d544238083DF0B93ad0d2cBE0f65f);  // misconfigured
}
​,Root cause:
Access Control,20230412,MetaPoint,https://web3sec.notion.site/Public-approve-cd1758695ea441929064585e9d035e65?pvs=25,$820k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/MetaPoint_exp.sol,SolidityCopyfunction approve() public payable { 
    v0, /* bool */ v1 = address(0x3b5e381130673f794a5cf67fbba48688386bea86).approve(msg.sender, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff).gas(msg.gas);
require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error
require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
require(v1 == bool(v1));
}
​,Root cause:
Reentrancy,20230411,Paribus,https://web3sec.notion.site/doTransferOut-before-updating-variables-d1748cbd6b8b49ff8569803258bdb0fb?pvs=25,$100k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Paribus_exp.sol,JavaScriptCopy​,Root cause:
Dex/AMMInsufficient validationAccess Control,20230409,SushiSwap,https://web3sec.notion.site/Sushi-RouteProcessor2-does-not-check-user-input-route-carefully-f2829a332a7c420eb625c70022ac5613?pvs=25,$3.3M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Sushi_Router_exp.sol,SolidityCopy/// @notice Processes the route generated off-chain. Has a lock
/// @param tokenIn Address of the input token
/// @param amountIn Amount of the input token
/// @param tokenOut Address of the output token
/// @param amountOutMin Minimum amount of the output token
/// @return amountOut Actual amount of the output token
function processRoute(
address tokenIn,
uint256 amountIn,
address tokenOut,
uint256 amountOutMin,
address to,
bytes memory route //vulnerable point
) external payable lock returns (uint256 amountOut) {
return processRouteInternal(tokenIn, amountIn, tokenOut, amountOutMin, to, route);
}
​,Root cause:
Reentrancy,20230405,Sentiment,https://web3sec.notion.site/Read-only-reentrancy-of-Balancer-7ced884c11ba4220b3ca1f25ee6faab1?pvs=25,$1M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Sentiment_exp.sol,SolidityCopy
function joinPool(
bytes32 poolId,
address sender,
address recipient,
        JoinPoolRequest memory request
    ) external payable override whenNotPaused {
// This function doesn't have the nonReentrant modifier: it is applied to `_joinOrExit` instead.
// Note that `recipient` is not actually payable in the context of a join - we cast it because we handle both
// joins and exits at once.
_joinOrExit(PoolBalanceChangeKind.JOIN, poolId, sender, payable(recipient), _toPoolBalanceChange(request)); //vulnerable point
}
...
function _joinOrExit(
        PoolBalanceChangeKind kind,
bytes32 poolId,
address sender,
address payable recipient,
        PoolBalanceChange memory change
    ) private nonReentrant withRegisteredPool(poolId) authenticateFor(sender) { //vulnerable point
// This function uses a large number of stack variables (poolId, sender and recipient, balances, amounts, fees,
// etc.), which leads to 'stack too deep' issues. It relies on private functions with seemingly arbitrary
// interfaces to work around this limitation.

        InputHelpers.ensureInputLengthMatch(change.assets.length, change.limits.length);
// We first check that the caller passed the Pool's registered tokens in the correct order, and retrieve the
// current balance for each.
        IERC20[] memory tokens = _translateToIERC20(change.assets);
bytes32[] memory balances = _validateTokensAndGetBalances(poolId, tokens);
...
​,Root cause: 
FlashloansPrice ManipulationBusiness Logic Flaw,20230402,Allbridge,https://web3sec.notion.site/Logic-flaw-in-the-withdraw-function-1193dd18bcbf4c61b103b628f8f79f39?pvs=25,$550k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Allbridge_exp.sol,JavaScriptCopy​,Root cause:
Access Control,20230328,SafeMoon,https://web3sec.notion.site/Public-burn-fa3c3cffd3254c0181ae3f9cd640890b?pvs=25,$8.9M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/safeMoon_exp.sol,SolidityCopyfunction burn(address from, uint256 amount) public { // Vulnerable Point: Public Burn function Without proper Access Control
_tokenTransfer(from, bridgeBurnAddress, amount, 0, false);
}
​,Root cause:
FlashloansBusiness Logic FlawInsufficient validationMisconfiguration,20230325,DBW,https://web3sec.notion.site/getStaticIncome-22abc3ff87e84178b3959de6ff014150?pvs=25,$24k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DBW_exp.sol,SolidityCopyfunction getStaticIncome() public {
if(!hasRole(VIP_ROLE, msg.sender)&&!_is_static_dynamic){
_staticIncome_(msg.sender); //vulnerable point
}
}
​,Root cause:
Access ControlFlashloans,20230322,BIGFI,https://web3sec.notion.site/Public-burn-f91fe4168c59469fb5f5deefc9e00af0?pvs=25,$30k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BIGFI_exp.sol,SolidityCopyfunction burn(uint256 _value) public { // Vulnerable Point: Public Burn function Without proper Access Control
_burn(msg.sender, _value);
}
​,Root cause:
Access ControlBusiness Logic Flaw,20230317,ParaSpace NFT,https://web3sec.notion.site/depositApeCoin-e0b3b62bad5b409ebb4fcb69a9305a19?pvs=25,2,909 ETH,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Paraspace_exp_2.sol,SolidityCopyfunction depositApeCoin(uint256 _amount, address _recipient) public { //vulnerable point _recipient
if (_amount < MIN_DEPOSIT) revert DepositMoreThanOneAPE();
updatePool(APECOIN_POOL_ID);

        Position storage position = addressPosition[_recipient]; //vulnerable point
_deposit(APECOIN_POOL_ID, position, _amount);

        apeCoin.transferFrom(msg.sender, address(this), _amount);
emit Deposit(msg.sender, _amount, _recipient);
}
​,Root cause:
Under/Overflow,20230315,Poolz,https://web3sec.notion.site/CreateMassPools-748f37f2cab04769a883235b8c123d23?pvs=25,$390K,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/poolz_exp.sol,SolidityCopyfunction CreateMassPools(
address _Token,
uint64[] calldata _FinishTime,
uint256[] calldata _StartAmount,
address[] calldata _Owner
    ) external isGreaterThanZero(_Owner.length) isBelowLimit(_Owner.length) returns(uint256, uint256) {
require(_Owner.length == _FinishTime.length, "Date Array Invalid");
require(_Owner.length == _StartAmount.length, "Amount Array Invalid");
TransferInToken(_Token, msg.sender, getArraySum(_StartAmount)); //vulnerable point
uint256 firstPoolId = Index;
for(uint i=0 ; i < _Owner.length; i++){
CreatePool(_Token, _FinishTime[i], _StartAmount[i], _Owner[i]);
}
uint256 lastPoolId = SafeMath.sub(Index, 1);
return (firstPoolId, lastPoolId);
}
​,Root cause:
FlashloansBusiness Logic Flaw,20230313,EulerFinance,https://web3sec.notion.site/donateToReserves-logical-error-0c7ce2ae5fde401ca631167e7e2d5e93?pvs=25,$200M(returned),https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Euler_exp.sol,SolidityCopyfunction donateToReserves(uint subAccountId, uint amount) external nonReentrant {
(address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();
address account = getSubAccount(msgSender, subAccountId);
updateAverageLiquidity(account);
emit RequestDonate(account, amount);

        AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);
uint origBalance = assetStorage.users[account].balance;
uint newBalance;
if (amount == type(uint).max) {
            amount = origBalance;
            newBalance = 0;
} else {
require(origBalance >= amount, "e/insufficient-balance");
            unchecked { newBalance = origBalance - amount; }
}

        assetStorage.users[account].balance = encodeAmount(newBalance);
        assetStorage.reserveBalance = assetCache.reserveBalance = encodeSmallAmount(assetCache.reserveBalance + amount);
emit Withdraw(assetCache.underlying, account, amount);
emitViaProxy_Transfer(proxyAddr, account, address(0), amount);
logAssetStatus(assetCache);
}
​,Root cause:
FlashloansPrice Manipulation,20230308,DKP,https://web3sec.notion.site/Incorrect-get-price-oracle-replies-on-the-balance-8d8b2564cf7d4241969fbd5dad92d41e?pvs=25,$80K,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DKP_exp.sol,JavaScriptCopyfunction 0x1201() private {
require(stor_3_0_19.code.size);
    v0, v1 = stor_3_0_19.balanceOf(_lp).gas(msg.gas);
require(v0); // checks call status, propagates error data on error
MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);
require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
0x2a44(v1);
require(_usdt.code.size);
    v2, v3 = _usdt.balanceOf(_lp).gas(msg.gas);
require(v2); // checks call status, propagates error data on error
MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);
require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
0x2a44(v3);
    v4 = 0x1af2(0xde0b6b3a7640000, v1);
    v5 = 0x1b6d(v3, v4);
return v5;
}
​,Root cause:
Access ControlFlashloans,20230307,Phoenix,https://web3sec.notion.site/delegateCallSwap-function-lack-of-access-control-fde6494823e44524b2f5d5a7d2ef8fd0?pvs=25,$100k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Phoenix_exp.sol,SolidityCopyfunction delegateCallSwap(bytes memory data) public returns (bytes memory) { //vulnerable point Access control
(bool success, bytes memory returnData) = phxSwapLib.delegatecall(data);
assembly {
if eq(success, 0) {
revert(add(returnData, 0x20), returndatasize)
}
}
return returnData;
}
​,Root cause:
Price ManipulationAccess Control,20230227,LaunchZone,https://web3sec.notion.site/Swapx-implementation-leak-of-approval-df386fc08bd144fcbe02d8db33052a1a?pvs=25,$320,000,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/LaunchZone_exp.sol,SolidityCopy​,Root cause:
Price ManipulationAccess Control,20230227,swapX,https://web3sec.notion.site/Swapx-implementation-leak-of-approval-de176507313a438ebdce76d50f699d83?pvs=25,$1M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SwapX_exp.sol,SolidityCopyfunction swap(
        IERC20 srcToken,
        IERC20 dstToken,
address dstReceiver,
uint256 amount,
uint256 minReturnAmount,
address referrer,
bytes calldata data
    )
external
payable 
        whenNotPaused
        returns (uint256 returnAmount)
{
require(minReturnAmount > 0, "Min return should not be 0");
require(data.length > 0, "Call data should exist");

        dstReceiver = (dstReceiver == address(0)) ? msg.sender : dstReceiver;
uint256 initialSrcBalance = srcToken.universalBalanceOf(msg.sender);
uint256 initialDstBalance = dstToken.universalBalanceOf(dstReceiver);
{
(bool success, bytes memory returndata) = swapXImpl.call{value: msg.value}(data); //vulnerable point
if (!success) {
// Look for revert reason and bubble it up if present
if (returndata.length > 0) {
// The easiest way to bubble the revert reason is using memory via assembly
// solhint-disable-next-line no-inline-assembly
assembly {
let returndata_size := mload(returndata)
revert(add(32, returndata), returndata_size)
}
} else {
revert("swap failed");
}
}
}
​,Root cause:
Storage collisionUpgradableMiscalculation,20230224,EFVault,https://web3sec.notion.site/Storage-Collision-During-Upgrade-b00a4f7f2eda4635af6943c149c60c36?pvs=25,$5.1M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/EFVault_exp.sol,SolidityCopyfunction assetsPerShare() internal view returns (uint256) {
return (IController(controller).totalAssets(false)*assetDecimal*1e18) / totalSupply();
function redeem (uint256 shares, address receiver)
public 
	virtual 
	nonReentrant 
	unPaused 
	onlyAllowed 
	returns (uint256 assets)
{
require (shares > 0, "ZERO_SHARES");
require (shares <= balance0f (msg.sender), "EXCEED_TOTAL_BALANCE");
	assets = (shares * assetsPerShare()) / 1e24; // Miscalculation of assets
require (assets <= maxWithdraw, "EXCEED_ONE_TIME_MAX_WITHDRAW");
// Withdraw asset
_withdraw(assets, shares, receiver);
}
​,Root cause: 
stakingMiscalculationFlashloans,20230222,DYNA,https://web3sec.notion.site/Incorrect-Accounting-of-deposit-time-4d62b532b92b44c5a2903152424e6581?pvs=25,$21k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DYNA_exp.sol,SolidityCopy​,Root cause: 
Arbitrary callInsufficient validationDex/AMM,20230218,RevertFinance,https://web3sec.notion.site/Arbitrary-External-Call-Vulnerability-2cc8559005984ec2b917b975b32c9f67?pvs=25,$30k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/RevertFinance_exp.sol,SolidityCopystruct SwapParams {
        IERC20 tokenIn;
        IERC20 tokenOut;
uint256 amountIn;
uint256 minAmountOut;
address recipient; // recipient of tokenOut and leftover tokenIn
bytes swapData;
bool unwrap; // if tokenIn or tokenOut is WETH - unwrap
}
function swap(SwapParams calldata params) external payable returns (uint256 amountOut) {
_prepareAdd(params.tokenIn, IERC20(address(0)), IERC20(address(0)), params.amountIn, 0, 0);
uint amountInDelta;
(amountInDelta, amountOut) = _swap(params.tokenIn, params.tokenOut, params.amountIn, params.minAmountOut, params.swapData);
// send swapped amount of tokenOut
if (amountOut > 0) {
_transferToken(params.recipient, params.tokenOut, amountOut, params.unwrap);
}
// if not all was swapped - return leftovers of tokenIn
uint leftOver = params.amountIn - amountInDelta;
if (leftOver > 0) {
_transferToken(params.recipient, params.tokenIn, leftOver, params.unwrap);
}
}
​,Root cause:
MisconfigurationFlashloansskim,20230217,Starlink,https://web3sec.notion.site/Misconfiguration-in-transfer-function-b8ac8c33074e4cefa656c55979952110?pvs=25,$12k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Starlink_exp.sol,SolidityCopyfunction _transfer(
address sender,
address recipient,
uint256 amount
    ) internal virtual override {
if (
            botAddresses[sender] &&
            amount > antiBotAmount &&
            antiBotTime > block.timestamp
        ) {
revert("Anti Bot");
}
uint256 contractTokenBalance = balanceOf(address(this));
if(contractTokenBalance >= _maxTxAmount) { 
            contractTokenBalance = _maxTxAmount;
}
bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;
bool buyLp = buyIndex >= buyIndexSellLiquify;
if (
            overMinTokenBalance &&
!inSwapAndLiquify && 
            sender != uniswapV2Pair && 
            swapAndLiquifyEnabled 
        ) {
            contractTokenBalance = numTokensSellToAddToLiquidity;
swapAndLiquify(contractTokenBalance);
}
if(recipient == uniswapV2Pair){
if (
                sender != address(this) &&
                recipient != address(this) &&
!_isExcludedFromFee[sender]
) {
if (
                    overMinTokenBalance &&
!inSwapAndLiquify && 
                    sender != uniswapV2Pair && 
                    swapSellLiquifyEnabled 
                ) {
                    contractTokenBalance = numTokensSellToAddToLiquidity;
swapAndLiquify(contractTokenBalance);
}
uint256 _fee = amount.mul(sellFeeRate).div(100);
                super._transfer(sender,mintContract, _fee.mul(LPSellFees).div(sellFeeRate));
                super._transfer(sender, addressForMarketing, _fee.mul(marketSellFees).div(sellFeeRate));
                super._transfer(sender, BurnAddr, _fee.mul(burnSellFees).div(sellFeeRate));
                amount = amount.sub(_fee);
}
}else if(sender == uniswapV2Pair){
if (
                sender != address(this) &&
                recipient != address(this) &&
!_isExcludedFromFee[sender]
) {
if (
                    overMinTokenBalance &&
!inSwapAndLiquify && 
                    buyLp&&
                    swapBuyLiquifyEnabled 
                ) {
                    contractTokenBalance = numTokensSellToAddToLiquidity;
swapAndLiquify(contractTokenBalance);
                    buyIndex =0;
}
uint256 _fee = amount.mul(buyFeeRate).div(100);
                super._transfer(sender,mintContract, _fee.mul(LPBuyFees).div(buyFeeRate));
                super._transfer(sender,addressForMarketing, _fee.mul(marketBuyFees).div(buyFeeRate));
                super._transfer(sender, BurnAddr, _fee.mul(burnBuyFees).div(buyFeeRate));
                amount = amount.sub(_fee);
                buyIndex =buyIndex+1;
}
}
    
        super._transfer(sender, recipient, amount);
}
​,Root cause: 
Arbitrary callDex/AMM,20230217,Dexible,https://web3sec.notion.site/Arbitrary-External-Call-Vulnerability-0e3c798c78114198839e5094ecbc84b5?pvs=25,$1.5M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Dexible_exp.sol,SolidityCopyfunction fill(SwapTypes.SwapRequest calldata request, SwapMeta memory meta) external onlySelf returns (SwapMeta memory) {
preCheck(request, meta) ;
	meta.outAmount = request.tokenOut.token.balanceOf(address(this));
for (uint i=0; i < request.routes.length; ++i) {
		SwapTypes.RouterRequest calldata rr = request.routes[i];
IERC20(rr.routeAmount.token).safeApprove(rr.spender, rr.routeAmount.amount);
(bool s, ) = rr.router.call.(routerData); //Vulnerable Point: The attacker can make an arbitrary external call from the contract.
if(!s) {
revert ("Failed to swap");
}
}
​,Root cause: 
Incorrect logiclendingMiscalculation,20230217,Platypusdefi,https://web3sec.notion.site/Flawed-emergencyWithdraw-function-74fc1a377a6e49b1b9ef4236c6e09594?pvs=25,$8.5M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Platypus_exp.sol,SolidityCopyfunction emergencyWithdraw(uint256 _pid) public nonReentrant {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
if (address(platypusTreasure) != address(0x00)) {
(bool isSolvent, ) = platypusTreasure.isSolvent(msg.sender, address(poolInfo[_pid].lpToken), true); //Vulnerable Point: No Check for Adjustment for borrowed funds
require(isSolvent, 'remaining amount exceeds collateral factor');
}
// reset rewarder before we update lpSupply and sumOfFactors
        IBoostedMultiRewarder rewarder = pool.rewarder;
if (address(rewarder) != address(0)) {
            rewarder.onPtpReward(msg.sender, user.amount, 0, user.factor, 0);
}
// SafeERC20 is not needed as Asset will revert if transfer fails
        pool.lpToken.transfer(address(msg.sender), user.amount);
// update non-dialuting factor
        pool.sumOfFactors -= user.factor;

        user.amount = 0;
        user.factor = 0;
        user.rewardDebt = 0;
emit EmergencyWithdraw(msg.sender, _pid, user.amount);
}
​,Root cause:
MiscalculationDeflationary token,20230210,Sheep Token,https://web3sec.notion.site/Price-Manipulation-of-deflationary-tokens-via-flashloan-c139bc9bb4de44d19f48d7791baabb53?pvs=25,$3K,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Sheep_exp.sol,SolidityCopyfunction balanceOf(address account) public view override returns (uint256) {
if (_isExcluded[account]) return _tOwned[account];
return tokenFromReflection(_rOwned[account]);
}
​,Root cause: 
ReentrancyPrice Manipulation,20230210,dForce,https://web3sec.notion.site/Read-Only-Reentrancy-4d70f8bfd63946c5bbb2e8543cbd35d9?pvs=25,$3.65M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/dForce_exp.sol,SolidityCopy@view
@external
def get_virtual_price() -> uint256:
"""
    @notice The current virtual price of the pool LP token
    @dev Useful for calculating profits
    @return LP token virtual price normalized to 1e18
"""
    D: uint256 = self.get_D(self._xp(self._stored_rates()), self._A())
    # D is in the units similar to DAI (e.g. converted to precision 1e18)
    # When balanced, D = n * x_u - total virtual value of the portfolio
    token_supply: uint256 = ERC20(self.lp_token).totalSupply()
return D * PRECISION / token_supply
​,Root cause: 
Arbitrary callInsufficient validation,20230207,CowSwap,https://web3sec.notion.site/Arbitrary-External-Call-Vulnerability-d4baab44f1d245c59044bc332ac807da?pvs=25,$120k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/CowSwap_exp.sol,SolidityCopyfunction settle(
        IERC20[] calldata tokens, // The function accepts an arbitrary token address from CallData and does not check the token received.
uint256[] calldata clearingPrices,
        GPv2Trade.Data[] calldata trades,
        GPv2Interaction.Data[][3] calldata interactions
    ) external nonReentrant onlySolver {
executeInteractions(interactions[0]);
(
            GPv2Transfer.Data[] memory inTransfers,
            GPv2Transfer.Data[] memory outTransfers
        ) = computeTradeExecutions(tokens, clearingPrices, trades); //vulnerable point

        vaultRelayer.transferFromAccounts(inTransfers); //vulnerable point
executeInteractions(interactions[1]);

        vault.transferToAccounts(outTransfers);
executeInteractions(interactions[2]);
emit Settlement(msg.sender);
}
​,Root cause: 
MiscalculationDeflationary tokenFlashloans,20230207,FDP Token,https://web3sec.notion.site/Price-Manipulation-of-deflationary-tokens-via-flashloan-78ba44b7311343b2a0528eb5e1598fa0?pvs=25,16 WBNB,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/FDP_exp.t.sol,SolidityCopyfunction deliver(uint256 tAmount) public {
address sender = _msgSender();
require(!_isExcluded[sender], "Excluded addresses cannot call this function");
(uint256 rAmount,,,,,) = _getValues(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _rTotal = _rTotal.sub(rAmount);
        _tFeeTotal = _tFeeTotal.add(tAmount);
}
​,Root cause: 
Reentrancy,20230203,Orion Protocol,https://web3sec.notion.site/Reentrancy-in-the-doSwapThroughOrionPool-function-0102b3104d52439a93de79ea722d55c0?pvs=25,$3M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Orion_exp.sol,SolidityCopy​,Root cause: 
Incorrect logicMath,20230203,Spherax USDs,https://web3sec.notion.site/Flawed-internal-accounting-systems-1735b1b56c4e4cf9976d3f4f5a2f521a?pvs=25,$309k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/USDs_exp.sol,No Code,Root cause: 
OracleInsufficient validation,20230202,BonqDAO,https://web3sec.notion.site/Incorrect-Oracle-Implementation-3d891413885741cca4c5aa35b9e82c42?pvs=25,$88M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BonqDAO_exp.sol,SolidityCopyfunction submitValue(
bytes32 _queryId,
bytes calldata _value,
uint256 _nonce,
bytes calldata _queryData
    ) external {
require(keccak256(_value) != keccak256(""), "value must be submitted");
        Report storage _report = reports[_queryId];
require(
            _nonce == _report.timestamps.length || _nonce == 0,
"nonce must match timestamp index"
);
        StakeInfo storage _staker = stakerDetails[msg.sender];
require(
            _staker.stakedBalance >= stakeAmount, // Its checks if the staker balance is more than stakeAmount i.e. 10 TRB
"balance must be greater than stake amount"
);
require(
(block.timestamp - _staker.reporterLastTimestamp) * 1000 >
(reportingLock * 1000) / (_staker.stakedBalance / stakeAmount),
"still in reporter time lock, please wait!"
);
....
....
        _report.timestampIndex[block.timestamp] = _report.timestamps.length;
        _report.timestamps.push(block.timestamp);
        _report.timestampToBlockNum[block.timestamp] = block.number;
        _report.valueByTimestamp[block.timestamp] = _value; // Vulnerable Point: The value is assigned here. Anyone who has staked 10TRB can submit the balance. 
        _report.reporterByTimestamp[block.timestamp] = msg.sender;
// Disperse Time Based Reward
uint256 _reward = ((block.timestamp - timeOfLastNewValue) * timeBasedReward) / 300; //.5 TRB per 5 minutes
​,Root cause: 
skimFlashloans,20230126,TomInu Token,https://web3sec.notion.site/reflective-token-skim-abuse-a52a2621ece54dcb90008be5ac723354?pvs=25,22 ETH,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/TINU_exp.t.sol,SolidityCopyfunction deliver(uint256 tAmount) public {
address sender = _msgSender();
require(!_isExcluded[sender], "Excluded addresses cannot call this function");
(uint256 rAmount,,,,,) = _getValues(tAmount);
            _rOwned[sender] = _rOwned[sender].sub(rAmount);
            _rTotal = _rTotal.sub(rAmount);
            _tFeeTotal = _tFeeTotal.add(tAmount);
}
​,Root cause: 
Token-TransferRug-Pull(Protocol Side),20230119,ThoreumFinance,https://web3sec.notion.site/Rug-Pull-e6a5293601c34aa4ab93c74da41caabb?pvs=25,2000 BNB,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/ThoreumFinance_exp.sol,No Code,Root cause:
Deflationary tokenERC20Token-Transfer,20230118,QTN,https://web3sec.notion.site/deliver-decreases-supply-18dfe803740b4113885f358d32649646?pvs=25,2 ETH,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/QTN_exp.sol,JavaScriptCopyfunction balanceOf(address account) public view override returns (uint256) {
if(account == uniswapV2Pair)
return uniswapV2PairAmount;
return _gonBalances[account].div(_gonsPerFragment); //vulnerable point
}
function rebasePlus(uint256 _amount) private {
         _totalSupply = _totalSupply.add(_amount.div(5));
        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);
}
function _transfer(address from, address to, uint256 amount) private {
require(from != address(0), "ERC20: transfer from the zero address");
require(to != address(0), "ERC20: transfer to the zero address");
require(amount > 0, "ERC20: Transfer amount must be greater than zero");
if (from != owner() && to != owner()) {
            uint256 txLimitAmount = _totalSupply.mul(_percentForTxLimit).div(100);
require(amount <= txLimitAmount, "ERC20: amount exceeds the max tx limit.");
if(from != uniswapV2Pair) { //vulnerable point
require(!blacklist[from] && !blacklist[to], 'ERC20: the transaction was blocked.');
require(_buyInfo[from] == 0 || _buyInfo[from].add(_timeLimitFromLastBuy) < now, "ERC20: Tx not allowed yet.");
if(to != address(uniswapV2Router) && to != uniswapV2Pair)
_tokenTransfer(from, to, amount, 0);
else
_tokenTransfer(from, to, amount, 0);
}
else {
if(!_live)
                    blacklist[to] = true;
require(balanceOf(to) <= txLimitAmount, 'ERC20: current balance exceeds the max limit.');
                
                _buyInfo[to] = now;
_tokenTransfer(from, to, amount, 0);

                uint256 rebaseLimitAmount = _totalSupply.mul(_percentForRebase).div(100);
                uint256 currentBalance = balanceOf(to);
                uint256 newBalance = currentBalance.add(amount);
if(currentBalance < rebaseLimitAmount && newBalance < rebaseLimitAmount) {
rebasePlus(amount);
}
}
} else {
_tokenTransfer(from, to, amount, 0);
}
}
​,Root cause:
Incorrect logicSandwich,20230118,UPS,https://web3sec.notion.site/burn-token-in-function-_transfer-0dc0e611e6874f4ca54c219a7c70a3b8?pvs=25,22 ETH,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Upswing_exp.sol,JavaScriptCopyfunction releasePressure(address _address) internal {
        uint256 amount = myPressure(_address);
if(amount < balanceOf(UNIv2)) {
require(_totalSupply.sub(amount) >= _initialSupply.div(1000), "There is less than 0.1% of the Maximum Supply remaining, unfortunately, kabooming is over");
            
            sellPressure[_address] = 0;
addToSteam(_address, amount);
ERC20._burn(UNIv2, amount); //vulnerable point

            _UPSBurned = _UPSBurned.add(amount);
            emit BurnedFromLiquidityPool(_address, amount);
_generateSteamFromUPSBurn(_address);
            emit SteamGenerated(_address, amount);
            
            txCount[_address] = 0;
} else if (amount > 0) {
            sellPressure[_address] = sellPressure[_address].div(2);
}
​,Root cause:
Insufficient validationstaking,20230117,OmniEstate,https://web3sec.notion.site/insufficient-check-of-the-arguments-96129dae563248e69fbf349f8ad720cd?pvs=25,$70k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/OmniEstate_exp.sol,JavaScriptCopy// ivesting function for staking
function invest(uint256 end_date, uint256 qty_ort) external whenNotPaused {
require(qty_ort > 0, "amount cannot be 0");
//transfer token to this smart contract
        stakeToken.approve(address(this), qty_ort);
        stakeToken.safeTransferFrom(msg.sender, address(this), qty_ort);
//save their staking duration for further use
if (end_date == 3) {
            end_staking[msg.sender] = block.timestamp + 90 days;
            duration[msg.sender] = 3;
} else if (end_date == 6) {
            end_staking[msg.sender] = block.timestamp + 180 days;
            duration[msg.sender] = 6;
} else if (end_date == 12) {
            end_staking[msg.sender] = block.timestamp + 365 days;
            duration[msg.sender] = 12;
} else if (end_date == 24) {
            end_staking[msg.sender] = block.timestamp + 730 days;
            duration[msg.sender] = 24;
}
//calculate reward tokens  for further use
        uint256 check_reward = _Check_reward(duration[msg.sender], qty_ort) /
1 ether;
//save values in array
        tokens_staking.push(
staking(
                msg.sender,
                qty_ort,
                end_staking[msg.sender],
                duration[msg.sender],
true,
                check_reward
            )
);
//save array index in map
        uint256 lockId = tokens_staking.length - 1;
        userStake[msg.sender].push(lockId);

        emit Invest(
            msg.sender,
            lockId,
            end_staking[msg.sender],
            duration[msg.sender],
            qty_ort,
            check_reward
        );
}
//Reward Calculation
function _Check_reward(uint256 durations, uint256 balance)
        internal
        returns (uint256)
{
        total_percent2 = balance / 1 ether;
//if user stakes token for 3 months
if (durations == 3) {
if (total_percent2 >= 10000 && total_percent2 < 40000) {
                total_percent = _Percentage(balance, 600000000000000000);
} else if (total_percent2 >= 40000 && total_percent2 < 60000) {
                total_percent = _Percentage(balance, 1200000000000000000);
} else if (total_percent2 >= 60000 && total_percent2 < 80000) {
                total_percent = _Percentage(balance, 1800000000000000000);
} else if (total_percent2 >= 80000 && total_percent2 < 100000) {
                total_percent = _Percentage(balance, 2400000000000000000);
} else if (total_percent2 >= 100000) {
                total_percent = _Percentage(balance, 3000000000000000000);
}
} else if (durations == 6) {
if (total_percent2 >= 10000 && total_percent2 < 40000) {
                total_percent = _Percentage(balance, 1600000000000000000);
} else if (total_percent2 >= 40000 && total_percent2 < 60000) {
                total_percent = _Percentage(balance, 3200000000000000000);
} else if (total_percent2 >= 60000 && total_percent2 < 80000) {
                total_percent = _Percentage(balance, 4800000000000000000);
} else if (total_percent2 >= 80000 && total_percent2 < 100000) {
                total_percent = _Percentage(balance, 6400000000000000000);
} else if (total_percent2 >= 100000) {
                total_percent = _Percentage(balance, 8000000000000000000);
}
} else if (durations == 12) {
if (total_percent2 >= 10000 && total_percent2 < 40000) {
                total_percent = _Percentage(balance, 4000000000000000000);
} else if (total_percent2 >= 40000 && total_percent2 < 60000) {
                total_percent = _Percentage(balance, 8000000000000000000);
} else if (total_percent2 >= 60000 && total_percent2 < 80000) {
                total_percent = _Percentage(balance, 12000000000000000000);
} else if (total_percent2 >= 80000 && total_percent2 < 100000) {
                total_percent = _Percentage(balance, 16000000000000000000);
} else if (total_percent2 >= 100000) {
                total_percent = _Percentage(balance, 20000000000000000000);
}
} else if (durations == 24) {
if (total_percent2 >= 10000 && total_percent2 < 40000) {
                total_percent = _Percentage(balance, 11200000000000000000);
} else if (total_percent2 >= 40000 && total_percent2 < 60000) {
                total_percent = _Percentage(balance, 22400000000000000000);
} else if (total_percent2 >= 60000 && total_percent2 < 80000) {
                total_percent = _Percentage(balance, 33600000000000000000);
} else if (total_percent2 >= 80000 && total_percent2 < 100000) {
                total_percent = _Percentage(balance, 44800000000000000000);
} else if (total_percent2 >= 100000) {
                total_percent = _Percentage(balance, 56000000000000000000);
}
}
return total_percent;
}
​,Root cause:
ReentrancylendingOracle,20230116,MidasCapital,https://web3sec.notion.site/Read-Only-Reentrancy-8fb249fd24d74980aa71f6cff8525d6a?pvs=25,$650k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Midas_exp.sol,JavaScriptCopyfunction redeemFresh(
address redeemer,
    uint256 redeemTokensIn,
    uint256 redeemAmountIn
) internal returns (uint256) {
require(redeemTokensIn == 0 || redeemAmountIn == 0, "!redeemTokensInorOut!=0");
 
    RedeemLocalVars memory vars;
/* exchangeRate = invoke Exchange Rate Stored() */
(vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
if (vars.mathErr != MathError.NO_ERROR) {
return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));
}
if (redeemAmountIn == type(uint256).max) {
      redeemAmountIn = comptroller.getMaxRedeemOrBorrow(redeemer, address(this), false);
}
/* If redeemTokensIn > 0: */
if (redeemTokensIn > 0) {
/*
       * We calculate the exchange rate and the amount of underlying to be redeemed:
       *  redeemTokens = redeemTokensIn
       *  redeemAmount = redeemTokensIn x exchangeRateCurrent
       */
      vars.redeemTokens = redeemTokensIn;
(vars.mathErr, vars.redeemAmount) = mulScalarTruncate(
Exp({ mantissa: vars.exchangeRateMantissa }),
        redeemTokensIn
      );
if (vars.mathErr != MathError.NO_ERROR) {
return
failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint256(vars.mathErr));
}
} else {
/*
       * We get the current exchange rate and calculate the amount to be redeemed:
       *  redeemTokens = redeemAmountIn / exchangeRate
       *  redeemAmount = redeemAmountIn
       */
(vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate( //vulnerable point
        redeemAmountIn,
Exp({ mantissa: vars.exchangeRateMantissa })
);
if (vars.mathErr != MathError.NO_ERROR) {
return
failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint256(vars.mathErr));
}
 
      vars.redeemAmount = redeemAmountIn;
}
/* Fail if redeem not allowed */
    uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);
if (allowed != 0) {
return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);
}
/* Verify market's block number equals current block number */
if (accrualBlockNumber != getBlockNumber()) {
return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);
}
/*
     * We calculate the new total supply and redeemer balance, checking for underflow:
     *  totalSupplyNew = totalSupply - redeemTokens
     *  accountTokensNew = accountTokens[redeemer] - redeemTokens
     */
(vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
if (vars.mathErr != MathError.NO_ERROR) {
return
failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint256(vars.mathErr));
}
(vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
if (vars.mathErr != MathError.NO_ERROR) {
return
failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));
}
/* Fail gracefully if protocol has insufficient cash */
if (getCashPrior() < vars.redeemAmount) {
return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);
}
/////////////////////////
// EFFECTS & INTERACTIONS
// (No safe failures beyond this point)
/* We write previously calculated values into storage */
    totalSupply = vars.totalSupplyNew;
    accountTokens[redeemer] = vars.accountTokensNew;
/*
     * We invoke doTransferOut for the redeemer and the redeemAmount.
     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
     *  On success, the cToken has redeemAmount less of cash.
     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
     */
doTransferOut(redeemer, vars.redeemAmount);
/* We emit a Transfer event, and a Redeem event */
    emit Transfer(redeemer, address(this), vars.redeemTokens);
    emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);
/* We call the defense hook */
    comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);
return uint256(Error.NO_ERROR);
}
​,Root cause:
Misconfiguration,20230112,UFDao,https://web3sec.notion.site/Misconfiguration-83e2224099e54ea0bfda1138223527eb?pvs=25,$90k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/UFDao_exp.sol,JavaScriptCopyfunction buyPublicOffer(address _dao, uint256 _lpAmount)
        external
        nonReentrant
        returns (bool)
{
require(
IFactory(factory).containsDao(_dao),
"Shop: only DAO can sell LPs"
);

        PublicOffer memory publicOffer = publicOffers[_dao]; // Vulnerable point
require(publicOffer.isActive, "Shop: this offer is disabled");
IERC20(publicOffer.currency).safeTransferFrom(
            msg.sender,
            _dao,
(_lpAmount * publicOffer.rate) / 1e18 // Vulnerable point
);

        address lp = IDao(_dao).lp();

        bool b = ILP(lp).mint(msg.sender, _lpAmount);
require(b, "Shop: mint error");
return true;
}
​,Root cause:
Oraclelending,20230112,RoeFinance,https://web3sec.notion.site/Manipulation-of-the-price-oracle-38e9a0e97e3a4cf6947f70790d3f71f5?pvs=25,$80k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/RoeFinance_exp.sol,SolidityCopyfunction borrow(
address asset,
uint256 amount,
uint256 interestRateMode,
uint16 referralCode,
address onBehalfOf
  ) external override whenNotPaused {
    DataTypes.ReserveData storage reserve = _reserves[asset];
_executeBorrow(
ExecuteBorrowParams(
        asset,
        msg.sender,
        onBehalfOf,
        amount,
        interestRateMode,
        reserve.aTokenAddress,
        referralCode,
true
)
);
}
function _executeBorrow(ExecuteBorrowParams memory vars) internal {
    DataTypes.ReserveData storage reserve = _reserves[vars.asset];
    DataTypes.UserConfigurationMap storage userConfig = _usersConfig[vars.onBehalfOf];
address oracle = _addressesProvider.getPriceOracle();
uint256 amountInETH =
IPriceOracleGetter(oracle).getAssetPrice(vars.asset).mul(vars.amount).div(
10**reserve.configuration.getDecimals()
);

    ValidationLogic.validateBorrow(
      vars.asset,
      reserve,
      vars.onBehalfOf,
      vars.amount,
      amountInETH,
      vars.interestRateMode,
      _maxStableRateBorrowSizePercent,
      _reserves,
      userConfig,
      _reservesList,
      _reservesCount,
      oracle
    );

    reserve.updateState();
uint256 currentStableRate = 0;
bool isFirstBorrowing = false;
if (DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE) {
      currentStableRate = reserve.currentStableBorrowRate;

      isFirstBorrowing = IStableDebtToken(reserve.stableDebtTokenAddress).mint(
        vars.user,
        vars.onBehalfOf,
        vars.amount,
        currentStableRate
      );
} else {
      isFirstBorrowing = IVariableDebtToken(reserve.variableDebtTokenAddress).mint(
        vars.user,
        vars.onBehalfOf,
        vars.amount,
        reserve.variableBorrowIndex
      );
}
if (isFirstBorrowing) {
      userConfig.setBorrowing(reserve.id, true);
}

    reserve.updateInterestRates(
      vars.asset,
      vars.aTokenAddress,
0,
      vars.releaseUnderlying ? vars.amount : 0
);
if (vars.releaseUnderlying) {
IAToken(vars.aTokenAddress).transferUnderlyingTo(vars.user, vars.amount);
}
emit Borrow(
      vars.asset,
      vars.user,
      vars.onBehalfOf,
      vars.amount,
      vars.interestRateMode,
      DataTypes.InterestRateMode(vars.interestRateMode) == DataTypes.InterestRateMode.STABLE
        ? currentStableRate
        : reserve.currentVariableBorrowRate,
      vars.referralCode
    );
}
​,Root cause: 
skimERC20,20230110,BRA,https://web3sec.notion.site/doubles-reward-the-tax-fee-to-the-pancake-pair-67248a5a986645b8a3fd4e2b2395da79?pvs=25,$224K,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BRA.exp.sol,SolidityCopyfunction _transfer(address sender, address recipient, uint amount) internal {
require(sender != address(0), "BEP20: transfer from the zero address");
bool recipientAllow = ConfigBRA(BRA).isAllow(recipient);
bool senderAllowSell = ConfigBRA(BRA).isAllowSell(sender);
uint BuyPer = ConfigBRA(BRA).BuyPer();
uint SellPer = ConfigBRA(BRA).SellPer();
address BuyTaxTo_ = address(0);
address SellTaxTo_ = address(0);

        _balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");
uint256 finalAmount = amount;
uint256 taxAmount = 0;
if(sender==uniswapV2Pair&&!recipientAllow){
            taxAmount = amount.div(10000).mul(BuyPer);
            BuyTaxTo_ = ConfigBRA(BRA).BuyTaxTo();
}
if(recipient==uniswapV2Pair&&!senderAllowSell){
            taxAmount = amount.div(10000).mul(SellPer);
            SellTaxTo_ = ConfigBRA(BRA).SellTaxTo();
}

        finalAmount = finalAmount - taxAmount;
if(BuyTaxTo_ != address(0)){
            _balances[BuyTaxTo_] = _balances[BuyTaxTo_].add(taxAmount);
emit Transfer(sender, BuyTaxTo_, taxAmount);
}
if(SellTaxTo_ != address(0)){
            _balances[SellTaxTo_] = _balances[SellTaxTo_].add(taxAmount);
emit Transfer(sender, SellTaxTo_, taxAmount);
}
        
        _balances[recipient] = _balances[recipient].add(finalAmount);
if (recipient == address(0) ) {
            totalBurn = totalBurn.add(amount);
            _totalSupply = _totalSupply.sub(amount);
emit Burn(sender, address(0), amount);
}
emit Transfer(sender, recipient, finalAmount);
}

​,Root cause: 
stakingFlashloans,20230103,GDS,https://web3sec.notion.site/abused-the-LP-Mining-mechanism-by-Flashloan-667493787cdf4d21bf50e11d8f4dd61d?pvs=25,$180k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/GDS_exp.sol,SolidityCopy​,Root cause: 
Insufficient validationFlashloansskim,20221230,DFS,https://web3sec.notion.site/flawed-price-calculation-of-a-deflation-token-c85fdf3fed674e3d928125c76a53352e?pvs=25,$1450,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DFS_exp.sol,SolidityCopyfunction _transfer(
address from,
address to,
uint256 amount
    ) internal {
require(from != address(0), "ERC20: transfer from the zero address");
require(amount > 0, "Transfer amount must be greater than zero");
if (from == address(this) || to == address(this)) {
return;
}
uint256 rate = 5;
uint256 fee = 0;
if (to == address(pair) || from == address(pair) ) {
if (takeFee && !exclusiveFromFee[from]) {
                fee = amount.mul(rate).div(1000);
                _balance[from] = _balance[from].sub(amount).sub(fee);
                _balance[destroyAddress] = _balance[destroyAddress].add(fee);
emit Transfer(from, destroyAddress, fee);
}
} else {
            _balance[from] = _balance[from].sub(amount);
}
if (_balance[from] == 0 && holders.length != 0) {
            holders[holdersIndex[from]] = holders[holders.length-1];
            holdersIndex[holders[holders.length-1]] = holdersIndex[from];
            holders.pop();
            includeHolders[from] = false;
}
        _balance[to] = _balance[to].add(amount);
if (!includeHolders[to]) {
            holdersIndex[to] = holders.length;
            holders.push(to);
            includeHolders[to] = true;
}
emit Transfer(from, to, amount);
}

​,Root cause: 
Insufficient validationReentrancy,20221229,JAY,https://web3sec.notion.site/Reenter-by-pass-fake-token-5dc4fdc2f76e4cdd899ad61de195677b?pvs=25,15.32 ETH,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/JAY_exp.sol,SolidityCopyfunction buyJay(
address[] calldata erc721TokenAddress,
uint256[] calldata erc721Ids,
address[] calldata erc1155TokenAddress,
uint256[] calldata erc1155Ids,
uint256[] calldata erc1155Amounts
    ) public payable {
require(start, "Not started!");
uint256 total = erc721TokenAddress.length;
if (total != 0) buyJayWithERC721(erc721TokenAddress, erc721Ids);
if (erc1155TokenAddress.length != 0)
            total = total.add(
buyJayWithERC1155(
                    erc1155TokenAddress,
                    erc1155Ids,
                    erc1155Amounts
                )
);
if (total >= 100)
require(
                msg.value >= (total).mul(sellNftFeeEth).div(2),
"You need to pay ETH more"
);
else
require(
                msg.value >= (total).mul(sellNftFeeEth),
"You need to pay ETH more"
);
_mint(msg.sender, ETHtoJAY(msg.value).mul(97).div(100));
(bool success, ) = dev.call{value: msg.value.div(34)}("");
require(success, "ETH Transfer failed.");

        nftsSold += total;
emit Price(block.timestamp, JAYtoETH(1 * 10**18));
}
function JAYtoETH(uint256 value) public view returns (uint256) {
return (value * address(this).balance).div(totalSupply());
}

​,Root cause: 
Arbitrary callDex/AMM,20221225,Rubic,https://web3sec.notion.site/Arbitrary-External-Call-0d602c84ea68430196823a5f5d0b77ee?pvs=25,$1.5M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Rubic_exp.sol,SolidityCopyfunction routerCallNative(BaseCrossChainParams calldata _params, bytes calldata _data)
external
payable
        nonReentrant
        whenNotPaused
        eventEmitter(_params)
{
if (!availableRouters.contains(_params.router)) {
revert RouterNotAvailable();
}

        IntegratorFeeInfo memory _info = integratorToFeeInfo[_params.integrator];
uint256 _amountIn = accrueTokenFees(
            _params.integrator,
            _info,
accrueFixedCryptoFee(_params.integrator, _info),
0,
address(0)
);

        AddressUpgradeable.functionCallWithValue(_params.router, _data, _amountIn);
}

​,Root cause:  
ReentrancyDex/AMM,20221223,Defrost,https://web3sec.notion.site/Reentrancy-746c0dcd97744242a7d7dc1bfdfe7501?pvs=25,$170k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Defrost_exp.sol,SolidityCopyfunction flashLoan(
        IERC3156FlashBorrower receiver,
address token,
uint256 amount,
bytes calldata data
    ) external virtual returns (bool) {
require(token == address(asset),"flash borrow token Error!");
uint256 fee = flashFee(token, amount);
onWithdraw(address(receiver),amount);
require(
            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE,
"invalid return value"
);
onDeposit(address(receiver),amount + fee,0);
emit FlashLoan(msg.sender,address(receiver),token,amount);
return true;
}
function deposit(uint256 _amount, address receiver) external returns (uint256){
uint256 amount = _deposit(msg.sender,_amount,receiver);
emit Deposit(msg.sender,receiver,_amount,amount);
return amount;
}
​,Root cause: 
Price ManipulationFlashloansclaimTokens,20221214,Nmbplatform,https://web3sec.notion.site/Staking-reward-is-based-on-spot-price-626996b6df1a41599e9d1443fb1617ff?pvs=25,$76k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Nmbplatform_exp.sol,SolidityCopy​,Root cause: 
Incorrect logic,20221213,ElasticSwap,https://web3sec.notion.site/removeLiquidity-doesn-t-sync-the-reserves-b81ed96543f4412999cb6cce4c16833e?pvs=25,$845k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/ElasticSwap_exp.sol,SolidityCopyfunction addLiquidity(uint256 _baseTokenQtyDesired, uint256 _quoteTokenQtyDesired, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, address _liquidityTokenRecipient){//vulnerable point
	MathLib.TokenQtys memory tokenQtys = MathLib.calculateAddLiquidityQuantities(, , , , IERC20(baseToken).balanceOf(address(this)), totalSupply, internalBalances);
	internalBalances.kLast = internalBalances.baseTokenReserveQty * internalBalances.quoteTokenReserveQty;
}
function removeLiquidity(uint256 _liquidityTokenQty, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, address _tokenRecipient){//vulnerable point
uint256 baseTokenReserveQty  = IERC20(baseToken).balanceOf(address(this));
uint256 quoteTokenReserveQty = IERC20(quoteToken).balanceOf(address(this));
uint256 baseTokenQtyToReturn  = (_liquidityTokenQty * baseTokenReserveQty) / totalSupplyOfLiquidityTokens;
uint256 quoteTokenQtyToReturn = (_liquidityTokenQty * quoteTokenReserveQty) / totalSupplyOfLiquidityTokens;
uint256 internalBaseTokenReserveQty = internalBalances.baseTokenReserveQty;
uint256 baseTokenQtyToRemoveFromInternalAccounting = (_liquidityTokenQty * internalBaseTokenReserveQty) / totalSupplyOfLiquidityTokens;
	
	internalBalances.baseTokenReserveQty = internalBaseTokenReserveQty = internalBaseTokenReserveQty - baseTokenQtyToRemoveFromInternalAccounting;
	
	internalBalances.quoteTokenReserveQty = internalQuoteTokenReserveQty = internalQuoteTokenReserveQty - quoteTokenQtyToReturn; // @audit: doesn't sync the reserves (as in UniswapPair.burn())
IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);
IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn);
}
​,Root cause: 
Deflationary tokenFlashloansPrice Manipulation,20221212,BGLD,https://web3sec.notion.site/Deflationary-token-abuse-via-skim-db35118332fd47dbb2fedfae4affa77f?pvs=25,$18k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BGLD_exp.sol,JavaScriptCopyfunction _transfer(
address sender,
        address recipient,
        uint256 amount
) internal {
require(sender != address(0), "BEP20: transfer from the zero address");
require(recipient != address(0), "BEP20: transfer to the zero address");
require(amount > 0, "Transfer amount must be greater than zero");

        uint256 onePercent = _findOnePercent(amount);
        uint256 burnFee = onePercent.mul(2);
        uint256 miningFee = onePercent.mul(4);
        uint256 liquidityFee = onePercent.mul(4);
if (!_isExcludedFromFee[sender]) {
require(
                _balances[sender] >
                    amount.add(miningFee).add(liquidityFee).add(burnFee), //vulnerable point
"BEP20: transfer amount + fees exceeds balance"
);
}
​,Root cause: 
FlashloansPrice ManipulationIncorrect logic,20221211,Lodestar,https://web3sec.notion.site/FlashLoan-price-manipulation-Incorrect-logic-in-GLPOracle-d557d4ee34ec47979493b69abe47c3d4?pvs=25,$4M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Lodestar_exp.sol,JavaScriptCopyfunction getPlvGLPPrice() public view returns (uint256) {
        uint256 exchangeRate = getPlutusExchangeRate();

        uint256 glpPrice = getGLPPrice();

        uint256 price = (exchangeRate * glpPrice) / BASE;
return price;
}
function getPlutusExchangeRate() public view returns (uint256) {
//retrieve total assets from plvGLP contract
        uint256 totalAssets = plvGLPInterface(plvGLP).totalAssets();
//retrieve total supply from plvGLP contract
        uint256 totalSupply = EIP20Interface(plvGLP).totalSupply();
//plvGLP/GLP Exchange Rate = Total Assets / Total Supply
        uint256 exchangeRate = (totalAssets * BASE) / totalSupply;
return exchangeRate;
}
​,Root cause: 
FlashloansPrice Manipulation,20221210,MU&MUG,https://web3sec.notion.site/FlashLoan-price-manipulation-35cbc96984f04881a7522eb57beac1c4?pvs=25,$57k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/MUMUG_exp.sol,JavaScriptCopyfunction mu_bond(address stable, uint256 amount) public nonReentrant { //vulnerable point
require(is_approved_stable_coin(stable) ,"Only accepting approved stable coins for bonding");
IERC20 _stable = IERC20(stable);
        Token token = Token(stable);
        uint8 _decimals = token.decimals();
        uint256 _adjusted_amount;
if(18 - _decimals == 0)
            _adjusted_amount = amount;
else {
            _adjusted_amount = (amount/(10**(18-_decimals)));
}
require(_stable.balanceOf(msg.sender) >= _adjusted_amount, "You don't have enough of that token to bond that amount");
(uint256 mu_coin_swap_amount, uint256 mu_coin_amount) = _mu_bond_quote(amount);
require(IERC20(_MuCoin).balanceOf(address(this)) >= mu_coin_amount, "This contract does not have enough Mu Coin");
        _stable.transferFrom(msg.sender, address(this), _adjusted_amount);
IERC20(_MuCoin).transfer(msg.sender, mu_coin_amount);
MuMoneyMinter(_MuMoney).mint(address(this), amount);
}
function mu_gold_bond(address stable, uint256 amount) public nonReentrant{ //vulnerable point
require(is_approved_stable_coin(stable) ,"Only accepting approved stable coins for bonding");
IERC20 _stable = IERC20(stable);
        Token token = Token(stable);
        uint8 _decimals = token.decimals();
        uint256 _adjusted_amount;
if(18 - _decimals == 0)
            _adjusted_amount = amount;
else {
            _adjusted_amount = (amount/(10**(18-_decimals)));
}
require(_stable.balanceOf(msg.sender) >= _adjusted_amount, "You don't have enough of that token to bond that amount");
(uint256 mu_gold_swap_amount, uint256 mu_gold_bond_amount) = _get_mug_bond_quote(amount);
require(IERC20(_MuGold).balanceOf(address(this)) >= mu_gold_bond_amount, "This contract does not have enough Mu Coin");
            _stable.transferFrom(msg.sender, address(this), _adjusted_amount);
IERC20(_MuGold).transfer(msg.sender, mu_gold_bond_amount);
MuMoneyMinter(_MuMoney).mint(address(this), amount);
}
​,Root cause:
FlashloansPrice Manipulation,20221210,TIFIToken,https://web3sec.notion.site/FlashLoan-price-manipulation-540e9cdcf9d142b492fbb0af178b0ee8?pvs=25,87 WBNB,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/TIFI_exp.sol,No Code,Root cause: 
Rug-Pull(Protocol Side),20221209,NOVAToken,https://web3sec.notion.site/Malicious-Unlimted-Minting-Rugged-f569b2e44e994a7082aaf108ae6ab29f?pvs=25,330 BNB,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/NovaExchange_exp.sol,JavaScriptCopy​,Root cause: Malicious Unlimted Minting (Rugged)
Deflationary tokenFlashloansIncorrect logic,20221207,AES,https://web3sec.notion.site/Deflationary-token-abuse-via-skim-c7df1959fe2c4c9786fa9e439e3b80c0?pvs=25,$60k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/AES_exp.sol,JavaScriptCopyfunction _transfer(
address from,
        address to,
        uint256 amount
) internal override {
require(from != address(0), "ERC20: transfer from the zero address");
require(to != address(0), "ERC20: transfer to the zero address");
if(from == address(this) && to == uniswapV2Pair){
super._transfer(from, to, amount);
} else {
if(automatedMarketMakerPairs[from]) {
buyTokenAndFees(from, to, amount);
}else if (automatedMarketMakerPairs[to]){
sellTokenAndFees(from, to, amount); //vulnerable point
}else {
super._transfer(from, to, amount);
}
}
}
function sellTokenAndFees(
address from, 
        address to, 
        uint256 amount
) internal {
        uint256 burnAmount = amount.mul(3).div(100); 
        uint256 otherAmount = amount.mul(1).div(100); 

        amount = amount.sub(burnAmount);
        swapFeeTotal = swapFeeTotal.add(otherAmount);
super._burn(from, burnAmount);
super._transfer(from, to, amount);
}
function distributeFee() public {
        uint256 mokeyFeeTotal = swapFeeTotal.mul(2);
super._transfer(uniswapV2Pair, monkeyWallet, mokeyFeeTotal);
super._transfer(uniswapV2Pair, birdWallet, swapFeeTotal);
super._transfer(uniswapV2Pair, foundationWallet, swapFeeTotal);
super._transfer(uniswapV2Pair, technologyWallet, swapFeeTotal);
super._transfer(uniswapV2Pair, marketingWallet, swapFeeTotal);
        swapFeeTotal = 0;
}
​,Root cause: 
Bad randomness,20221205,RFB,https://web3sec.notion.site/Predicting-Random-Numbers-RFB-Bad-randomness-b85eef0524454becb2a807b71afed2e0?pvs=25,12 BNB,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/RFB_exp.sol,JavaScriptCopyfunction randMod(address buyer,uint256 buyamount) internal  returns(uint){

        uint randnum = uint(keccak256(abi.encodePacked(block.number,block.timestamp,buyer,_balances[pair]))); //vulnerable point
        uint256 buyBNBamount = buyamount.div(10**_decimals).mul(getPrice());
// increase nonce
if(randnum%(10000*luckyMultiplier) == 8888 && buyBNBamount > (0.1 ether)){
            distributor.withdrawDistributor(buyer, 79);
            distributor.withdrawDistributor(marketingFeeReceiver,9);
}else if(randnum%(1000*luckyMultiplier) == 888){
if(buyBNBamount.mul(100) > 10 ether){
                buyBNBamount = 0.1 ether;
}
try distributor.withdrawPlazz(buyer, buyBNBamount.mul(100).mul(90).div(100)){}catch {}
try distributor.withdrawPlazz(marketingFeeReceiver, buyBNBamount.mul(100).mul(10).div(100)){}catch {}
}else if(randnum%(100*luckyMultiplier) == 88){
if(buyBNBamount.mul(10) > 10 ether){
                buyBNBamount = 1 ether;
}
try distributor.withdrawPlazz(buyer, buyBNBamount.mul(10).mul(90).div(100)){}catch {}
try distributor.withdrawPlazz(marketingFeeReceiver, buyBNBamount.mul(10).mul(10).div(100)){}catch {}
}else if(randnum%(10*luckyMultiplier) == 8){
if(buyBNBamount > 10 ether){
                buyBNBamount = 10 ether;
}
try distributor.withdrawPlazz(buyer, buyBNBamount.mul(90).div(100)){}catch {}
try distributor.withdrawPlazz(marketingFeeReceiver, buyBNBamount.mul(10).div(100)){}catch {}
}
return randnum;
}
​,Root cause: 
FlashloansPrice Manipulation,20221205,BBOX,https://web3sec.notion.site/FlashLoan-price-manipulation-_transfer-will-burn-the-BBOX-token-incorrectly-2465104b93144e60bac5513c714f7710?pvs=25,$12k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BBOX_exp.sol,JavaScriptCopyfunction _transfer(
address from,
        address to,
        uint256 amount
) private {
require(from != address(0), "ERC20: transfer from the zero address");
require(amount > 0, "Transfer amount must be greater than zero");
if(
!_isContract(to)
&& _recommerMapping[to] == address(0)
&& amount >= recommeCondition){
if( ammPairs[from] ){
addRelationEx(holder,to);
}else{
addRelationEx(from,to);
}
}

        bool isAddLiquidity;
        bool isDelLiquidity;
( isAddLiquidity, isDelLiquidity) = _isLiquidity(from,to);
if( 
            pairAmountChange 
            && !isAddLiquidity
            && pairAmount > 0
&& !ammPairs[from]
&& pairAmount < balanceOf(uniswapV2Pair)){

            uint v = pairAmount;
            pairAmount = 0;
            _tOwned[uniswapV2Pair] =  _tOwned[uniswapV2Pair].sub(v); //vulnerable point
            _tOwned[address(0)] = _tOwned[address(0)].add(v);
            emit Transfer(uniswapV2Pair, address(0), v);
IUniswapV2Pair(uniswapV2Pair).sync();
}
​,Root cause: 
Flashloans,20221202,OverNight,https://web3sec.notion.site/Flashloan-attacks-force-investment-19e1a0d60ae349e5b262e5067011fb54?pvs=25,$170k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Overnight_exp.sol,No Code,Root cause: 
FlashloansPrice Manipulation,20221201,APC,https://web3sec.notion.site/Incorrect-price-calculation-via-getReverse-82732d5f4d134a5591814f073d610e5f?pvs=25,$6k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/APC_exp.sol,No Code,Root cause: 
Incorrect logicAccess Control,20221129,MBC,https://web3sec.notion.site/Business-Logic-Flaw-Access-Control-f6db9bb68bb94381bc1063e9a9c3f88c?pvs=25,$5.6k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/MBC_exp.sol,JavaScriptCopy​,Root cause: 
Incorrect logic,20221129,SEAMAN,https://web3sec.notion.site/Business-Logic-Flaw-43cf1adbac52409f8f8e093bdefdcaaf?pvs=25,$7k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SEAMAN_exp.sol,JavaScriptCopyhToken = IERC20(0xDB95FBc5532eEb43DeEd56c8dc050c930e31017e);//GVC
lpToken = IERC20(0xDB95FBc5532eEb43DeEd56c8dc050c930e31017e);//GVC
function transfer(address recipient, uint256 amount)
public
    virtual
    override
    returns (bool)
{
_transfer(_msgSender(), recipient, amount);
return true;
}
function _transfer(
address from,
        address to,
        uint256 amount
) internal override {
require(from != address(0), "ERC20: transfer from the zero address");
require(to != address(0), "ERC20: transfer to the zero address");
require(!_isBot[from],"the bot address");
if(_isDelivers[from] || _isDelivers[to]){
super._transfer(from, to, amount);
return;
}
if( uniswapV2Pair.totalSupply() > 0 && balanceOf(address(this)) > balanceOf(address(uniswapV2Pair)).div(10000) && to == address(uniswapV2Pair)){
if (
!swapping &&
                _tokenOwner != from &&
                _tokenOwner != to &&
!ammPairs[from] &&
!(from == address(uniswapV2Router) && !ammPairs[to])&&
                swapAndLiquifyEnabled
            ) {
                swapping = true;
swapAndLiquifyV3(); //vulnerable point
swapAndLiquifyV1(); //vulnerable point
                swapping = false;
}
...
function swapAndLiquifyV1() public {
        uint256 canlpAmount = lpAmount.sub(lpTokenAmount);
        uint256 amountT = balanceOf(address(uniswapV2Pair)).div(10000);
if(balanceOf(address(this)) >= canlpAmount && canlpAmount >= amountT){
if(canlpAmount >= amountT.mul(5))
                canlpAmount = amountT.mul(5);
            lpTokenAmount = lpTokenAmount.add(canlpAmount);
            uint256 beflpBal = lpToken.balanceOf(address(this));
swapTokensFor(canlpAmount,address(lpToken),address(this));
            uint256 newlpBal = lpToken.balanceOf(address(this)).sub(beflpBal);
            lpDivTokenAmount = lpDivTokenAmount.add(newlpBal);
            isLpProc = true;
}
}
function swapAndLiquifyV3() public {
        uint256 canhAmount = hAmount.sub(hTokenAmount);
        uint256 amountT = balanceOf(address(uniswapV2Pair)).div(10000);
if(balanceOf(address(this)) >= canhAmount && canhAmount >= amountT){
if(canhAmount >= amountT.mul(5))
                canhAmount = amountT.mul(5);
            hTokenAmount = hTokenAmount.add(canhAmount);
            uint256 befhBal = hToken.balanceOf(address(this));
swapTokensFor(canhAmount,address(hToken),address(this));
            uint256 newhBal = hToken.balanceOf(address(this)).sub(befhBal);
            hDivTokenAmount = hDivTokenAmount.add(newhBal);
            isHProc = true;
}
}
function swapTokensFor(uint256 tokenAmount,address token,address to) private{
// generate the uniswap pair path of token -> weth
            address[] memory path = new address[](3);
            path[0] = address(this);
            path[1] = address(usdt);
            path[2] = address(token);
// make the swap
            uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens( //vulnerable point
                tokenAmount,
0, // accept any amount of ETH
                path,
                to,
                block.timestamp
            );
}
​,Root cause: 
ERC20CrossChainToken Incompatible,20221123,NUM,https://web3sec.notion.site/NUM-token-incompatible-with-the-Multichain-Router-5e3bc9b894c748e5a0ae71ba5c71fdcb?pvs=25,$13k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/NUM_exp.sol,No Code,Root cause: 
Access Control,20221122,AurumNodePool (AUR),https://web3sec.notion.site/Incorrect-access-control-changeRewardPerNode-d11884eb7b164178b6bd70801fd639f9?pvs=25,$13k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/AUR_exp.sol,SolidityCopy```
function changeRewardPerNode(uint256 _rewardPerDay) external { //vulnerable point - Incorrect access control
    rewardPerDay = _rewardPerDay;
}
```
​,Root cause: 
FlashloansBusiness Logic Flaw,20221121,SDAO,https://web3sec.notion.site/Business-Logic-Flaw-e045e4f035b847ff8bcc9764e088ab60?pvs=25,$13k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SDAO_exp.sol,SolidityCopyfunction getPerTokenReward() public view returns(uint) {
if ( LPInstance.balanceOf(address(this)) == 0) {
return 0;
}
uint newPerTokenReward = (totalStakeReward - lastTotalStakeReward) * 1e18 / LPInstance.balanceOf(address(this));
return PerTokenRewardLast + newPerTokenReward;
}
​,Root cause:
Insufficient validation,20221119,AnnexFinance,https://web3sec.notion.site/Insufficient-Validation-c56a1316b9a641a7aa4d59b090a9722c?pvs=25,$3k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Annex_exp.sol,SolidityCopy​,Root cause:
Business Logic FlawFlashloans,20221117,UEarnPool,https://web3sec.notion.site/Business-logic-flaw-on-reward-distribution-00d50e9accb2465eb032cdb4d02eb7ec?pvs=25,$24k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/UEarnPool_exp.sol,No Code,Root cause:
Incorrect logic,20221116,SheepFarm,https://web3sec.notion.site/Incorrect-logic-when-register-the-new-user-f8f7c4a5e6254650b37bd2d8e7b602f0?pvs=25,1BNB,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/SheepFram_exp.sol,SolidityCopyfunction register(address neighbor) external initialized {
address user = msg.sender;
require(villages[user].timestamp == 0, "just new users"); //@audit not updated while the new user creation
uint256 gems;
        totalVillages++;
if (villages[neighbor].sheeps[0] > 0 && neighbor != manager) {
            gems += GEM_BONUS * 2;
} else{
            neighbor = manager;
            gems += GEM_BONUS;
}
        villages[neighbor].neighbors++;
        villages[user].neighbor = neighbor;
        villages[user].gems += gems;
emit Newbie(msg.sender, gems);
}
​,Root cause:
FlashloansIncorrect logic,20221110,DFXFinance,https://web3sec.notion.site/Logic-issue-with-flashloan-repayment-judgment-7cc9f52587d24886bc4d1ca59f57d71b?pvs=25,$4M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/DFX_exp.sol,SolidityCopyfunction flash(
address recipient,
uint256 amount0,
uint256 amount1,
bytes calldata data
    ) external transactable noDelegateCall isNotEmergency {
uint256 fee = curve.epsilon.mulu(1e18);
require(IERC20(derivatives[0]).balanceOf(address(this)) > 0, 'Curve/token0-zero-liquidity-depth');
require(IERC20(derivatives[1]).balanceOf(address(this)) > 0, 'Curve/token1-zero-liquidity-depth');
uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e18);
uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e18);
uint256 balance0Before = IERC20(derivatives[0]).balanceOf(address(this));
uint256 balance1Before = IERC20(derivatives[1]).balanceOf(address(this));
if (amount0 > 0) IERC20(derivatives[0]).safeTransfer(recipient, amount0);
if (amount1 > 0) IERC20(derivatives[1]).safeTransfer(recipient, amount1);
IFlashCallback(msg.sender).flashCallback(fee0, fee1, data);
uint256 balance0After = IERC20(derivatives[0]).balanceOf(address(this));
uint256 balance1After = IERC20(derivatives[1]).balanceOf(address(this));
require(balance0Before.add(fee0) <= balance0After, 'Curve/insufficient-token0-returned');
require(balance1Before.add(fee1) <= balance1After, 'Curve/insufficient-token1-returned');
// sub is safe because we know balanceAfter is gt balanceBefore by at least fee
uint256 paid0 = balance0After - balance0Before;
uint256 paid1 = balance1After - balance1Before;
IERC20(derivatives[0]).safeTransfer(owner, paid0);
IERC20(derivatives[1]).safeTransfer(owner, paid1);
emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);
}
​,Root cause:
Insufficient validation,20221109,BrahTOPG,https://web3sec.notion.site/Insufficient-Validation-on-zapIn-39533027888f4070be5b75da6f02398c?pvs=25,$89k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BrahTOPG_exp.sol,SolidityCopystruct ZapData {
address requiredToken;
uint256 amountIn;
uint256 minAmountOut;
address allowanceTarget;
address swapTarget;
bytes callData;
}
​,Root cause:
Access Controlcall/delegatecall,20221108,MEV_0ad8,https://web3sec.notion.site/Unlimited-external-call-2f2982ab8bd14bb8b4e1053476e25a84?pvs=25,$282k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/MEV_0ad8.t.sol,SolidityCopy0x
000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48
000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000001
00000000000000000000000000000000000000000000000000000000000000a0
0000000000000000000000000000000000000000000000000000000000000064
23b872dd000000000000000000000000211b6a1137bf539b2750e02b9e525cf5 => 23b872dd TransferFrom
757a35ae000000000000000000000000ae39a6c2379bef53334ea968f4c711c8 => 211b6a1137bf539b2750e02b9e525cf5 => 23b872dd TransferFrom
757a35ae victim
cf3898b600000000000000000000000000000000000000000000000000000015 => ae39a6c2379bef53334ea968f4c711c8cf3898b6 attacker
560e9ff900000000000000000000000000000000000000000000000000000000
​,Root cause:
Incorrect logic,20221108,Kashi,https://web3sec.notion.site/Incorrect-logic-on-exchangeRate-usage-242c9fee208c4ab5aec350fd17a10d5c?pvs=25,$110k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/Kashi_exp.sol,SolidityCopy​,Root cause:
Flashloans,20221107,MooCAKECTX,https://web3sec.notion.site/Flashloan-attack-reward-mechanism-cba5a806e282490fa494e86a8c5ca2db?pvs=25,$140k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/MooCAKECTX_exp.sol,SolidityCopy​,Root cause:
Price Manipulation,20221105,BDEX,https://web3sec.notion.site/Price-manipulation-attack-210bdab2b3ec4eb29f36a213c765273a?pvs=25,16WBNB,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/BDEX_exp.sol,SolidityCopyfunction convertDustToEarned() public whenNotPaused {
require(isAutoComp, "!isAutoComp");
// Converts dust tokens into earned tokens, which will be reinvested on the next earn().
// Converts token0 dust (if any) to earned tokens
uint256 _token0Amt = IERC20(token0Address).balanceOf(address(this));
if (token0Address != earnedAddress && _token0Amt > 0) {
_vswapSwapToken(token0Address, earnedAddress, _token0Amt);
}
// Converts token1 dust (if any) to earned tokens
uint256 _token1Amt = IERC20(token1Address).balanceOf(address(this));
if (token1Address != earnedAddress && _token1Amt > 0) {
_vswapSwapToken(token1Address, earnedAddress, _token1Amt);
}
}
​,Root cause:
Business Logic FlawFlashloans,20221027,VTF Token,https://web3sec.notion.site/Business-Logic-Flaw-on-Reward-387e8d9d8fb6419093484b4dc2c4c791?pvs=25,$50k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/VTF_exp.sol,SolidityCopyfunction updateUserBalance(address _user) public {
uint256 totalAmountOver = super.totalSupply();
if(maxTotal <= totalAmountOver){
			maxCanMint = false;
}
if(userBalanceTime[_user] > 0){
uint256 canMint = getUserCanMint(_user);
if(canMint > 0){
				userBalanceTime[_user] = block.timestamp;
_mint(_user, canMint);
}
}else{
			userBalanceTime[_user] = block.timestamp;
}
}
​,Root cause:
Insufficient validation,20221027,Team Finance,https://web3sec.notion.site/Insufficient-Validation-on-MigrateParams-84f27bc9536549468be66b9f9e9b5157?pvs=25,$15.8M,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/TeamFinance.exp.sol,SolidityCopy/**
     * migrate liquidity from v2 to v3
    */
function migrate(
uint256 _id,
        IV3Migrator.MigrateParams calldata params,
bool noLiquidity,
uint160 sqrtPriceX96,
bool _mintNFT
    )
external
payable
    whenNotPaused
    nonReentrant
    {
require(address(nonfungiblePositionManager) != address(0), "NFT manager not set");
require(address(v3Migrator) != address(0), "v3 migrator not set");
        Items memory lockedERC20 = lockedToken[_id];
require(block.timestamp < lockedERC20.unlockTime, "Unlock time already reached");
require(_msgSender() == lockedERC20.withdrawalAddress, "Unauthorised sender");
require(!lockedERC20.withdrawn, "Already withdrawn");
uint256 totalSupplyBeforeMigrate = nonfungiblePositionManager.totalSupply();
//scope for solving stack too deep error
{
uint256 ethBalanceBefore = address(this).balance;
uint256 token0BalanceBefore = IERC20(params.token0).balanceOf(address(this));
uint256 token1BalanceBefore = IERC20(params.token1).balanceOf(address(this));
//initialize the pool if not yet initialized
if(noLiquidity) {
                v3Migrator.createAndInitializePoolIfNecessary(params.token0, params.token1, params.fee, sqrtPriceX96);
}
IERC20(params.pair).approve(address(v3Migrator), params.liquidityToMigrate);

            v3Migrator.migrate(params);
//refund eth or tokens
uint256 refundEth = address(this).balance - ethBalanceBefore;
(bool refundSuccess,) = _msgSender().call.value(refundEth)("");
require(refundSuccess, 'Refund ETH failed');
uint256 token0BalanceAfter = IERC20(params.token0).balanceOf(address(this));
uint256 refundToken0 = token0BalanceAfter - token0BalanceBefore;
if( refundToken0 > 0 ) {
require(IERC20(params.token0).transfer(_msgSender(), refundToken0));
}
uint256 token1BalanceAfter = IERC20(params.token1).balanceOf(address(this));
uint256 refundToken1 = token1BalanceAfter - token1BalanceBefore;
if( refundToken1 > 0 ) {
require(IERC20(params.token1).transfer(_msgSender(), refundToken1));
}
}
//remove old locked token details
_removeERC20Deposit(_id);
//Get the token id of newly generated nft for v3
uint256 totalSupplyAfterMigrate = nonfungiblePositionManager.totalSupply();
require(totalSupplyAfterMigrate == totalSupplyBeforeMigrate.add(1));
uint256 tokenIndex = totalSupplyAfterMigrate.sub(1);
uint256 tokenId = nonfungiblePositionManager.tokenByIndex(tokenIndex);
//add new locked nft details ( received after migrating liquidity )
uint256 newDepositId = ++depositId;
_addNFTDeposit(_id, newDepositId, tokenId);

        listMigratedDepositIds[newDepositId] = _id;
if (_mintNFT){
require(NFT != address(0), 'NFT: Unintalized');
            nftMinted[newDepositId] = true;
}
if(nftMinted[_id])
{
            nftMinted[_id] = false;
IERC721Extended(NFT).burn(_id);
}
if (_mintNFT){
IERC721Extended(NFT).mintLiquidityLockNFT(_msgSender(), newDepositId);
}
emit LiquidityMigrated(_msgSender(), _id, newDepositId, tokenId);
}
​,Root cause:
ReentrancyFlashloans,20221026,N00d Token,https://web3sec.notion.site/Reentrancy-with-ERC777-8f9c85fb195748c6a8987bc99fa32abb?pvs=25,$29k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/N00d_exp.sol,SolidityCopy// Enter the bar. Pay some SUSHIs. Earn some shares.
function enter(uint256 _amount) public {
uint256 totalSushi = sushi.balanceOf(address(this));
uint256 totalShares = totalSupply();
if (totalShares == 0 || totalSushi == 0) {
_mint(msg.sender, _amount);
} else {
uint256 what = _amount.mul(totalShares).div(totalSushi);
_mint(msg.sender, what);
}
        sushi.transferFrom(msg.sender, address(this), _amount);
}
​,Root cause:
FlashloansPrice Manipulation,20221026,ULME,https://web3sec.notion.site/Price-Manipulation-with-Pre-Approval-BUSD-b1eb08e884ff4eaeb736162749de6b59?pvs=25,$200k,https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/ULME.sol,SolidityCopy​,Root cause:
FlashloansReentrancy,20221024,Market,https://web3sec.notion.site/Read-only-Reentrancy-with-Curve-Oracle-2c9c88c708ed45368e6d84f644174faa?pvs=25,$220k,https://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20221024-market---read-only-reentrancy,SolidityCopy@external
@nonreentrant('lock')
def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS],
                     use_eth: bool = False, receiver: address = msg.sender):
"""
    This withdrawal method is very safe, does no complex math
    """
    lp_token: address = self.token
    total_supply: uint256 = CurveToken(lp_token).totalSupply()
CurveToken(lp_token).burnFrom(msg.sender, _amount)
    balances: uint256[N_COINS] = self.balances
    amount: uint256 = _amount - 1  # Make rounding errors favoring other LPs a tiny bit

    for i in range(N_COINS):
        d_balance: uint256 = balances[i] * amount / total_supply
        assert d_balance >= min_amounts[i]
        self.balances[i] = balances[i] - d_balance
        balances[i] = d_balance  # now it's the amounts going out
        coin: address = self.coins[i]
if use_eth and coin == WETH20:
raw_call(receiver, b"", value=d_balance)
else:
if coin == WETH20:
WETH(WETH20).deposit(value=d_balance)
            response: Bytes[32] = raw_call(
                coin,
_abi_encode(receiver, d_balance, method_id=method_id("transfer(address,uint256)")),
                max_outsize=32,
)
if len(response) != 0:
assert convert(response, bool)

    D: uint256 = self.D
    self.D = D - D * amount / total_supply

    log RemoveLiquidity(msg.sender, balances, total_supply - _amount)
​,Root cause:
