
https://solodit.xyz/issues/trst-h-1-incorrect-implementation-of-getprofitsharinge18-greatly-reduces-lenders-yield-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nProfitSharingModel.getProfitSharingE18() calculates the share of profit that Lender gets\nbased on the APR of the position. According to the formula, the higher the APR, the lower\nthe share of profit the Lender gets, but due to the wrong implementation of the\ngetProfitSharingE18() function, if the APR is smaller than MAX_ANNUALIZED_YEILD, the\nbase share of 25% is returned, actually 25% should be returned when the APR is larger than\nMAX_ANNUALIZED_YEILD.\nConsidering an APR of 5%, Lender's share of the profit should be 77%, while\ngetProfitSharingE18() returns 25%, which greatly reduces Lender's share of the profit."
    ],
    "Recommended Mitigation": [
        "\nModify getProfitSharingE18() as follows"
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe team has fixed it as recommended to make the logic correct"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-2-on-liquidation-if-netpnle36-0-the-premium-paid-by-the-liquidator-is-locked-in-the-contract-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        (\n        netPnLE36,\n             lenderProfitUSDValueE36,\n                 borrowTotalUSDValueE36,\n                     positionOpenUSDValueE36,\n                      sharingProfitTokenAmts ) = calcProfitInfo(_positionManager, _user, _posId);\n        // 2. add liquidation premium to the shared profit amounts\n                            uint lenderLiquidatationPremiumBPS = IConfig(config).lenderLiquidatePremiumBPS();\n                         for (uint i; i < sharingProfitTokenAmts.length; ) {\n                    sharingProfitTokenAmts[i] +=\n                (pos.openTokenInfos[i].borrowAmt * lenderLiquidatationPremiumBPS) / BPS;\n        unchecked {\n        ++i;\n        }\n        }\n",
        "            function _shareProfitsAndRepayAllDebts( address _positionManager, address _posOwner, uint _posId,\n                    int _netPnLE36, uint[] memory _shareProfitAmts, address[] memory _tokens,\n                         OpenTokenInfo[] memory _openTokenInfos\n                              ) internal {\n                    // 0. load states\n            address _lendingProxy = lendingProxy;\n                    // 1. if net pnl is positive, share profits to lending proxy\n                 if (_netPnLE36 > 0) {\n            for (uint i; i < _shareProfitAmts.length; ) {\n                if (_shareProfitAmts[i] > 0) {\n                    ILendingProxy(_lendingProxy).shareProfit(_tokens[i], _shareProfitAmts[i]);\n                 }\n                     unchecked {\n                         ++i;\n                      }\n                  }\n            emit ProfitShared(_posOwner, _posId, _tokens, _shareProfitAmts);\n            }\n",
        "            underlyingAmts = new uint[](underlyingTokens.length);\n                    for (uint i; i < underlyingTokens.length; ) {\n                        underlyingAmts[i] = IERC20(underlyingTokens[i]).balanceOf(address(this));\n                             if (underlyingAmts[i] < _params.minUnderlyingAmts[i]) {\n                                 revert TokenAmountLessThanExpected(\n                         underlyingTokens[i],\n                      underlyingAmts[i],\n                 _params.minUnderlyingAmts[i]\n              );\n            }\n            _doRefund(underlyingTokens[i], underlyingAmts[i]);\n                 unchecked {\n                      ++i;\n                  }\n"
    ],
    "Description": [
        "\nWhen liquidating a position, the liquidator is required to pay premium to Lender, which is\naccumulated in sharingProfitTokenAmts together with Lender's profit and paid to Lender in\n_shareProfitsAndRepayAllDebts()."
    ],
    "netPnLE36 <= 0": [
        "However, if , _shareProfitsAndRepayAllDebts() will not pay any profit to\nLender and the premium in sharingProfitTokenAmts will also not be paid to Lender, which\nmeans that the premium paid by the liquidator will be locked in the contract.",
        "Also, when the position is closed, the tokens in the contract will be sent to the caller, so the\nnext person who closes the position will get the locked tokens."
    ],
    "Recommended Mitigation": [
        "\nModify shareProfitsAndRepayAllDebts() as follows:"
    ],
    "Team Response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe team has fixed it as recommended to make the logic correct."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-3-the-liquidated-person-can-make-the-liquidator-lose-premium-by-adding-collateral-in-advance-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "            uint deltaTime;\n            // 1.1 check the amount of time since position is marked\n            if (pos.startLiqTimestamp > 0) {\n                 deltaTime = Math.max(deltaTime, block.timestamp - pos.startLiqTimestamp);\n            }\n            // 1.2 check the amount of time since position is past the deadline\n             if (block.timestamp > pos.positionDeadline) {\n                    deltaTime = Math.max(deltaTime, block.timestamp - pos.positionDeadline);\n            }\n            // 1.3 cap time-based discount, as configured\n              uint timeDiscountMultiplierE18 = Math.max(\n                IConfig(config).minLiquidateTimeDiscountMultiplierE18(),\n                     ONE_E18 - deltaTime * IConfig(config).liquidateTimeDiscountGrowthRateE18()\n            );\n            // 2. calculate health-based discount factor\n            uint curHealthFactorE18 = (ONE_E18 * ONE_E18) /\n             getPositionDebtRatioE18(_positionManager, _user, _posId);\n                 uint minDesiredHealthFactorE18 = IConfig(config).minDesiredHealthFactorE18s(strategy);\n            // 2.1 interpolate linear health discount factor (according to the diagram in documentation)\n            uint healthDiscountMultiplierE18 = ONE_E18;\n             if (curHealthFactorE18 < ONE_E18) {\n                 healthDiscountMultiplierE18 = curHealthFactorE18 > minDesiredHealthFactorE18\n                     ? ((curHealthFactorE18 - minDesiredHealthFactorE18) * ONE_E18) /\n            (ONE_E18 - minDesiredHealthFactorE18)\n            : 0;\n            }\n            // 3. final liquidation discount = apply the two discount methods together\n            liquidationDiscountMultiplierE18 =\n            (timeDiscountMultiplierE18 * healthDiscountMultiplierE18) /\n            ONE_E18;\n"
    ],
    "Description": [
        "\nWhen the position with debtRatioE18 >= 1e18 or startLiqTimestamp ! = 0, the position can\nbe liquidated. On liquidation, the liquidator needs to pay premium, but the profit is related\nto the position's health factor and deltaTime, and when discount == 0, the liquidator loses\npremium.",
        "Consider the following scenario."
    ],
    "debtRatioE18 >= 1e18": [],
    "Recommended Mitigation": [
        "\nConsider having the liquidated person bear the premium, or at least have the liquidator use\nthe minDiscount parameter to set the minimum acceptable discount."
    ],
    "Team response": [
        "\nLiquidator contracts can easily require the min amount in their own logic to ensure\nprofitability anyways."
    ],
    "maxPayAmount": [
        "Add  parameter as slippage control in the liquidate() and if\nrequiredPayAmount exceeds the value, just revert."
    ],
    "Mitigation Review": [
        "\nThe fix makes liquidators able to use the maxPayAmount parameter to prevent compromise\nin liquidation.\nIn addition, after discussing with the team, there are some external conditions / measures\nthat the team could make, which could lead to a lower severity, but the assigned severity is\nbased on the worst-case scenario."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-4-first-depositor-can-steal-asset-tokens-of-others-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        function _mintInternal(address _receiver, uint _balanceIncreased, uint _totalAsset\n             ) internal returns (uint mintShares) {\n                unfreezeTime[_receiver] = block.timestamp + mintFreezeInterval;\n        if (freezeBuckets.interval > 0) {\n             FreezeBuckets.addToFreezeBuckets(freezeBuckets, _balanceIncreased.toUint96());\n        }\n                 uint _totalSupply = totalSupply();\n                    if (_totalAsset == 0 || _totalSupply == 0) {\n                     mintShares = _balanceIncreased + _totalAsset;\n                 } else {\n             mintShares = (_balanceIncreased * _totalSupply) / _totalAsset;\n             }\n            if (mintShares == 0) {\n        revert ZeroAmount();\n        }\n        _mint(_receiver, mintShares);\n        }\n"
    ],
    "Description": [
        "\nThe first depositor can be front run by an attacker and as a result will lose a considerable\npart of the assets provided.\nWhen the pool has no share supply, in _mintInternal(), the amount of shares to be minted is\nequal to the assets provided. An attacker can abuse of this situation and profit of the\nrounding down operation when calculating the amount of shares if the supply is non-zero.",
        "Consider the following scenario."
    ],
    "_totalAsset = 1M * 1e6 + 1": [],
    "Recommended Mitigation": [
        "\nWhen _totalSupply == 0, send the first min liquidity LP tokens to the zero address to enable\nshare dilution\nAnother option is to use the ERC4626 implementation(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC4626.sol#L199C14-L208) from OZ."
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation Review": [
        "\nThe team increased the interest-bearing token decimal by 18 to prevent attackers from\nmanipulating the share price by precision loss, and made themself the first depositor to\nprevent potential attacks."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-5-the-attacker-can-use-larger-dust-when-opening-a-position-to-perform-griefing-attacks-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "            uint inputTotalUSDValueE36;\n                for (uint i; i < openTokenInfos.length; ) {\n                 inputTotalUSDValueE36 += openTokenInfos[i].inputAmt * tokenPriceE36s[i];\n                      borrowTotalUSDValueE36 += openTokenInfos[i].borrowAmt * tokenPriceE36s[i];\n                 unchecked {\n            ++i;\n                }\n            }\n                // 1.3 calculate net pnl (including strategy users & borrow profit)\n            positionOpenUSDValueE36 = inputTotalUSDValueE36 + borrowTotalUSDValueE36;\n            netPnLE36 = positionCurUSDValueE36.toInt256() - positionOpenUSDValueE36.toInt256();\n",
        "            minLpUSDValueE36 = ((inputUSDValueE36 + borrowUSDValueE36) *\n               IConfig(_config).posMinLpSlippageMultiplierE18s(strategy)) / ONE_E18;\n            // 4. get min & max borrow value cap\n            (minBorrowUSDValueE18, maxBorrowUSDValueE18) = \n                 IConfig(_config).getMinMaxCapBorrowUSDValueE18( strategy);\n            }\n                    return\n                        lpUSDValueE36 >= minLpUSDValueE36 &&\n"
    ],
    "Description": [
        "\nWhen opening a position, unused assets are sent to dustVault as dust, but since these dust\nare not subtracted from inputAmt, they are included in the calculation of\npositionOpenUSDValueE36, resulting in a small netPnLE36, which can be used by an\nattacker to perform a griefing attack."
    ],
    "posMinLpSlippageMultiplierE18s = 0.95e18": [
        "Consider ETH:USDC = 1:1000, "
    ],
    "dustVault": [],
    "calcProfitInfo": [],
    "Recommended Mitigation": [
        "\nConsider subtracting dust from inputAmt when opening a position."
    ],
    "Team response": [
        "\nAcknowledged, the attacker is not profitable, where the dust vault can later be used to\ndistribute to lenders afterwards if needs be."
    ],
    "Mitigation Review": [
        "\nIt would be a good practice to distribute the dust to Lender, which can prevent Lender from\nbeing compromised by Griefing attacks."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-6-an-attacker-can-increase-liquidity-to-the-positions-uniswapnft-to-prevent-the-position-from-being-closed-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "            function increaseLiquidity(IncreaseLiquidityParams calldata params)\n                 external payable override checkDeadline(params.deadline)\n                    returns (\n                     uint128 liquidity, uint256 amount0, uint256 amount1)\n            {\n            Position storage position = _positions[params.tokenId];\n                PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];\n                    IUniswapV3Pool pool;\n                        (liquidity, amount0, amount1, pool) = addLiquidity(\n",
        "             function _redeemPosition(\n                    address _user, uint _posId\n                     ) internal override returns (address[] memory rewardTokens, uint[] memory rewardAmts) {\n                        address _positionManager = positionManager;\n                    uint128 collAmt = IUniswapV3PositionManager(_positionManager).getPositionCollAmt(_user, \n                    _posId);\n                    // 1. take lp & extra coll tokens from lending proxy\n                    _takeAllCollTokens(_positionManager, _user, _posId, address(this));\n                         UniV3ExtraPosInfo memory extraPosInfo = IUniswapV3PositionManager(_positionManager)\n                             .getDecodedExtraPosInfo(_user, _posId);\n                        address _uniswapV3NPM = uniswapV3NPM; // gas saving\n                    // 2. remove underlying tokens from lp (internal remove in NPM)\n                    IUniswapV3NPM(_uniswapV3NPM).decreaseLiquidity(\n                        IUniswapV3NPM.DecreaseLiquidityParams({\n                            tokenId: extraPosInfo.uniV3PositionId,liquidity: collAmt, amount0Min: 0,\n                    amount1Min: 0,\n                         deadline: block.timestamp\n                    })\n                    );\n                    ...\n                    // 4. burn LP position\n                          IUniswapV3NPM(_uniswapV3NPM).burn(extraPosInfo.uniV3PositionId);\n                      }\n",
        "        function burn(uint256 tokenId) external payable override isAuthorizedForToken(tokenId) {\n            Position storage position = _positions[tokenId];\n                require(position.liquidity == 0 && position.tokensOwed0 == 0 && position.tokensOwed1 == 0,'Not cleared');\n             delete _positions[tokenId];\n        _burn(tokenId);\n        }\n"
    ],
    "Description": [
        "\nUniswapV3NPM allows the user to increase liquidity to any NFT.",
        "When closing a position, in _redeemPosition(), only the initial liquidity of the NFT will be\ndecreased, and then the NFT will be burned.",
        "If the liquidity of the NFT is not 0, burning will fail.",
        "This allows an attacker to add 1 wei liquidity to the position's NFT to prevent the position from\nbeing closed, and later when the position expires, the attacker can liquidate it."
    ],
    "Recommended Mitigation": [
        "\nConsider decreasing the actual liquidity(using uniswapV3NPM.positions to get it) of the NFT\nin _redeemPosition(), instead of the initial liquidity"
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation Review": [
        "\nThe team addressed this issue by decreasing NFT's latest liquidity in _redeemPosition()"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-7-pending-position-fees-miscalculation-may-result-in-increased-pnl-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nWhen calculating pending liquidity position fees, liquidity, tokensOwed0, and tokensOwed1\nare read from a Uniswap V3 pool using a position belonging to the\nNonfungiblePositionManager contract. However, the read values will also include the liquidity\nand the owed token amounts of all Uniswap V3 users who deposited funds in the price range\nof the position via the NonfungiblePositionManager contract. Since\nNonfungiblePositionManager manages positions in pools on behalf of users, the positions will\nhold liquidity of all NonfungiblePositionManager users. As a result, the PnL of\nUniswapV3Strategy positions may be significantly increased, resulting in increased payouts to\nlenders and loss of funds to borrowers/liquidators."
    ],
    "Recommended Mitigation": [
        "\nConsider reading the values of liquidity, tokensOwed0, and tokensOwed1 from the\nIUniswapV3NPM(uniV3NPM).positions() call on line 95. The call returns values specifically for\nthe position identified by the token ID."
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation Review": [
        "\nThe team has fixed it as recommended to make the logic correct."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-8-exact-output-swaps-cannot-be-executed-blocking-repayment-of-debt-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nWhen performing \u201cexact output\u201d swaps via Uniswap V2 and V3, the maximum input amount\nargument (amountInMax when calling Uniswap V2\u2019s swapTokensForExactTokens(),\namountInMaximum when calling V3\u2019s exactOutput()) is set to 0. As a result, swapping\nattempts will always revert because no more than 0 input tokens can be sold (the slippage\ncheck in the Uniswap contracts will always revert because the swaps will require more input\ntokens).\nWe consider it high-severity because an \u201cexact output\u201d swap is mandatory when closing a\nposition that doesn\u2019t have enough tokens to repay(https://github.com/AlphaFinanceLab/stella-arbitrum-private-contract/blob/3a4e99307e9cbf790279e49a4d90771e5486c51d/contracts/stella-strategies/strategies/base/BaseStrategy.sol#L224) the borrowed amount. Thus, since \u201cexact\noutput\u201d swaps are not possible, closing some positions won\u2019t be possible as well, leaving funds\nlocked in the contract."
    ],
    "Recommended Mitigation": [
        "\nTaking into account that the protocol implements delayed slippage checks, consider setting\nthe maximum input amount arguments to type(uint256).max."
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation Review": [
        "\nThe team has fixed it as recommended to make the logic correct."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-1-markliquidationstatus-may-cause-the-liquidator-to-lose-premium-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nWhen the debtRatioE18 of a position is greater than 1 and less than 1.03 (unmark), the\nliquidator can call markLiquidationStatus() to accumulate timeDiscountMultiplierE18 by\nmaking pos.startLiqTimestamp == block.timestamp. The liquidated person can also call\nmarkLiquidationStatus() to reset pos.startLiqTimestamp to clear\ntimeDiscountMultiplierE18, which results in that when the debtRatioE18 of a position\nhovers between 1.0 and 1.03, the liquidated person can front run the liquidator to make the\nliquidator lose premium.",
        "Consider the following scenarios:"
    ],
    "debtRatioE18": [],
    "Recommended Mitigation": [
        "\nConsider allowing markLiquidationStatus() to set the startLiqTimestamp only when\ndebtRatioE18 >= 1.03(unmark), or allowing the liquidator to set the minimum acceptable\ndiscount."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe team addressed this issue by changing the unmark value to ~0.97."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-2-swaphelpergetcalldata-should-check-whitelistedrouters_router-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        for (uint i; i < _statuses.length; ) {\n             whitelistedRouters[_routers[i]] = _statuses[i];\n                 if (_statuses[i]) {\n                 routerTypes[_routers[i]] = _types[i];\n        emit SetRouterType(_routers[i], _types[i]);\n        }\n              emit SetWhitelistedRouter(_routers[i], _statuses[i]);\n           unchecked {\n        ++i;\n        }\n        }\n"
    ],
    "Description": [
        "\nSwapHelper.getCalldata() returns data for swap based on the input, and uses\nwhitelistedRouters to limit the _router param. The issue here is that when\nsetWhitelistedRouters() sets the _routers state to false, it does not reset the data in\nrouterTypes and swapInfos, which results in the router still being available in getCalldata().\nAs a result, users can still swap with invalid router data."
    ],
    "Recommended Mitigation": [
        "\nConsider checking whitelistedRouters[_router] in SwapHelper.getCalldata()"
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation Review": [
        "\nThe team addressed this issue by setting routerTypes to UNSET status in whitelist function\nwhen delisting."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-3-no-check-for-active-arbitrum-sequencer-in-chainlink-oracle-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nIf the Arbitrum sequencer were to go offline the Chainlink oracle may return an invalid/stale\nprice. It should always be checked before consuming any data from Chainlink.",
        "The Chainlink docs(https://docs.chain.link/data-feeds/l2-sequencer-feeds) on L2 Sequencer Uptime Feeds specify more details."
    ],
    "Recommended Mitigation": [
        "\nCheck sequencer uptime before consuming any price data."
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation Review": [
        "\nThe team addressed this issue by checking sequencer uptime before consuming any price\ndata."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-4-the-swap-when-closing-a-position-does-not-consider-shareprofitamts-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        for (uint i; i < swapParams.length; ) {\n        // find excess amount after repay\n        uint swapAmt = swapParams[i].operation == SwapOperation.EXACT_IN\n          ? IERC20(swapParams[i].tokenIn).balanceOf(address(this)) - openTokenInfos[i].borrowAmt\n             : openTokenInfos[i].borrowAmt - IERC20(swapParams[i].tokenOut).balanceOf(address(this));\n                 swapAmt = (swapAmt * swapParams[i].percentSwapE18) / ONE_E18\n                 if (swapAmt == 0) {\n              revert SwapZeroAmount();\n             }\n"
    ],
    "Description": [
        "\nWhen closing a position, token swap is performed to ensure that the closer can repay the\ndebt, for example, when operation == EXACT_IN, tokens of borrowAmt are required to be\nexcluded from the swap, and when operation == EXACT_OUT, tokens of borrowAmt are\nrequired to be swapped. The issue here is that the closer needs to pay not only the borrowAmt\nbut also the shareProfitAmts, which causes the closure to fail when percentSwapE18 = 100%\ndue to insufficient tokens. Although the closer can adjust the percentSwapE18 to make the\nclosure successful, it greatly increases the complexity."
    ],
    "Recommended Mitigation": [
        "\nConsider taking shareProfitAmts into account when calculating swapAmt"
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe team has fixed it as recommended to make the logic correct."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-5-freezing-of-repaid-debts-can-cause-dos-when-borrowing-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nWhen a debt is repaid, the repaid amount gets frozen via\nfreezeBuckets.addToFreezeBuckets(). In most scenarios, the repaid amount won\u2019t be frozen\nby the mint freezing mechanism since the amount of time that has passed since the borrowed\nand repaid amount was deposited will almost always be greater than mintFreezeInterval\n(which is expected to be 1 day). Thus, a lender can withdraw a repaid amount while it\u2019s frozen\nin FreezeBuckets. This can cause a miscalculation of borrowable funds in the\nBaseLendingPool.getBorrowableAmount() function: in the worst case scenario,\nfreezeBuckets.getLockedAmount() can return a value that\u2019s bigger (it\u2019ll include the repaid\namount) than the current balance of the pool (the repaid amount will be withdrawn), which\nwill case a revert and block borrowing."
    ],
    "Recommended Mitigation": [
        "\nConsider not freezing repaid funds."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe team addressed this issue by changing the algorithm (unlocking the same amount from\nthe buckets when the user made withdrawals)."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-6-pending-fees-calculations-dont-allow-overflowingunderflowing-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nWhen computing pending fees in the UniswapV3PositionViewer.\n_computePendingFeesToBeEarned() function, the calculations of feeGrowthBelowX128,\nfeeGrowthAboveX128, and feeGrowthInsideX128 don\u2019t allow under- and overflowing.\nHowever, the respective calculations in Uniswap V3 are designed to underflow and overflow\n(for more information, refer to https://github.com/Uniswap/v3-core/issues/573 issue and this https://github.com/Jeiwan/uniswapv3-book/issues/45). As a result, executing\n_computePendingFeesToBeEarned() can revert in some situations, causing transaction\nreverts."
    ],
    "Recommended Mitigation": [
        "\nIn the _computePendingFeesToBeEarned() function, consider wrapping the fee growth\ncalculations in unchecked. This is what Uniswap does in the 0.8 branch(https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/Tick.sol#L69-L97)."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe team addressed this issue by wrapping the fee growth calculations in unchecked in\n_computePendingFeesToBeEarned()."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-7-changing-liquidation-vault-or-token-makes-liquidations-impossible-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nWhen UniswapV3Strategy is initialized, it approves spending of the liquidation token to the\nliquidation vault. The addresses of the vault and the token are read from the Config contract,\nwhich allows the \u201cexec\u201d role to change them. However, after liquidation vault or token is\nchanged, token spending is not re-approved. As a result, liquidations will always revert\nbecause the new vault won\u2019t be able to take liquidation tokens from the strategy contract (or\nthe old vault won\u2019t be able to take the new liquidation token, if the token was changed)."
    ],
    "Recommended Mitigation": [
        "\nStrategy contracts need a (restricted) way to approve arbitrary tokens to arbitrary addresses.\nBaseStrategy.approve() allows that, but it only approves to whitelisted routers. Thus, our\nrecommendation is to allow any spender address in the BaseStrategy.approve() function."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe team addressed this issue by extending target approval to either liquidation vault or\nrouter in BaseStrategy.approve()"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-8-the-freeze-mechanism-reduces-the-borrowableamount-which-reduces-lenders-yield-trust-security-none-stella-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        function _mintInternal(address _receiver,uint _balanceIncreased, uint _totalAsset\n          ) internal returns (uint mintShares) {\n             unfreezeTime[_receiver] = block.timestamp + mintFreezeInterval;\n          if (freezeBuckets.interval > 0) {\n         FreezeBuckets.addToFreezeBuckets(freezeBuckets, _balanceIncreased.toUint96());\n        }\n"
    ],
    "Description": [
        "\nThe contract has two freeze intervals, mintFreezeInterval and freezeBuckets.interval, the\nformer to prevent users from making flash accesses and the latter to prevent borrowers\nfrom running out of funds.\nBoth freeze intervals are applied when a user deposits, and due to the difference in\nunlocking time, it significantly reduces borrowableAmount and thus reduces Lender's yield."
    ],
    "freezeBuckets.interval == mintFreezeInterval = 1 day": [
        "Consider , 100 ETH in the LendingPool,\nand borrowableAmount = 100 ETH.\nAt day 0 + 1s, Alice deposits 50 ETH, borrowableAmount = 150 ETH**-** lockedAmount(50 ETH)\n= 100 ETH, the 50 ETH frozen in freezeBuckets will be unlocked on day 2, while\nunfreezeTime[alice] = day 1 + 1s.\nAt day 1 + 1s, unfreezeTime[Alice] is reached, Alice can withdraw 50 ETH,\nborrowableAmount = 100 ETH - LockedAmount(50 ETH) = 50 ETH.\nIf Bob wants to borrow the available funds in the Pool at this time, Bob can only borrow 50\nETH, while the available funds are actually 100 ETH, which will reduce Lender's yield by half.\nAt day 2 + 1s, freezeBuckets is unfrozen and borrowableAmount = 100 ETH -LockedAmount(0 ETH) = 100 ETH."
    ],
    "Recommended Mitigation": [
        "\nConsider making mintFreezeInterval >= 2 * freezeBuckets.interval, which makes\nunfreezeTime greater than the unfreeze time of freezeBuckets."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe team addressed this issue by changing the algorithm (unlocking the same amount from\nthe buckets when the user made withdrawals)."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-1-a-malicious-operator-can-drain-the-vault-funds-in-one-transaction-trust-security-none-orbital-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "         struct tradeInput { \n             address spendToken;\n               address receiveToken;\n                 uint256 spendAmt;\n                   uint256 receiveAmtMin;\n                address routerAddress;\n         uint256 pathIndex;\n         }\n",
        "               (,int priceFromInt,,,) = AIFrom.latestRoundData();\n         (,int priceToInt,,,) = AITo.latestRoundData();\n"
    ],
    "Description": [
        "\nThe vault operator can swap tokens using the trade() function. They pass the following\nstructure for each trade:"
    ],
    "receiveAmtMin": [
        "Notably,  is used to guarantee acceptable slippage. An operator can simply\npass 0 to make sure the trade is executed. This allows an operator to steal all the funds in the\nvault by architecting a sandwich attack."
    ],
    "Recommended Mitigation": [
        "\nThe contract should enforce sensible slippage parameters."
    ],
    "Team response": [
        "\n\"Added Chainlink Interface to allow for off-chain price knowledge, in a new contract,\nChainlinkInterface.sol, which is deployed by the VaultManager at deploy time, and ownership\nis given to the protocol owner. This contract has an \"addPriceFeed\" function, on per token\nbasis. All feeds are assumed to be in USD units. Then, the function \"getMinReceived\", performs\nthe needed math to get the min expected back from a trade. This function is called by the\nVaultManager at trade time, which then checks against the caller's minReceived input.\nAdditionally, a slippage for a given pair is now get and set by the AuxInfo.sol contract."
    ],
    "Mitigation review": [
        "\nThe integration with Chainlink oracle introduces new issues. There is no check for a stale price\nfeed, which makes trading possibly incur high slippage costs.",
        "Additionally, when the contracts are deployed on L2, there is a sequencer down-time issue,\nas detailed here(https://docs.chain.link/data-feeds/l2-sequencer-feeds). The contract should check the sequencer is up when deployed on L2."
    ],
    "Team Response": [
        "\n\"Stale price feed check added ChainlinkInterface.sol, \"getMinReceived\" function, lines 90 - 94.\nSequencer uptime check added to \"getMinReceived\" function, line 76.\""
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-2-a-malicious-operator-can-steal-all-user-deposits-trust-security-none-orbital-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "         if (D == 0) { //initial deposit\n                   uint256 sumDenoms = 0; \n                        for (uint256 i = 0; i < tkns.length; i++) {\n                              sumDenoms += \n                        AI.getAllowedTokenInfo(tkns[i]).initialDenominator;\n                      }\n                   require(sumDenoms > 0 && sumDenoms <= maxInitialDenominator, \n         \"invalid sumDenoms\");\n                   deltaN = sumDenoms; //initial numerator and denominator are the \n                same, and are greater than any possible balance in the vault.\n             //this ensures precision in the vault's \n         balances. User Balance = (N*T)/D will have rounding errors always 1 \n         wei or less. \n         } else { \n            // deltaN = (amt * D)/T;\n            deltaN = Arithmetic.overflowResistantFraction(amt, D, T);\n         }\n"
    ],
    "Description": [
        "\nIn the Orbital architecture, each Vault user has a numerator which represents their share of\nthe vault holdings. The denominator is by design the sum of all numerators of users, an\ninvariant kept at deposits and withdrawals. For maximum precision, the denominator should\nbe a very large value. Intuitively, numerators could be spread across different users without\nlosing precision. The critical calculations occur in these lines in deposit():"
    ],
    "initialDenominators": [
        "In the initial deposit, Vault sums all token  to get the final denominator.\nIt is assumed that the vault will never have this amount in total balances (each token\ndenominator is worth around $100m dollars)."
    ],
    "deltaN": [
        "In any other deposit, the  (numerator) credited to the depositor is (denominator *\ndeposit amount / existing balance). When denominator is huge, this calculation is highly precise. However, when denominator is 1, a serious issue oc**curs. If user's deposit amount is\none wei smaller than existing balance,  would be zero. This property has lead to the\nwell-known ERC4626 inflation attack, where an attacker donates (sends directly to the\ncontract) an amount so that the following deposit is consumed without any shares given to\nthe user. In fact, it is possible to reduce the denominator to 1 and resurrect that attack. The\nroot cause is that the initial deposit denominator is not linear to the deposit amount. Consider\nthe attack flow below, done by a malicious operator:"
    ],
    "Recommended Mitigation": [
        "\nConsider checking that user's received deltaN is reasonable. Calculate the expected\nwithdrawable value (deltaN / denominator * balance), and verify that is close enough to the\ndeposited amount."
    ],
    "Team Response": [
        "\n\"Integration Testing revealed that the ERC204626 arithmetic loses precision when a low\nprecision token is traded for a higher precision token (USDC to WETH, for example). The math\nis not as simple as it appears at first and doing a proper error analysis might reveal a way to\ncorrect the problem. However, we've opted to revert back to the more straightforward\napproach where the Denominator starts at 0 and is kept equal to the sum of Numerators. In\norder to prevent the original attack described by Trust, the intial denominator starts extremely high: 2**128 - 1, and, the Vault works with \"Tracked Balances\" instead of the real balances.\nThe tracked balances are set to the true balances under these circumstances: Trade events,\nDepsoit events if the msg.sender is the Vault Operator, and Withdraw Events if the msg.sender\nis the Operator, or if the withdrawal is the final withdrawal. This method is designed to ward\noff Donation Attacks and Denial Of Service Attacks because Donations can have no affect on\nthe Vault behavior.\""
    ],
    "Mitigation review": [
        "\nThe new ERC4626 logic is sound. The denominator cannot ever be below initD, therefore it is\nimpossible to make a victim deposit lose precision, assuming it is not an abnormally massive\ndeposit."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-1-removing-a-trade-path-in-router-will-cause-serious-data-corruption-trust-security-none-orbital-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "         mapping(address => mapping(address => listInfo)) private allowedPairsMap;\n                  pair[] private allowedPairsList;\n",
        "          struct listInfo {\n               bool allowed;\n                uint256 listPosition;\n         }\n         struct pair {\n            address token0;\n               address token1;\n                  uint256 numPathsAllowed;\n          }\n",
        "               function _increasePairPaths(address token0, address token1) private {\n                     listInfo storage LI = allowedPairsMap[token0][token1];\n                  if (!LI.allowed){\n                  LI.allowed = true;\n                  LI.listPosition = allowedPairsList.length;\n                      allowedPairsList.push(pair(token0, token1, 0));\n                   }\n                      allowedPairsList[LI.listPosition].numPathsAllowed++;\n                   }\n",
        "      function _decreasePairPaths(address token0, address token1) private {\n             listInfo storage LI = allowedPairsMap[token0][token1];\n                require(LI.allowed, \"RouterInfo: pair not allowed\");\n                   allowedPairsList[LI.listPosition].numPathsAllowed--;\n            if (allowedPairsList[LI.listPosition].numPathsAllowed == 0){\n         allowedPairsList[LI.listPosition] = \n      allowedPairsList[allowedPairsList.length - 1];\n         allowedPairsList.pop();\n         LI.allowed = false;\n      }\n      }\n"
    ],
    "Description": [
        "\nThe RouterInfo represents a single UniV3-compatible router which supports a list of token\npaths. It uses the following data structures:"
    ],
    "token0": [
        "When an admin specifies a new path from  to token1, _increasePairPaths() is called.",
        "When a path is removed, the complementary function is called."
    ],
    "listInfo": [
        "When the last path is removed, the contract reuses the index of the removed pair, to store\nthe last pair in the list. It then removes the last pair, having already copied it. The issue is that\nthe corresponding  structure is not updated, to keep track of index in the pairs list.\nFuture usage of the last pair will use a wrong index, which at this moment, is over the array\nbounds. When a new pair will be created, it will share the index with the corrupted pair. This\ncan cause a variety of serious issues. For example, it will not be possible to remove paths from\nthe corrupted pair until a new pair is created, at which point the new pair will have a wrong\nnumPathsAllowed as it is shared."
    ],
    "Recommended Mitigation": [
        "\nUpdate the listPosition member of the last pair in the list, before repositioning it."
    ],
    "Team Response": [
        "\n\"Added 'lastPair' variable, which is used to point what was the last pair, to the new location in\nthe list.\""
    ],
    "Mitigation review": [
        "\nThe fix is simple and correct."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-2-attacker-can-dos-deposit-transactions-due-to-strict-verifications-trust-security-none-orbital-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "      uint256[] memory balances = vlt.balances();\n          //ensure deposits are in the same ratios as the vault's current balances\n          require(functions.ratiosMatch(balances, amts), \"ratios don't match\");\n",
        "         for (uint256 i = 0; i < sourceRatios.length; i++) {\n         // if (targetRatios[i] != (targetRatios[greatestIndex] * \n                  sourceRatios[i]) / greatest) {\n               if (targetRatios[i] != \n         Arithmetic.overflowResistantFraction(targetRatios[greatestIndex], sourceRatios[i], greatest)) {\n         return false;\n            }\n         }\n"
    ],
    "Description": [
        "\nWhen users deposit funds to the Vault, it verifies that the proportion between the tokens\ninserted to the vault matches the current vault token balances.",
        "The essential part of the check is below:"
    ],
    "targetRatios": [
        "The exact logic here is not important, but note that a small change in the balance of one of\nthe vault tokens will affect the expected number of tokens that need to be inserted to\nmaintain correct ratio. The exact amounts to be deposited are passed as , and\nsourceRatios is the current balances. Therefore, an attacker can directly transfer a negligible\namount of some vault token to the contract to make the amount the user specified in\n not line up with the expected proportion. As a result, the deposit would revert.\nEssentially it is an abuse of the over-granular verification of ratios, leading to a DOS of any\ndeposit in the mempool."
    ],
    "Recommended Mitigation": [
        "\nLoosen the restriction on deposit ratios. A DOS attack should cost an amount that the vault\ncreditors would be happy to live with."
    ],
    "Team Response": [
        "\n\"Added a new function to the VaultV2 contract, \"takeBalanceSnapshot\", which stores the state\nof the vault balances in a new variable. This function is called at the end of every \"official\"\nbalance state change (Deposit, Withdraw, and Trade in the VaultManager). The ratios are\nchecked against this new list instead of the actual balances.\""
    ],
    "Mitigation review": [
        "\nThe fix does not eliminate the described issue. An attacker can simply donate followed by\ndeposit() of a negligible amount, in order to make takeBalancesSnapshot() get called. The new\nratio will make the deposit getting front-ran revert."
    ],
    "Team response": [
        "\n\"See TRST-H-2 for solution.\""
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-3-user-deposits-can-fail-despite-using-the-correct-method-for-calculation-of-deposit-amounts-trust-security-none-orbital-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "         for (uint256 i = 0; i < balances.length; i++) {\n               if (i == indexOfReferenceToken) {\n                amtsNeeded[i] = amtIn;\n         } else {\n         // amtsNeeded[i] = (amtIn * balances[i]) / \n                  balances[indexOfReferenceToken];\n                     amtsNeeded[i] = Arithmetic.overflowResistantFraction(amtIn, \n                  balances[i], balances[indexOfReferenceToken]);\n               }\n            }\n"
    ],
    "Description": [
        "\nUsers can use the getAmtsNeededForDeposit() function to get the amount of tokens that\nmaintain the desired proportion for vault deposits. It will perform a calculation very similar to\nthe one in ratiosMatch(), which will verify the deposit.",
        "However, a difference between the verification function and the getter function is that the\ngetter receives any reference token, while the verification will use proportions based on the\ndeposit amount in the largest balance in the vault. Indeed, these fractions may differ by a\nsmall amount. This could cause the getAmtsNeededForDeposit() function to respond with\nvalues which will not be accepted at deposit, since they will be rounded differently."
    ],
    "Recommended Mitigation": [
        "\nCalculation amounts needed using the ratio between largest balance and the deposit amount.\nThis would line up the numbers as verification would expect."
    ],
    "Team Response": [
        "\n\"Reworked the functions.getAmtsNeededForDeposit method so that ratios are based on the\ngreatest amt instead of the reference token. The \"amtIn\" of the reference token is rounded\ndown, if needed.\""
    ],
    "Mitigation review": [
        "\nFix is sound."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-4-deposits-of-fee-on-transfer-tokens-will-favor-later-depositors-making-earlier-investors-lose-funds-trust-security-none-orbital-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "         uint256 T = vlt.virtualTotalBalance(); //will be at least 1\n         uint256 D = vlt.D();\n         if (functions.willOverflowWhenMultiplied(amt, D)) {\n            require(T > amt || T > D, \"overflow\");\n         }\n         deltaN = Arithmetic.overflowResistantFraction(amt, D, T);\n             vlt.setN(msg.sender, vlt.N(msg.sender) + deltaN);\n                  vlt.setD(D + deltaN); //D always kept = sum of all Ns, plus \n                    vlt.initD()\n         for (uint256 i = 0; i < tkns.length; i++) {\n            if (amts[i] > 0) {\n         IERC20(tkns[i]).safeTransferFrom(msg.sender, vaultAddress, amts[i]);\n            }\n         }\n"
    ],
    "Description": [
        "\nWhen deposits are processed, the percentage of Denominator minted to the depositor is\nlinear to the contribution, compared to the current balance.",
        "The calculation will lead to incorrect results when using fee-on-transfer (tax) tokens. The\n\"before-tax\" amount of the depositor will be compared to the \"after-tax\" amount in the\ncontract balance. It is exploitable by immediately withdrawing the shares, receiving more\ntokens than the amount contributed (unless fees are higher than the token tax)."
    ],
    "Recommended mitigation": [
        "\nCompare the balance before and after the safeTransferFrom() call."
    ],
    "Team response": [
        "\n\"amt now calculated by comparing vault balances before and after safeTransferFrom. N and\nD updated afterwards. \""
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-1-an-attacker-can-drain-mozaic-vaults-by-manipulating-the-lp-price-trust-security-none-mozaic-archimedes-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nThe controller is tasked with synchronizing LP token price across all chains. It implements a\nlifecycle. An admin initiates the snapshot phase, where Controller requests all Vaults to report\nthe total stable ($) value and LP token supply. Once all reports are in, admin calls the settle\nfunction which dispatches the aggregated value and supply to all vaults. At this point, vaults\nprocess all deposits and withdrawals requested up to the last snapshot, using the universal\nvalue/supply ratio.\nThe described pipeline falls victim to an economic attack, stemming from the fact that LP\ntokens are LayerZero OFT tokens which can be bridged. An attacker can use this property to\nbypass counting of their LP tokens across all chains. When the controller would receive a\nreport with correct stable value and artificially low LP supply, it would cause queued LP\nwithdrawals to receive incorrectly high dollar value.\nTo make vaults miscalculate, attacker can wait for Controller to initiate snapshotting. At that\nmoment, they can start bridging a large amount of tokens. They may specify custom LayerZero\nadapter params to pay a miniscule gas fee, which will guarantee that the bridge-in transaction\nwill fail due to out-of-gas. At this point, they simply wait until all chains have been\nsnapshotted, and then finish bridging-in with a valid gas amount. Finally, Controller will order\nvaults to settle, at which point the attacker converts their LP tokens at an artificially high price.\nAnother clever way to exploit this flaw is to count LP tokens multiple times, by quickly\ntransporting them to additional chains just before those chains are snapshotted. This way, the\nLP tokens would be diluted and the attacker can get a disproportionate amount of LP tokens\nfor their stables."
    ],
    "Recommended Mitigation": [
        "\nThe easy but limiting solution is to reduce complexity and disable LP token bridging across\nnetworks. The other option is to increase complexity and track incoming/outgoing bridge\nrequests in the LP token contract. When snapshotting, cross reference the requested\nsnapshot time with the bridging history."
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation Review": [
        "\nMozaic's response is to disable LP token bridging altogether. As this is a configuration-level\nfix, users are encouraged to confirm the tokens are not linked via bridges at runtime."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-10-mozbridge-underestimates-gas-for-sending-of-moz-messages-trust-security-none-mozaic-archimedes-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        function quoteLayerZeroFee(uint16 _chainId, uint16 _msgType, LzTxObj memory _lzTxParams) public view returns (uint256 _nativeFee, uint256 _zroFee) { \n             bytes memory payload = \"\";\n        if (_msgType == TYPE_REPORT_SNAPSHOT) {\n                payload = abi.encode(TYPE_REPORT_SNAPSHOT);\n        }\n        else if (_msgType == TYPE_REQUEST_SNAPSHOT) {\n                     payload = abi.encode(TYPE_REQUEST_SNAPSHOT);\n        }\n        else if (_msgType == TYPE_SWAP_REMOTE) {\n                        payload = abi.encode(TYPE_SWAP_REMOTE);\n        }\n        else if (_msgType == TYPE_STAKE_ASSETS) {\n                          payload = abi.encode(TYPE_STAKE_ASSETS);\n        }   \n        else if (_msgType == TYPE_UNSTAKE_ASSETS) {\n                                 payload = abi.encode(TYPE_UNSTAKE_ASSETS);\n        }\n        else if (_msgType == TYPE_REPORT_SETTLE) {\n                                 payload = abi.encode(TYPE_REPORT_SETTLE);\n        }\n        else if (_msgType == TYPE_REQUEST_SETTLE) {\n                            payload = abi.encode(TYPE_REQUEST_SETTLE);\n        }\n        else {\n                         revert(\"MozBridge: unsupported function type\");\n        }\n        \n                     bytes memory _adapterParams = _txParamBuilder(_chainId, _msgType, _lzTxParams);\n              return layerZeroEndpoint.estimateFees(_chainId, address(this), \n       payload, useLayerZeroToken, _adapterParams);\n        }\n",
        "           struct Snapshot {\n              uint256 depositRequestAmount;\n                uint256 withdrawRequestAmountMLP;\n                    uint256 totalStablecoin;\n                        uint256 totalMozaicLp; // Mozaic \"LP\"\n                            uint8[] pluginIds;\n                                address[] rewardTokens;\n                                 uint256[] amounts;\n                  }\n"
    ],
    "Description": [
        "\nThe bridge calculates LayerZero fees for sending Mozaic messages using the function below:"
    ],
    "Snapshot": [
        "The issue is that the actual payload used for Mozaic messages is longer than the one calculated\nabove. For example, REPORT_SNAPSHOT messages include a  structure.",
        "Undercalculation of gas fees will cause insufficient gas to be sent to the bridge, reverting the\nsend() transaction."
    ],
    "Recommended mitigation": [
        "\nError on the side of caution and estimate a larger than expected fee."
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation review": [
        "\nThe code now uses the correct payload for estimating fees."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-9-vault-does-not-have-a-way-to-withdraw-native-tokens-trust-security-none-mozaic-archimedes-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        /// @notice Report snapshot of the vault to the controller.\n        function reportSnapshot() public onlyBridge {\n                 MozBridge.Snapshot memory _snapshot = _takeSnapshot();\n             MozBridge(mozBridge).reportSnapshot(_snapshot, \n          payable(address(this)));\n        }\n",
        "        function withdraw() public {\n        // get the amount of Ether stored in this contract\n            uint amount = address(this).balance;\n        // send all Ether to owner\n        // Owner can receive Ether since the address of owner is payable\n            (bool success, ) = treasury.call{value: amount}(\"\");\n                 require(success, \"Controller: Failed to send Ether\");\n         }\n"
    ],
    "Description": [
        "\nThe Vault sets the LayerZero fee refund address to itself:",
        "However, there is no function to withdraw those funds, making them forever stuck in the vault\nonly available for paying for future transactions."
    ],
    "Recommended mitigation": [
        "\nAdd a native token withdrawal function."
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation review": [
        "\nThe fix includes a new withdraw() function. Its intention is to vacate any ETH stored in the\ncontroller and vaults.",
        "In fact, attackers can simply call withdraw() to make messaging fail due to lack of native\ntokens. This could be repeated in every block to make the system unusable."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-2-attacker-can-freeze-deposits-and-withdrawals-indefinitely-by-submitting-a-bad-withdrawal-trust-security-none-mozaic-archimedes-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        function addWithdrawRequest(uint256 _amountMLP, address _token) external {\n            require(isAcceptingToken(_token), \"ERROR: Invalid token\");\n                require(_amountMLP != 0, \"ERROR: Invalid amount\");\n        \n        address _withdrawer = msg.sender;\n        // Get the pending buffer and staged buffer.\n             RequestBuffer storage _pendingBuffer = _requests(false);\n             RequestBuffer storage _stagedBuffer = _requests(true);\n        // Check if the withdrawer have enough balance to withdraw.\n        uint256 _bookedAmountMLP =  _stagedBuffer.withdrawAmountPerUser[_withdrawer] + \n       _pendingBuffer.withdrawAmountPerUser[_withdrawer];\n            require(_bookedAmountMLP + _amountMLP <= \n                MozaicLP(mozLP).balanceOf(_withdrawer), \"Withdraw amount > amount  MLP\");\n        \u2026\n        emit WithdrawRequestAdded(_withdrawer, _token, chainId, _amountMLP);\n        }\n",
        "                // Burn moazic LP token.\n            MozaicLP(mozLP).burn(request.user, _mlpToBurn);\n"
    ],
    "Description": [
        "\nUsers request to queue a withdrawal using the function below in Vault.",
        "Notice that the function only validates that the user has a sufficient LP token balance to\nwithdraw at the moment of execution. After it is queued up, a user can move their tokens to\nanother wallet. Later in _settleRequests(), the Vault will attempt to burn user's tokens:",
        "This would revert and block any other settlements from occurring. Therefore, users can block\nthe entire settlement process by requesting a tiny withdrawal amount in every epoch and\nmoving funds to another wallet."
    ],
    "Recommended Mitigation": [
        "\nVault should take custody of user's LP tokens when they request withdrawals. If the entire\nwithdrawal cannot be satisfied, it can refund some tokens back to the user."
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation Review": [
        "\nThe Vault now holds custody of withdrawn LP tokens. If it is not able to transfer the desired\namount of stablecoins, it will transfer the remaining LP tokens back to the user."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-3-all-layerzero-requests-will-fail-making-the-contracts-are-unfunctional-trust-security-none-mozaic-archimedes-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nWhen sending messages using the LayerZero architecture, native tokens must be supplied to\ncover the cost of delivering the message at the receiving chain. However, none of the Mozaic\ncontracts account for it. The controller calls the bridge's requestSnapshot(), requestSettle(),\nrequestExecute() without passing value. Vault calls reportSnapshot(), reportSettle() similarly.\nStargatePlugin calls the StargateRouter's swap() which also requires value. As a result, the\ncontracts are completely unfunctional."
    ],
    "Recommended Mitigation": [
        "\nPass value in each of the functions above. Perform more meticulous testing with LayerZero\nendpoints. Contracts should support receiving base tokens with the receive() fallback, to pay\nfor fees."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe Controller and Vault now pass appropriate value in native tokens for messaging. The\ncontracts can be topped-up with the receive() method."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-1-removal-of-multisig-members-will-corrupt-data-structures-trust-security-none-mozaic-archimedes-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        if(proposals[_proposalId].actionType == TYPE_DEL_OWNER) {\n                (address _owner) = abi.decode(proposals[_proposalId].payload, (address));\n        require(contains(_owner) != 0, \"Invalid owner address\");\n            uint index = contains(_owner);\n                for (uint256 i = index; i < councilMembers.length - 1; i++) {\n            councilMembers[i] = councilMembers[i + 1];\n        }\n            councilMembers.pop();\n                 proposals[_proposalId].executed = true;\n                     isCouncil[_owner] = false;\n          }\n",
        "       function contains(address _owner) public view returns (uint) {\n             for (uint i = 1; i <= councilMembers.length; i++) {\n       if (councilMembers[i - 1] == _owner) {\n                return i;\n            }\n        }\n        return 0;\n        }\n"
    ],
    "Description": [
        "\nThe Mozaic Multisig (the senate) can remove council members using the TYPE_DEL_OWNER\noperation:"
    ],
    "isCouncil[_owner]": [
        "The code finds the owner's index in the councilMembers array, copies all subsequent\nmembers downwards, and deletes the last element. Finally, it deletes the \nentry.\nThe issue is actually in the contains() function."
    ],
    "owner": [
        "The function returns the index following the 's index. Therefore, the intended  is\nnot deleted from councilMembers, instead the one after it is. The submitProposal() and\nconfirmTransaction() privileged functions will not be affected by the bug, as they filter by\nisCouncil. However, the corruption of councilMembers will make deleting the member\nfollowing the currently deleted  fail, as deletion relies on finding the member in\ncouncilMembers."
    ],
    "Recommended Mitigation": [
        "\nFix the contains() function to return the correct index of _owner"
    ],
    "Team Response": [
        "\nFixed."
    ],
    "Mitigation review": [
        "\nIndex is calculated correctly."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-2-multisig-could-become-permanently-locked-trust-security-none-mozaic-archimedes-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nAs described, the senate can remove council members. It can also adjust the threshold for\nquorum using the TYPE_ADJ_THRESHOLD proposal type. Both remove and adjust operations\ndo not perform an important security validation, that the new council member count and\nthreshold number allow future proposal to pass."
    ],
    "Recommended Mitigation": [
        "\nVerify that councilMembers.length >= threshold, after execution of the proposal."
    ],
    "Team Response": [
        "\nFixed."
    ],
    "Mitigation review": [
        "\nThe TYPE_ADJ_THRESHOLD proposal now checks the new threshold is safe. However it is not\nchecked during owner removal."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-3-attacker-could-abuse-victims-vote-to-pass-their-own-proposal-trust-security-none-mozaic-archimedes-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        function submitProposal(uint8 _actionType, bytes memory _payload)  public onlyCouncil {\n             uint256 proposalId = proposalCount;\n                 proposals[proposalId] = Proposal(msg.sender,_actionType, \n                    _payload, 0, false);\n                proposalCount += 1;\n         emit ProposalSubmitted(proposalId, msg.sender);\n        }\n",
        "        function confirmTransaction(uint256 _proposalId) public onlyCouncil \n            notConfirmed(_proposalId) {\n             confirmations[_proposalId][msg.sender] = true;\n             proposals[_proposalId].confirmation += 1;\n        emit Confirmation(_proposalId, msg.sender);\n        }\n"
    ],
    "Description": [
        "\nProposals are created using submitProposal():",
        "After submission, council members approve them by calling confirmTransaction():"
    ],
    "_proposalId": [
        "Notably, the  passed to confirmTransaction() is simply the proposalCount at time\nof submission. This design allows the following scenario to occur:"
    ],
    "Recommended Mitigation": [
        "\nCalculate proposalId as a hash of the proposal properties. This way, votes cannot be\nmisdirected."
    ],
    "Team Response": [
        "\nFixed."
    ],
    "Mitigation review": [
        "\nThe suggestion mitigation has been applied correctly. It is woth noting that the new\nproposalIds array will keep growing throughout the governance lifetime. At some point, it\nmay be too large to fetch using getProposalIds()."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-4-users-can-lose-their-entire-xmoz-balance-when-specifying-too-short-a-duration-for-redemption-trust-security-none-mozaic-archimedes-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "            function redeem(uint256 xMozAmount, uint256 duration) external {\n                require(xMozAmount > 0, \"redeem: xMozAmount cannot be zero\");\n                    xMozToken.transferFrom(msg.sender, address(this), xMozAmount);\n                    uint256 redeemingAmount = xMozBalances[msg.sender];\n                   // get corresponding MOZ amount\n                    uint256 mozAmount = getMozByVestingDuration(xMozAmount, duration);\n                 if (mozAmount > 0) {\n             emit Redeem(msg.sender, xMozAmount, mozAmount, duration);\n            // add to total\n             xMozBalances[msg.sender] = redeemingAmount + xMozAmount;\n             // add redeeming entry\n                userRedeems[msg.sender].push(RedeemInfo(mozAmount, \n             xMozAmount, _currentBlockTimestamp() + duration));\n             }\n              }\n"
    ],
    "Description": [
        "\nUsers can convert their XMoz to Moz through MozStaking, using redeem()."
    ],
    "mozAmount": [
        "If the specified duration is shorter than the minRedeemDuration specified in the staking\ncontract,  will end up being zero. In such scenarios, redeem will consume user's\nxMozAmount without preparing any redemption at all. The contract should not expose an\ninterface that so easily can lead to loss of funds."
    ],
    "Recommended mitigation": [
        "\nIf duration is less than minRedeemDuration, revert the transaction."
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation review": [
        "\nThe staking contract now verifies that the staking duration is safe to use."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-5-mozstaking-does-not-reserve-moz-tokens-for-redemptions-leading-to-unfulfillable-redemptions-trust-security-none-mozaic-archimedes-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nWhen users call redeem() in MozStaking, they are scheduling a future redemption for a specific\nMoz amount. However, that amount is not set aside for them. Other users can \"cut in line\",\nrequest a redemption for a lower duration and empty the Moz bank. The original user would\nhave to cancel redemption or wait until new users stake their Moz.\nThe assumption that Moz supply > XMoz supply in the staking contract does not hold, as there\nis an initial XMoz supply minted in XMozToken."
    ],
    "Recommended Mitigation": [
        "\nAnother state variable should be introduced to account for the reserved Moz amount.\nMozStaking should not allow new redemptions if there is currently insufficient Moz."
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation review": [
        "\nThe staking contract mints and burns tokens, ensuring it cannot run out of them."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-6-moztoken-will-have-a-much-larger-fixed-supply-than-intended-trust-security-none-mozaic-archimedes-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        constructor( address _layerZeroEndpoint, uint8 _sharedDecimals\n            ) OFTV2(\"Mozaic Token\", \"MOZ\", _sharedDecimals, _layerZeroEndpoint) {\n            _mint(msg.sender, 1000000000 * 10 ** _sharedDecimals);\n                isAdmin[msg.sender] = true;\n            }\n"
    ],
    "Description": [
        "\nMozToken is planned to be deployed on all supported chains. Its total supply will be 1B.\nHowever, its constructor will mint 1B tokens on each deployment."
    ],
    "Recommended Mitigation": [
        "\nPass the minted supply as a parameter. Only on the main chain, mint 1B tokens."
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation review": [
        "\nAccording to Mozaic, Moz and XMoz tokens will be deployed on base chain with the contracts\naudited. When deploying on additional chains, they will remove the _mint() call."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-7-moztoken-allows-owner-to-mint-an-arbitrary-amount-of-tokens-although-supply-is-fixed-trust-security-none-mozaic-archimedes-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        function mint(address to, uint256 amount) public onlyOwner {\n            _mint(to, amount);\n            }\n",
        "        function mint(uint256 _amount, address _to) external   onlyStakingContract {\n            _mint(_to, _amount);\n           }\n",
        "        function setStakingContract(address _mozStaking) external onlyOwner {\n              require(_mozStaking != address(0x0), \"Invalid address\");\n             mozStaking = _mozStaking;\n            }\n"
    ],
    "Description": [
        "\nSupply of MozToken is defined to be fixed at 1B tokens:\nMax Supply\n1B MOZ will be minted at the genesis and will be the entire finite supply of tokens",
        "However, there is an exposed mint() function which allows the owner to mint arbitrary\namount of tokens.",
        "This would typically be in the centralization risks section, however due to the fact that the\ndocumentation is potentially misleading users, it must appear in the main report as well."
    ],
    "Recommended mitigation": [
        "\nRemove the mint() function."
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation review": [
        "\nThe fix made only the staking contract capable of minting tokens.",
        "However, the centralization issue remains as the owner can change the staking contract at\nonce."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-8-the-vault-cannot-operate-with-popular-non-conforming-erc20-tokens-due-to-unsafe-transfers-trust-security-none-mozaic-archimedes-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        ///@notice Withdraw token with specified amount.\n        function withdrawToken(address _token, uint256 _amount) external onlyAdmin {\n             require(_amount != 0, \"ERROR: Invalid amount\");\n                uint256 _curAmount = IERC20(_token).balanceOf(address(this));\n                    require(_curAmount >= _amount, \"ERROR: Current balance is too low\");\n        IERC20(_token).transfer(msg.sender, _amount);\n        }\n        ///@notice Deposit token with specified amount.\n        function depositToken(address _token, uint256 _amount) external onlyAdmin {\n                require(isAcceptingToken(_token), \"ERROR: Invalid token\");\n                    require(_amount != 0, \"ERROR: Invalid amount\");\n                        IERC20(_token).transferFrom(msg.sender, address(this), _amount);\n        }\n",
        "import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n"
    ],
    "Description": [
        "\nIn Vault, the admin can deposit and withdraw tokens using the functions below:",
        "However, it uses transfer()/transferFrom() directly, instead of using a safe transfer library.\nThere are hundreds of tokens who do not use the standard ERC20 signature and return void.\nSuch tokens (USDT, BNB, etc.) would be incompatible with the Vault."
    ],
    "Recommended mitigation": [
        "\nUse the SafeERC20 library. Indeed, it has already been imported to Vault."
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation review": [
        "\nAll transfers have been fixed in Vault. However, StargatePlugin still uses unsafe transfers."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-11-no-slippage-protection-for-cross-chain-swaps-in-stargateplugin-trust-security-none-mozaic-archimedes-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "            // Swaps\n            IStargateRouter(_router).swap(_dstChainId, _srcPoolId, _dstPoolId, \n                  payable(address(this)), _amountLD, 0, IStargateRouter.lzTxObj(0, 0, \"0x\"), abi.encodePacked(_to), bytes(\"\"));\n"
    ],
    "Description": [
        "\nThe StargatePlugin calls StargateRouter's swap() function to do a cross-chain swap.",
        "It will pass 0 as the minimum amount of tokens to receive. This pattern is vulnerable to\nsandwich attacks, where the fee or conversion rate is pumped to make the user receive hardly\nany tokens. In Layer Zero, the equilibrium fee can be manipulated to force such losses."
    ],
    "Recommended mitigation": [
        "\nCalculate accepted slippage off-chain, and pass it to the _swapRemote() function for\nvalidation."
    ],
    "Team response": [
        "\nFixed."
    ],
    "Mitigation review": [
        "\nAffected function has been removed"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-1-user-fee-token-balance-can-be-drained-in-a-single-operation-by-a-malicious-bot-trust-security-none-brahma-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "\n  if (feeToken == ETH) \n   {uint256 totalFee = (gasUsed + GAS_OVERHEAD_NATIVE) * tx.gasprice;\n     totalFee = _applyMultiplier(totalFee);\n       return (totalFee, recipient, TokenTransfer._nativeTransferExec(recipient, totalFee));\n            } else {uint256 totalFee = (gasUsed + GAS_OVERHEAD_ERC20) * tx.gasprice;\n      // Convert fee amount value in fee tokenuint256 feeToCollect =PriceFeedManager(_addressProvider.priceFeedManager()).getTokenXPriceInY(totalFee, ETH, feeToken);\n  feeToCollect = _applyMultiplier(feeToCollect);\n return (feeToCollect, recipient, TokenTransfer._erc20TransferExec(feeToken, recipient, feeToCollect));}\n"
    ],
    "Description": [
        "\nIn _buildFeeExecutable(),  BrahRouter  calculates  the  total  fee  charged  to  the  wallet.  It  uses tx. gas price to get the gas price specified by the bot."
    ],
    "Impact": [
        "\nThe issue is that a malicious bot can manipulate tx.gasprice to be as high as they wish. This value is calculated post EIP1559 as the block base fee plus the sender's priority fee. A bot can offer an extremely high priority fee to drain the user's fee token balance. These losses will go to the Brahma fund manager."
    ],
    "Recommended Mitigation": [
        "\nUse a gas oracle or a capped priority fee to ensure an inflated gas price down not harm the user."
    ],
    "Team response": [
        "\nThere  exist  some  scenarios  where  high  gas  may  be  required  for  quick  block  inclusion  like liquidation protection. An additional check is not worth the added oracle gas cost for this.We  use  reputable  3rd  party  bots  like  gelato  which  work  in  a decentralizedfashion  for  bot operators.  operators  stake  GEL  tokens  which  get  slashed  if  they  submit  txns  with  high  gas price.  Even  if  they  do  so,  they  have  less  economic  incentive  to  do  so  as  the  gas  fee  will  be burned rather than being paid to the miner. If a 3rd party bot still tries to abuse it, they can be kicked by the governance usingBotManager.sol."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-2users-can-drain-gelato-deposit-at-little-cost-trust-security-none-brahma-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "   modifier claimExecutionFees(address _wallet) {\n     uint256 startGas = gasleft();\n  _;\n if (feeMultiplier > 0) {\n    address feeToken = FeePayer._feeToken(_wallet);\n      uint256 gasUsed = startGas -gasleft();\n       (uint256 feeAmount, address recipient, Types.Executable memory feeTransferTxn)=FeePayer._buildFeeExecutable\n         (gasUsed, feeToken);\n emit FeeClaimed(_wallet, feeToken, feeAmount);\n   if (feeToken != ETH) {uint256 initialBalance = IERC20(feeToken).balanceOf(recipient);_\n       executeSafeERC20Transfer(_wallet, feeTransferTxn);\n             if (IERC20(feeToken).balanceOf(recipient) -initialBalance < feeAmount){\n        revert UnsuccessfulFeeTransfer(_wallet, feeToken);}\n     } else {\n    uint256 initialBalance = recipient.balance;\n  Executor._executeOnWallet(_wallet, feeTransferTxn);\n if (recipient.balance -initialBalance < feeAmount) {\n      revert UnsuccessfulFeeTransfer(_wallet, feeToken);\n                }\n            }\n        }\n    }\n"
    ],
    "Description": [
        "\nIn Console automation, fees are collected via the claimExecutionFees() modifier:"
    ],
    "Impact": [
        "\nThe actual strategy processing happens in _; , then the total fee is calculated using the gas used up to this point.\nThe issue is that a malicious user can get arbitrary execution in the actual payment stage. It is easy to create and register a custom wallet contract as a Safe contract. In _executeOnWallet(), the contract would be called to deliver the payment request. However, the malicious contract can execute anything at this point. It could use up a large amount of gas and convert it to gas tokens likeCHI. It would only pay for the strategy execution, which could be negligible compared to actual gas usage. The Gelato deposit in GelatoBot could be drained with little cost."
    ],
    "Recommended Mitigation": [
        "\nWhen calculating fees in buildFeeExecutable(), there are assumptions about the gas cost of an ERC20 transfer and a native transfer.",
        "A good fix would be to check the actual gas usage and require it to be under the hard cap.Team responseAdded a gas check for this attack.Mitigation reviewApplied fix has been applied."
    ],
    "Team Response": [
        "\nAdded a gas check for this attack"
    ],
    "Mitigation review": [
        "\nApplied fix has been applied"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-3-attackers-can-drain-users-over-time-by-donating-negligible-erc20-amount-trust-security-none-brahma-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "\n      function canInitSwap(address subAccount, address inputToken, uint256 interval, uint256 lastSwap)\n          external view returns (bool)\n        {\n      if (hasZeroBalance(subAccount, inputToken)) \n          { return false;\n        }\n      return ((lastSwap + interval) < block.timestamp);\n      }\n"
    ],
    "Description": [
        "\nIn the Console automation model, a strategy shall keep executing until its trigger check fails. For DCA strategies, the swapping trigger is defined as:"
    ],
    "Impact": [
        "\nNote that every execution will charge the user for gas costs, which can be expensive. The issue is that whenever the account is empty, anyone can donate inputToken to the user, which will make the check pass periodically. It would keep executing a negligible swap order. The bot will not unsubscribe the user from the strategy because the exit trigger is defined to be zero balance for the user, which attacker can ensure will never be true."
    ],
    "Recommended Mitigation": [
        "\nDefine a DUST_AMOUNT, below that amount exit is allowed, while above that amount swap execution is allowed. User should only stand to gain from another party donating ERC20 tokens to their account."
    ],
    "Team response": [
        "\nFix DCA automation to only swap requested amount."
    ],
    "Mitigation review": [
        "\nFixed."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-4-executors-can-drain-the-gelato-deposit-while-profiting-from-free-gas-trust-security-none-brahma-markdown
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    if (feeToken != ETH) {\n      uint256 initialBalance = IERC20(feeToken).balanceOf(recipient);\n      _executeSafeERC20Transfer(_wallet, feeTransferTxn);\n        if (IERC20(feeToken).balanceOf(recipient) - initialBalance < feeAmount)\n    {\n    revert UnsuccessfulFeeTransfer(_wallet, feeToken);\n    }\n    } else {\n    uint256 initialBalance = recipient.balance; Executor._executeOnWallet(_wallet, feeTransferTxn); if (recipient.balance - initialBalance < feeAmount) {\n    revert UnsuccessfulFeeTransfer(_wallet, feeToken);\n            }\n      }\n"
    ],
    "Description": [
        "\nAs discussed, claimExecutionFees() charges the user for gas fees. Since wallet is not trusted, the payment is wrapped and checked that the balance increased by the required amount."
    ],
    "Impact": [
        "",
        "While the check is sound, it can be bypassed because the execution functions are not protected from reentrancy. A bot attacker can profit by registering a malicious wallet contract, which reenters for the execution of another strategy on their wallet. At this point, the initialBalance will be the same as the previous initialBalance. The contract may reenter many times, and at the final iteration it will actually pay the feeAmount. When the TXs unwind, it will appear as the fee has been paid for all transactions, although it has only been paid for the last one. This can be abused to claim the gas costs from the GelatoBot deposit, while converting the free gas to gas tokens to net profit."
    ],
    "Recommended mitigation": [
        "\nMark the execution functions as nonReentrant."
    ],
    "Mitigation review": [
        "\nBoth execution functions are protected by a reentrancy guard."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-1-when-feepayer-is-subsidizing-users-can-steal-gas-trust-security-none-brahma-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "The feeMultiplier enables the admin to subsidize or upcharge for the automation service.\n/**\n\u2981\t@notice feeMultiplier represents the total fee to be charged on the transaction\n\u2981\tIs set to 100% by default\n\u2981\t@dev In case feeMultiplier is less than BASE_BPS, fees charged will be less than 100%,\n\u2981\tsubsidizing the transaction\n\u2981\tIn case feeMultiplier is greater than BASE_BPS, fees charged will be greater than 100%,\n\u2981\tcharging the user for the transaction\n*/ \n      uint16 public feeMultiplier = 10_000;\n        // The normal fee is calculated and then processed by the multiplier.\n  if (feeToken == ETH) {\n         uint256 totalFee = (gasUsed + GAS_OVERHEAD_NATIVE) * tx.gasprice; \n      totalFee = _applyMultiplier(totalFee);\n    return (totalFee, recipient, TokenTransfer._nativeTransferExec(recipient, totalFee));\n  } else {\n"
    ],
    "Description": [
        ""
    ],
    "Impact": [
        "\nThe issue is that Brahma stands to lose up to Gelato deposit x subsidization %. Gas can be stolen by setting up a malicious wallet and programming the adapter function (likely execTransactionFromModuleReturnData()), to mint a popular gas token such as CHI or GST2. Then, attacker can schedule an ever-occurring automation which will trigger their gas minting logic."
    ],
    "Recommended Mitigation": [
        "\nThe root cause is that the gasUsed amount is subsidized as well as GAS_OVERHEAD_NATIVE, which is the gas reserved for the delivery from Gelato executors. By subsidizing only the Gelato gas portion, users will not gain from gas minting attacks, while the intention of improving user experience is maintained."
    ],
    "Team Response": [
        "\nThanks, duly noted. The subsidy is meant to be used during small-time promotional events. Acknowledged."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-2-strategy-actions-could-be-executed-out-of-order-due-to-lack-of-reentrancy-guard-trust-security-none-brahma-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    function _executeAutomation( address _wallet, address _subAccount, address _strategy,\n       Types.Executable[] memory _actionExecs ) internal {\n        uint256 actionLen = _actionExecs.length;\n    if (actionLen == 0) {\n           revert InvalidActions();\n        } else {\n      uint256 idx = 0;\n    do {\n    _executeOnSubAccount(_wallet, _subAccount, _strategy,\n    _actionExecs[idx]);\n    unchecked {\n    ++idx;\n            }\n          } while (idx < actionLen);\n        }\n      }\n"
    ],
    "Description": [
        "\nThe Execute module performs automation of the fetched Executable array on wallet subaccounts."
    ],
    "Impact": [
        "\nNote that there are no uses of reentrancy guards in this function or any above it in the call chain. As a result, a bot or a keeper can execute operations out of sequence. For example, instead of actions called as [1,2,3], it could call [1,[1,2,3],2,3]. As a result, security guarantees are bypassed which can have unforeseen impacts on future strategies. Using the DCA strategy as an example, consider that it is composed of two actions. The first performs the swap while the second updates the block.timestamp of the last swap, so that a future automation will need to wait the appropriate interval. Through abusing the reentrancy, a bot could execute the strategy an unlimited number of times. As a result, it becomes a single spot swap instead of a DCA swap. A requirement for this attack is that at some point during execution, the strategy will interact with an external address that belongs to the keeper or bot."
    ],
    "Recommended Mitigation": [
        "\nAdd a reentrancy guard for executeAutomationViaBot() and executeTrustedAutomation()."
    ],
    "Team Response": [
        "\nFixed as suggested."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-3-anyone-can-make-creating-strategies-extremely-expensive-for-the-user-trust-security-none-brahma-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    function deploySpareSubAccount(address _wallet) external { address subAccount =\n        SafeDeployer(addressProvider.safeDeployer()).deploySubAccount(_wallet);\n             subAccountToWalletMap[subAccount] = _wallet; walletToSubAccountMap[_wallet].push(subAccount);\n           // No need to update subAccountStatus as it is already set to false\n              emit SubAccountAllocated(_wallet, subAccount);\n                }\n",
        "  function requestSubAccount(address _wallet) external returns (address) {\n      if (msg.sender != subscriptionRegistry) \n        revert OnlySubscriptionRegistryCallable();\n          // Try to find a subAccount which already exists\n           address[] memory subAccountList = walletToSubAccountMap[_wallet];\n"
    ],
    "Description": [
        "\nIn Console architecture, users can deploy spare subaccounts (Gnosis Safes) so that when they will subscribe to a strategy most of the gas spending would have been spent at a low-gas phase."
    ],
    "Impact": [
        "\nThe issue is that anyone can call the deploy function and specify another user's wallet. While on the surface that sounds like donating gas costs, in practice this functionality can make operating with strategies prohibitively expensive.\nWhen users will subscribe to strategies, the StrategyRegistry will request a subaccount using this function:",
        "At this point, the entire subaccount array will be copied from storage to memory. Therefore, attackers can fill the array with hundreds of elements at a low-gas time and make creation of strategies very difficult."
    ],
    "Recommended Mitigation": [
        "\nLimit the amount of spare subaccount to something reasonable, like 10\nTeam Response:\nRemoving the spare subaccount deployment\nMitigation review:\nAttack surface has been removed."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-4-dca-strategies-may-not-be-effective-at-averaging-spot-prices-trust-security-none-brahma-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nThe DCA strategies periodically set off CoW Swap orders, according to the specified interval. The order TTL is fixed at 2 hours. When interval is not an order of magnitude larger than TTL, the strategy does not average effectively. An order fulfilled near the end of the TTL window would be priced much closer to the next order. When interval < TTL, consecutive orders can be executed at the same time."
    ],
    "Recommendation": [
        "\nTTL should be a dynamic value based on the user's specified interval. Team response\nUser makes this DCA subscription call with interval that they decide. We don't support intervals less than a day. If they chose to try interval less than a day, which means less than effective averaging, that's their prerogative."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-5-dca-strategies-build-orders-that-may-not-be-executable-wasting-fees-trust-security-none-brahma-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    // Check if enough balance present to swap, else swap entire balance\n        uint256 amountIn = (inputTokenBalance < params.amountToSwap) ? \n          inputTokenBalance : params.amountToSwap;\n"
    ],
    "Description": [
        "\nIn _buildInitiateSwapExecutable(), DCA strategies determine the swap parameters for the CoW Swap. The code has recently been refactored so that there may be more than one active order simultaneously. The issue is that the function assumes the user's entire ERC20 balance to be available for the order being built."
    ],
    "Impact": [
        "\nThis is a problem because if the previous order will be executed before the current order, there may not be enough funds to pull from the user to execute the swap. As a result, transaction execution fees are wasted."
    ],
    "Recommended Mitigation": [
        "\nEnsure only one swap can be in-flight at a time, or deduct the in-flight swap amounts from the current balance."
    ],
    "Team response": [
        "\nSet min interval during initialization to more than 2 hours."
    ],
    "Mitigation review": [
        "\nFix works as interval > TTL at any point."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-6-user-will-lose-all-console-functionality-when-upgrading-their-wallet-and-an-upgrade-target-has-not-been-set-up-trust-security-none-brahma-markdown
--------------------------------------------------
----Start JSON----
{
    "code": [
        "  function upgradeWalletType() external {\n    if (!isWallet(msg.sender)) \n    revert WalletDoesntExist(msg.sender); uint8 fromWalletType = _walletDataMap[msg.sender].walletType;\n      _setWalletType(msg.sender, _upgradablePaths[fromWalletType]);\n      emit WalletUpgraded(msg.sender, fromWalletType,\n  _upgradablePaths[fromWalletType]);\n  }\n",
        "   function _setWalletType(address _wallet, uint8 _walletType) private {\n    _walletDataMap[_wallet].walletType = _walletType;\n    }\n",
        "  function isWallet(address _wallet) public view returns (bool) \n    { WalletData memory walletData = _walletDataMap[_wallet];\n  if (walletData.walletType == 0 || walletData.feeToken == address(0)){\n          return false;\n        }\n    return true;\n  }\n"
    ],
    "Description": [
        "\nConsole supports upgrading of the manager wallet using the upgradeWalletType() function.",
        "Note that upgradablePaths are set by governance. There is a lack of check that the upgradable path is defined before performing the upgrade.",
        "If _upgradablePaths[fromWalletType] is zero (uninitialized), the user's wallet type shall become zero too. However, zero is an invalid value, as defined by the isWallet() view function:"
    ],
    "Impact": [
        "\nAs a result, most of the functionality of Console is permanently broken when users upgrade their wallet when an upgrade path isn't set. They can salvage their funds if it is a Safe account, as they can still execute on it directly."
    ],
    "Recommended Mitigation": [
        "\nWhen settings a new wallet type, make sure the new type is not zero."
    ],
    "Team response": [
        "\nRemove upgradable feature, replaced with deregistering wallet."
    ],
    "Mitigation review": [
        "\nRelevant code has been removed."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-1-first-liquidity-provider-receives-increased-returned-shorts-due-to-increased-duration-trust-security-none-timeswap-markdown
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nWhen updating duration weight, pool\u2019s lastTimestamp is initially set to 0. During the first call\nto PoolLibrary.updateDurationWeightBeforeMaturity(), the amount of returned shorts will be\ncalculated based on a duration starting at the start of the Unix epoch (January 1, 1970). As a\nresult, the first liquidity provider\u2019s position will accumulate 53+ years of short tokens, which\nwill let the liquidity provider claim more returned shorts than expected\u2013the excess amount\nwill be subtracted from the returned shorts of other liquidity providers. In other words, first\nliquidity provider will be able to claim other liquidity providers\u2019 shorts.\nThe vulnerability can be exploited by any first liquidity provider in a pool. On the first deposit,\nPoolLibrary.mint() will not update duration weight since pool\u2019s liquidity will be 0; however,\npool\u2019s lastTimestamp will be initialized at 0 (the default value of uint256). The position\u2019s\nshortReturnedGrowth will be set to 0 since the pool won\u2019t accumulate any returned shorts\nby this time. Any other deposit of liquidity will trigger a call to\nPoolLibrary.updateDurationWeightBeforeMaturity(), which will accrue returned shorts for a\nduration computed as block.timestamp - 0, resulting in an increased value of\nshortReturnedGrowth. As a result, the first liquidity provider\u2019s position will accumulate\nincreased shorts, while other liquidity providers\u2019 positions will accumulate correct amounts."
    ],
    "Recommended Mitigation": [
        "\nWhen adding initial liquidity to a pool, consider setting pool\u2019s lastTimestamp to\nblock.timestamp. Additionally, ensure that pool\u2019s lastTimestamp is handled correctly when\nremoving and re-adding the entire liquidity of a pool."
    ],
    "Team response": [
        "\nThis issue has been fixed as was suggested, in the commit linked here (https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/commit/cfbae00d6af384ea9b2f477ba7cecc1ff4f3009a)"
    ],
    "Mitigation review": [
        "\nFixed as per the recommendation: pool.lastTimestamp is set to the current block timestamp\nwhen liquidity is minted in a pool with 0 liquidity."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-2-pool-initialization-can-be-front-ran-to-manipulate-the-interest-rate-trust-security-none-timeswap-markdown
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nA pool can be permissionlessly initialized multiple times, each time setting a different interest\nrate. An interest rate can be set by either a liquidity provider or a malicious actor. When a\nliquidity provider creates a new pool, they send two transactions:"
    ],
    "Recommended Mitigation": [
        "\nConsider reworking the initialization of a pool so that a liquidity provider can always provide\ninitial liquidity at a chosen interest rate. This may require adding the initial interest rate as a\nkey to the TimeswapV2Pool.pool mapping, so that each pool is identified by a strike price, a\nmaturity date, and an initial interest rate."
    ],
    "Team Response": [
        "\n\"This may be mitigated by making a multicall to both initialise and addLiquidity at the same\ntime. We currently utilise the same while creating a new pool.\""
    ],
    "Mitigation review": [
        "\nIn packages/v2-pool/README.md, a note was added:\n\"It is recommended to call initialize and mint for the initial liquidity addition\nin a single multicall as otherwise it is possible for a malicious actor to\nsandwich the transactions.\"\nThe issue remains valid when a multicall contract is not used. Some alternative fixes are\nproposed:"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-1-short-token-amounts-rounding-can-result-in-a-revert-when-burning-options-trust-security-none-timeswap-markdown
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nIn OptionLibrary.mint(), when computing the amount of shorts in a GivenTokensAndLongs\ntransaction, the \"round up\" flag is set to false, but, during burning in OptionLibrary.burn(), it's\nset to true. This can result in a reverted transaction when burning all previously minted tokens\nusing a GivenTokensAndLongs transaction: the rounding in OptionLibrary.burn() will increase\nthe amount of short tokens to burn by 1, which will result in an \"Arithmetic over/underflow\"\nerror. In such situations, to burn their tokens users will have to use the GivenShorts\ntransaction type, which requires extra calculations."
    ],
    "Recommended Mitigation": [
        "\nConsider using consistent rounding when computing the amount of short tokens from\namounts of long tokens via StrikeConversion.combine(). In the current implementation,\nOptionLibrary.burn(), OptionLibrary.totalPosition(), and OptionLibrary.collect() round up, but\nOptionLibrary.mint() rounds down."
    ],
    "Team Response": [
        "\n\"After deliberation we have arrived at the conclusion that this roundUp/roundDown issue\nmentioned is to documented.\nUnfortunately cannot roundUp during the mint.\nAs a workaround the same library StrikeConversion may be utilized in calculating the input for\nthe burn transaction, instead of taking the output from the mint transaction, this is currently\nbeing followed in our peripheries.\nThis would resultin the userlosing about 1 unit position, thisis a limitation of the workaround.\""
    ],
    "Mitigation review": [
        "\nIn packages/v2-pool/README.md, a note was added:\nThe contracts like most others roundUp/roundDown calculations, which may\naccount for some minor loss from rounding. Eg: When minting using\ngivenTokensAndLong and burning using givenTokensAndLong using given,\nthe total short that one can burn might be 1 less than the actual short position\nowned. This maybe mitigated by using the same library as the one pool uses\nwhile calculating the long amount required for the short position amount.\nThe issue remains valid and cannot be fully fixed because burning of option tokens is\nimplemented as redeeming of short options with a conversion of short options to long\noptions. The amount of short options is rounded up when the GivenTokensAndLongs\ntransaction type is used, which forces users to provide +1 short options and burn -1 long\noptions. Thus, the GivenTokensAndLongs transaction type cannot be seemed as an exact\ninput one when burning all short/long tokens of an address.\nA possible fix would be to remove the GivenTokensAndLongs branch in OptionLibrary.mint()."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-2-timeswapv2poolfactory-allows-creation-of-pools-with-non-standard-option-contracts-trust-security-none-timeswap-markdown
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nThe TimeswapV2PoolFactory.create() function doesn\u2019t check that the provided options\ncontract was created via the official TimeswapV2OptionFactory. This allows creation of official\npools (i.e. pools created via the official TimeswapV2PoolFactory) with non-official underlying\noptions contracts. Since option contracts accept and store user funds, this poses a severe risk\nfor users who interact with Timeswap pools.",
        "A malicious actor can:"
    ],
    "Recommended Mitigation": [
        "\nConsider reworking the TimeswapV2PoolFactory.create() function to take a pair of token\naddresses instead of an options contract address. Having token addresses, the function can\nget an options contract address from the official TimeswapV2OptionFactory deployment."
    ],
    "Team Response": [
        "\nHas been identified and fixed here: commit (https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/commit/e32cf3697691c20be327978b50947c0172cb2240)"
    ],
    "Mitigation review": [
        "\nTimeswapV2PoolFactory.create() was updated as per the recommendation."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-3-wrong-erc1155-metadata-uri-trust-security-none-timeswap-markdown
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nTimeswapV2LiquidityToken and TimeswapV2Token implement the ERC1155 metadata\nextension, however they incorrectly set the URIs. As per the ERC1155 specification:\nThe URI MUST point to a JSON file that conformsto the \"ERC-1155 Metadata URI JSON\nSchema\u201d.\nIncorrectly-set URIs will affect off-chain integrations with the tokens that will try to read\ntokens\u2019 metadata and fail."
    ],
    "Recommended Mitigation": [
        "\nConsider correctly setting the URIs in TimeswapV2LiquidityToken and TimeswapV2Token.\nAlternatively, consider not implementing the metadata extension since it\u2019s optional (this\nwould require copying the ERC1155 implementation from OpenZeppelin and removing the\nmetadata extension implementation; also, the IERC1155MetadataURI interface selector\nshould be removed from supported interfaces)."
    ],
    "Team Response": [
        "\nThe issue was fixed as is suggested in this commit: commit.(https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/pull/483/commits/946eb502e3373b6339009121c1ca5f8d57be73ff)"
    ],
    "Mitigation review": [
        "\nTimeswapV2LiquidityToken and TimeswapV2Token were updated as per the\nrecommendation: the contracts set a metadata URI in their constructors."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-1-reentrancy-protection-can-likely-be-bypassed-trust-security-none-lukso-lsp-audit-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    function _nonReentrantAfter() internal virtual {\n    // By storing the original value once again, a refund is triggered \n             (see // https://eips.ethereum.org/EIPS/eip-2200)\n        _reentrancyStatus = false;\n     }\n"
    ],
    "Description": [
        "\nThe KeyManager offers reentrancy protection for interactions with the associated account.\nThrough the LSP20 callbacks or through the execute() calls, it will call _nonReentrantBefore()\nbefore execution, and _nonReentrantAfter() post-execution. The latter will always reset the\nflag signaling entry.",
        "An attacker can abuse it to reenter provided that there exists some third-party contract with\nREENTRANCY_PERMISSION that performs some interaction with the contract. The attacker\nwould trigger the third-party code path, which will clear the reentrancy status, and enable\nattacker to reenter. This could potentially be chained several times. Breaking the reentrancy\nassumption would make code that assumes such flows to be impossible to now be vulnerable."
    ],
    "Recommended Mitigation": [
        "\nIn _nonReentrantAfter(), the flag should be returned to the original value before reentry,\nrather than always setting it to false."
    ],
    "Team response": [
        "\nApplied a fix different than recommendation."
    ],
    "Mitigiation review": [
        "\nAll code paths will now leave the _reentrancyStatus on when the current call is not the initial\ncall to the KeyManager."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-1-lsp20-verification-library-deviates-from-spec-and-will-accept-fail-values-trust-security-none-lukso-lsp-audit-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    function _verifyCall(address logicVerifier) internal virtual returns (bool verifyAfter) {\n        (bool success, bytes memory returnedData) = logicVerifier.call(\n            abi.encodeWithSelector(ILSP20.lsp20VerifyCall.selector, msg.sender, msg.value, msg.data)\n    );\n    if (!success) _revert(false, returnedData);\n    if (returnedData.length < 32) revert \n      LSP20InvalidMagicValue(false, returnedData);\n        bytes32 magicValue = abi.decode(returnedData, (bytes32));\n    if (bytes3(magicValue) != \n      bytes3(ILSP20.lsp20VerifyCall.selector))\n        revert LSP20InvalidMagicValue(false, returnedData);\n    return bytes1(magicValue[3]) == 0x01 ? true : false;\n    }\n"
    ],
    "Description": [
        "\nThe functions lsp20VerifyCall() and lsp20VerifyCallResult() are called to validate the owner\naccepts some account interaction. The specification states they must return a specific 4 byte\nmagic value.\nHowever, the implementation will accept any byte array that starts with the required magic\nvalue.",
        "Therefore, implementations of the above functions which intend to signal failure status may\nbe accepted by the verification wrapper above."
    ],
    "Recommended Mitigation": [
        "\nVerify that the return data length is 32 bytes (the 4 bytes are extended by the compiler), and\nthat all other bytes are zero."
    ],
    "Team Response": [
        "\nFixed (applied recommendation)."
    ],
    "Mitigation review": [
        "\nThe code correctly validates only the first four bytes are not zero. Code will still accept data\nlength which is greater than 32 bytes, which has been confirmed as a design decision"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-2-deviation-from-spec-will-result-in-dislocation-of-receiver-delegate-trust-security-none-lukso-lsp-audit-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "  bytes32 lsp1typeIdDelegateKey = LSP2Utils.generateMappingKey(\n  _LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX, bytes20(typeId));\n"
    ],
    "Description": [
        "\nThe LSP0 universalReceiver() function looks up the receiver delegate by crafting a mapping key\ntype.",
        "Mapping keys are constructed of a 10-byte prefix, 2 zero bytes and a 20-byte suffix. However,\nfollowers of the specification will use an incorrect suffix.\nThe docs do not discuss the trimming of bytes32 into a bytes20 type. The mismatch may cause\nvarious harmful scenarios when interacting with the delegate not using the reference\nimplementation."
    ],
    "Recommended Mitigation": [
        "\nDocument the trimming action in the LSP0 specification."
    ],
    "Team Response": [
        "\nFix applied (documented in specs)."
    ],
    "Mitigation review": [
        "\nDocs clearly state the described behavior."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-3-lsp0-allows-delegate-calls-when-lsp20-post-execution-check-is-required-trust-security-none-lukso-lsp-audit-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nLSP20 call verification protects actions on an LSP0 account. The pre-execution check may mark\nthe action as requiring a post-execution check. However, in the case of delegate call execution, the post-execution check can never be guaranteed to execute. The called contract\nmay call the SELFDESTRUCT opcode and destroy the calling contract. Call flow returns\nimmediately from the call to execute(), without executing the necessary check."
    ],
    "Recommended Mitigation": [
        "\nWhen the first call verification marks a secondary call as necessary, disallow delegate call\nexecution. The fix should be applied to both execute() variants."
    ],
    "Team Response": [
        "\nThe use of delegatecall with selfdestruct will result in the destruction of the contract, in this\ncase, the post-execution check will not run. However, delegatecall could be used in other\nscenarios requiring a post-execution check. We decided not to remove the post-execution\ncheck because of only one edge case."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-4-incorrect-decoding-of-universalreceiver-call-trust-security-none-lukso-lsp-audit-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    function callUniversalReceiverWithCallerInfos(address universalReceiverDelegate,\n        bytes32 typeId, bytes calldata receivedData, address msgSender, uint256 msgValue) internal            returns (bytes memory) {\n    bytes memory callData = abi.encodePacked(\n           abi.encodeWithSelector(\nILSP1UniversalReceiver.universalReceiver.selector, typeId,receivedData ),\n    msgSender,\n       msgValue\n    );\n    (bool success, bytes memory result) = \n        universalReceiverDelegate.call(callData);\n    Address.verifyCallResult(success, result, \"Call to universalReceiver failed\");\n          return result.length != 0 ? abi.decode(result, (bytes)) : result;\n        }\n",
        "      function universalReceiver(bytes32 typeId, bytes memory\n       /* data */\n      )   public payable virtual returns (bytes memory result) {\n"
    ],
    "Description": [
        "\nSome contracts use the utility below to interact with the registered universal receiver\ndelegate."
    ],
    "bytes": [
        "However, the wrapper above will only decode the low-level call into a  type when result\nin non-zero. In fact, when result is zero the delegate has returned invalid output (no\nreturndata). The callee will confuse the response with a valid zero- return value and will\npresumably finish execution."
    ],
    "Recommended mitigation": [
        "\nWhen the result length is zero, revert the transaction."
    ],
    "Team response": [
        "\nIt was decided by design to allow empty non-conforming bytes."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-5-renounceownership-will-accidentally-be-one-step-in-a-certain-time-period-trust-security-none-lukso-lsp-audit-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nIn _renounceOwnership(), if renouncing did not start yet, confirmationPeriodStart and\nconfirmationPeriodEnd will be 100 and 200 respectively. This means that if the current block\nis between those values, logic will funnel to the second stage handling. This is dangerous as\nwe know Lukso will start from a new genesis block and other blockchains may use the same\nLSP code when they boot."
    ],
    "Recommended Mitigation": [
        "\nIf _renounceOwnershipStartedAt is zero, perform the first step regardless."
    ],
    "Team response": [
        "\nFixed (applied recommendation)."
    ],
    "Mitigation review": [
        "\nFixed."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-6-keymanager-erc165-does-not-support-lsp20-trust-security-none-lukso-lsp-audit-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return\n    interfaceId == _INTERFACEID_LSP6 || interfaceId == _INTERFACEID_ERC1271 ||\n        super.supportsInterface(interfaceId);\n           }\n"
    ],
    "Description": [
        "\nLSP6KeyManager supports LSP20 call verification. However, in supportInterface() it does not\nreturn the LSP20 interfaceId.",
        "As a result, clients which correctly check for support of LSP20 methods will not operate with\nthe KeyManager implementation."
    ],
    "Recommended Mitigation": [
        "\nInsert another supported interfaceId under supportsInterface()."
    ],
    "Team response": [
        "\nFixed (applied recommendation)"
    ],
    "Mitigation review": [
        "\nFixed. An additional non-conforming ERC165 interface was created for verification clients, is\na design decision."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-7-incorrect-permission-check-due-to-confusion-between-empty-call-and-the-zero-selector-trust-security-none-lukso-lsp-audit-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    // CHECK if there is at least a 4 bytes function selector\n    bytes4 selector = executeCalldata.length >= 168\n       ? bytes4(executeCalldata[164:168]) : bytes4(0);\n           return (operationType, to, value, selector);\n",
        "      if (operationType == OPERATION_0_CALL) {\n      if (\n      // CHECK if we are doing an empty call\n          (selector == bytes4(0) && value == 0) ||\n      // we do not require callType CALL\n      // if we are just transferring value without `data`\n          selector != bytes4(0)\n       ) {\n           requiredCallTypes = _ALLOWEDCALLS_WRITE;\n           }\n      }\n"
    ],
    "Description": [
        "\nIn case the caller of LSP6 does not have _PERMISSION_SUPER_CALL, _verifyAllowedCall() is\ncalled to check they have specific permissions for the call. It will use the function\n_extractExecuteParameters() to get the call selector."
    ],
    "_ALLOWEDCALLS_WRITE": [
        "Due to the behavior above, the 0x00000000 selector would be confused with an empty call.\nLater in _extractCallType(), the call will not be marked as requiring \npermission, if it's passing value.",
        "As a result, a user that has transfer permission but not write permission for 0xFFFFFFFF\n(function wildcard), will be permitted to pass calldata to the fallback function. The fallback as\nimplemented in LSP0ERC725AccountCore would look up the extension for 0x00000000\nselector and call it."
    ],
    "Recommended mitigation": [
        "\nConsider adding an isEmptyCall parameter to _extractCallType(). If it is not true,\n_ALLOWEDCALLS_WRITE should be turned on even for selector 0x00000000."
    ],
    "Team response": [
        "\nFixed (applied recommendation)."
    ],
    "Mitigation review": [
        "\nFixed"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-1-_calculateclaim-does-not-distribute-boost-emissions-correctly-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "      if ((lockEndTime - oldUserPoint.ts) > (minLockDurationForReward)) {\n        toDistribute +=\n          (balanceOf * tokensPerWeek[weekCursor]) / veSupply[weekCursor];\n      weekCursor += WEEK;\n      }\n"
    ],
    "Description": [
        "\nThe function _calculateClaim() is responsible for the calculations of the amount of emissions a\nspecific veSatin is entitled to claim. The idea is to distribute emissions only to veSatin tokens\nlocked for more than minLockDurationForReward and only for the extra time the veSatin is\nlocked for on top of minLockDurationForReward. As an example, if minLockDurationForReward\nis set to 6 months a veSatin locked for 7 months would receive emissions for 1 month and a\nveSatin locked for 5 months would receive no emissions at all.\nTo do so the following code is executed in a loop, where every loop calculates the amount of\nemissions the veSatin accumulated during a specific week, in chronological order:"
    ],
    "lockEndTime": [
        "The code distributes the rewards if the elapsed time between  (the locking end\ntimestamp) and oldUserPoint.ts is bigger than minLockDurationForReward. However,\noldUserPoint.ts is the timestamp of the last user action on a veSatin, for example depositing LP\nby calling increaseAmount(). As an example, a user that locks his veSatin and does nothing\nelse will receive rewards for the whole locking duration. In contrast, a user that performs\none action a week would only receive rewards for the locking duration minus\nminLockDurationForReward"
    ],
    "Recommended Mitigation": [
        "\nThe variable weekCursor should be used instead of oldUserPoint.ts in the if condition:"
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has been resolved as suggested, the function _calculateClaim() now correctly\nhandles emissions for the last minLockDurationForReward seconds of locking time"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-2-users-will-be-unable-to-claim-emissions-from-vesatin-tokens-if-they-withdraw-it-or-merge-it-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "           if ((lockEndTime - weekCursor) > (minLockDurationForReward)) {\n            toDistribute +=\n        (balanceOf * tokensPerWeek[weekCursor]) / veSupply[weekCursor];\n        weekCursor += WEEK;\n       }\n"
    ],
    "Description": [
        "\nThe function _calculateClaim() uses the variable lockEndTime when checking if a veSatin is\nentitled to emissions for a particular week (code with mitigation from TRST-H-1):"
    ],
    "lockEndTime": [
        "However  is set to 0 whenever a user withdraws a veSatin by calling withdraw() or\nmerges one by calling merge(). When this is the case the operation  - weekCursor\nunderflows, thus reverting. This results in users being unable to claim veSatin emissions if they\nwithdraw or merge it first"
    ],
    "Recommended Mitigation": [
        "\nIn the withdraw() and merge() functions, call claim() in VeDist.sol to claim emissions before\nsetting the lock end timestamp to 0. In merge() this is only necessary for the veSatin passed\nas _from"
    ],
    "Team Response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has been resolved as suggested, both merge() and withdraw() now call claim() in\nVeDist.sol before lockEndTime is set to 0."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-3-additional-satincash-lp-locked-in-an-owner-created-vesatin-cant-be-withdrawn-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\n_The protocol allows the owners to create a special veSatin for the owners and partners via\ncreateLockForOwner(), which does not require to lock LP. On such veSatin, the protocol\nreverts when calling withdraw(), merge(), and increaseUnlockTime(). However the function\nincreaseAmount(), which is used to lock extra Satin/$CASH LP, does not.\nThis could lead to partners adding Satin/$CASH LP to their position, but then being unable\nwot withdraw it, since withdraw() would revert."
    ],
    "Recommended Mitigation": [
        "\nRevert on calls to increaseAmount() for veSatin tokens created via createLockForOwner(),\nlike in the other functions."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has been resolved as suggested, increaseAmount() can\u2019t be called anymore on a\nveSatin created via createLockForOwner()."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-4-its-possible-to-dos-the-distribution-of-weekly-emissions-and-as-a-consequence-the-whole-protocol-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nThe function updatePeriod(), responsible for the weekly distribution of emissions, internally\ncalls distributeAll() on SatinVoter.sol which loops over all of the existing gauges, updates\nthem and distribute rewards if necessary. This can be an issue when the number of gauges is\nso high that the execution would cost more gas than the maximum amount permitted in a\nblock, thus making the function call toupdatePeriod() always revert."
    ],
    "Recommended Mitigation": [
        "\nCall distribute() only for the Satin/$CASH LP gauge."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has been resolved as suggested, updatePeriod() now only updates and distributes\nemissions to the Satin / $CASH LP gauge."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-5-its-possible-to-dos-voting-for-the-whole-protocol-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nThe function _vote() internally calls _calculateMaxVotePossible(), which internally calls\ngetTotalVotingPower() on Ve.sol, which loops over every veSatin and adds all of their\ncurrent voting power to get the total voting power in the system. This can be an issue when\nthe number of veSatin is so high that the execution would cost more gas than the maximum\namount permitted in a block, thus making _vote() always revert."
    ],
    "Recommended Mitigation": [
        "\nIt\u2019s possible to leverage the variable pointHistory in Ve.sol to get the current total amount of\nvoting power in the system. An example of how this is done is in the function\n_checkpointTotalSupply() in VeDist.sol."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has been resolved as suggested, _calculateMaxVotePossible() now internally\ncalculates the total amount of voting power by calling totalSupply() on Ve.sol which uses the\nvariable pointHistory, which does not require unbounded loops."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-6-its-never-possible-to-vote-for-new-pools-until-setmaxvotesforpool-is-called-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        require(_poolWeights <= _calculateMaxVotePossible(_pool), \"Max votes exceeded\");\n",
        "          return ((totalVotingPower * maxVotesForPool[_pool]) / 100);\n"
    ],
    "Description": [
        "\nThe function _vote() allows voting on a pool only when the current amount of votes plus the\nnew votes is lower or equal to the value returned by _calculateMaxVotePossible():"
    ],
    "maxVotesForPool": [
        "However, _calculateMaxVotePossible() returns 0 for every pool in which the variable\n has not been initialized, thus making _vote() revert:"
    ],
    "Recommended Mitigation": [
        "\nIn createGauge() and createGauge4Pool() set maxVotesForPool for the pool the gauge is\nbeing created for to 100."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has been resolved by adding an if statement that only executes the requirement if\nmaxVotesForPool[_pool] is bigger than zero."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-7-the-protocol-might-transfer-extra-satin-emissions-to-vesatin-holders-potentially-making-satinvotersol-insolvent-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "      uint _claimable = claimable[_gauge];\n      if (SATIN_CASH_LP_GAUGE == _gauge) {\n            veShare = calculateSatinCashLPVeShare(_claimable);\n      _claimable -= veShare;\n      }\n      if (_claimable > IMultiRewardsPool(_gauge).left(token) && _claimable / DURATION > 0) {\n          claimable[_gauge] = 0;\n      if (is4poolGauge[_gauge]) {\n              IGauge(_gauge).notifyRewardAmount(token, _claimable, true);\n      } else {\n                IGauge(_gauge).notifyRewardAmount(token, _claimable, false);\n           }\n      emit DistributeReward(msg.sender, _gauge, _claimable);\n        }\n"
    ],
    "Description": [
        "\nThe function _distribute() in SatinVoter.sol is generally responsible for distributing weekly\nemissions to a gauge based on the percentage of total votes the associated pool received. In\nparticular, it\u2019s called by updatePeriod() (as per fix TRST-H-4) on the gauge associated with\nthe Satin / $CASH pool.\nThe variable veShare is set to be equal to the returned value of\ncalculateSatinCashLPVeShare(), which is calculated as the percentage of Satin / $CASH LP\ntimes claimable[gauge] and represents the amount of SATIN that will be transferred to\nVeDist.sol when checkpointing emissions in checkpointEmissions():"
    ],
    "_claimable > IMultiRewardsPool(_gauge).left(token)": [
        "However, when the if condition ( &&\n_claimable / DURATION > 0) is false the variable claimable[_gauge] will not be set to 0,\nmeaning the next time veShare will be calculated it will include emissions that have already\nbeen distributed, potentially making SatinVoter.sol insolvent"
    ],
    "Recommended Mitigation": [
        "\nAdjust claimable[gauge] after calculating veShare and calculate veShare only if the\nmsg.sender is SatinMinter.sol to prevent potential attackers from manipulating the value by\nrepeatedly calling _distribute():"
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has been resolved as suggested, claimable[gauge] is now correctly adjusted and\nthe veShare calculations are executed only when _distribute() is called by SatinMinter.sol."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-8-its-possible-to-drain-all-the-funds-from-externalbribe-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    Checkpoint memory cp = checkpoints[tokenId][_endIndex];\n      uint _lastEpochStart = _bribeStart(cp.timestamp);\n        uint _lastEpochEnd = _lastEpochStart + DURATION;\n    if (block.timestamp > _lastEpochEnd) {\n            reward += (cp.balanceOf * \n         tokenRewardsPerEpoch[token][_lastEpochStart]) /\n           supplyCheckpoints[getPriorSupplyIndex(_lastEpochEnd)].supply;\n"
    ],
    "Description": [
        "\nThe function earned() is used to calculate the amount rewards owed to a tokenId, to do so it\nperforms a series operations over a loop and then it always executes:"
    ],
    "reward": [
        "which adds to  the amount of s earned by the tokenId during the last epoch in\nwhich it was used to vote, but only if that happened at least a week prior (block.timestamp\n> _lastEpochEnd). Because of this, it\u2019s possible to call earned() multiple times in a row with a\ntokenId that voted more than a week before to drain the contract funds."
    ],
    "Recommended Mitigation": [
        "\nThe function earned() is taken from the Velodrome protocol and is known to have issues.\nBecause it uses the convoluted logic of looping over votes to calculate the rewards per\nepoch instead of looping over epochs, we recommend using the Velodrome fixed\nimplementation, which we reviewed:"
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has been resolved as suggested, the function earned() now uses the suggested\nlogic to calculate rewards"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-9-anybody-can-withdraw-the-admin-fees-in-the-4pool-for-themselves-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nThe admin-only function withdrawAdminFees() is responsible for collecting the 4pool admin\nfees, the way this is done is by withdrawing the excess amount of tokens in the contract\nrelative to the variables tracking the token balances. The function skim() does the same\nthing as withdrawAdminFees() but it\u2019s a public function, meaning anybody can withdraw the\nadmin fees to an arbitrary address."
    ],
    "Recommended Mitigation": [
        "\nBecause skim() is supposed to be called by the team and/or a trusted address to collect\n$CASH rebase restricting access to the skim() function only to the team and/or trusted\naddresses solves the issue.\nImportant to note that when collecting the $CASH rebase the function withdrawAdminFees()\nshould be called first, then the rebase should be distributed, and then skim() should be\nfollowed. If the order is not followed the rebase might be collected as admin fees or the\nadmin fees might be collected as rebase."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has been resolved as suggested, a modifier onlyOwnerOrRebaseHandler() which\nallows calls only from the owner and the rebase handler contract has been applied to both\nthe withdrawAdminFees() and skim() functions."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-1-division-by-0-can-freeze-emissions-claims-for-vesatin-holders-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    if ((lockEndTime - weekCursor) > (minLockDurationForReward)) {\n         toDistribute +=\n            (balanceOf * tokensPerWeek[weekCursor]) / veSupply[weekCursor];\n    weekCursor += WEEK;\n         }\n"
    ],
    "Description": [
        "\nThe function _calculateClaim() is responsible for the calculations of the amount of emissions a\nspecific veSatin is entitled to claim. In doing so, this code is executed (code with mitigation from\nTRST-H-1):"
    ],
    "veSupply[weekCursor]": [
        "The variable  is used as a denominator without checking if it\u2019s 0,\nwhich could make the function revert. If the protocol ever reaches a state where\n is 0, all the claims for veSatin that were locked during that week\nwould fail for both past and future claims. The same issue is present in the function\n_calculateEmissionsClaim()"
    ],
    "Recommended Mitigation": [
        "\nEnsure veSupply[weekCursor] is not 0 when performing the division."
    ],
    "Team Response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has not been resolved in the function _calculateEmissionsClaim() but has been\nresolved in the function _calculateClaim() which now correctly avoids division by 0."
    ],
    "Mitigation Review 2": [
        "\nThe issue has been resolved as suggested in both _calculateEmissionsClaim() and\n_calculateClaim(), which now correctly avoids division by 0."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-2-anybody-can-forfeit-partner-fees-if-there-are-no-partners-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nThe protocol accumulates fees for partners whenever a swap() happens and there\u2019s at least\none partner account. The fees can later be claimed for every partner by calling\nclaimPartnerFee() which distributes the fees to the accounts listed as partners at the\nmoment the function is called. If claimPartnerFee() is called when there are no partners it zeroes partnerClaimable0 and partnerClaimable1 without any distribution occurring, which effectively locks the fees in the contract."
    ],
    "Recommended Mitigation": [
        "\nIn claimPartnerFee() revert if the number of partners is 0."
    ],
    "Team Response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has been resolved in a different, but correct, way than the suggested one. The\nfunction claimPartnerFee() still succeeds if called when there are 0 partners, but\npartnerClaimable0 and partnerClaimable1 are not zeroed."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-3-basev1pair-could-break-because-of-overflow-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    uint256 timeElapsed = blockTimestamp - blockTimestampLast;\n     // overflow is desired\n    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n      reserve0CumulativeLast += _reserve0 * timeElapsed;\n        reserve1CumulativeLast += _reserve1 * timeElapsed;\n     }\n"
    ],
    "Description": [
        "\nIn the function _update(), called internally by mint(), burn() and swap(), the following code\nis executed:",
        "This is forked from UniswapV2 source code, and it\u2019s meant and known to overflow. It works\nfine if solidity < 0.8.0 is used but reverts when solidity >= 0.8.0 is used.\nIf this happens all the core functionalities of the pool would break, including mint(), burn(),\nand swap()."
    ],
    "Recommended Mitigation": [
        "\nWrap the operation around an unchecked{} block so that when the variable overflows it\nloops back to 0 instead of reverting."
    ],
    "Team Response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has been resolved as suggested, the operation has been wrapped around an\nunchecked{} block"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-4-its-possible-to-dilute-rewards-per-second-in-gauge-and-internal-bribes-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    periodFinish[token] = block.timestamp + DURATION;\n"
    ],
    "Description": [
        "\nThe function notifyRewardAmount() is called to distribute new rewards to a gauge or an\ninternal bribe. In particular, it increases the duration over which the rewards have to be\ndistributed by DURATION every time it\u2019s called:",
        "Because of this an attacker could dilute the rewards per second received by bribes and\ngauges users by calling notifyRewardAmount() with a new reward of 1, extending the\nduration of the rewards that are currently being distributed thus lowering the rewards per\nsecond received by users."
    ],
    "Recommended mitigation": [
        "\nA mitigation that also have positive side-effects in lowering the attack surface is to restrict\naccess to the Gauge.sol and InternalBribe.sol notifyRewardAmount() functions:\n\u25cf Adjust notifyRewardAmount() in Gauge.sol to be only callable by SatinVoter.sol and\nthe trusted addresses responsible for sending $CASH rebases, if any.\n\u25cf Adjust notifyRewardAmount() in InternalBribe.sol to be only callable by the\nassociated gauge and Ve.sol."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation review": [
        "\nThe issue has been resolved as suggested but a new issue has been introduced, the function\nclaimFees() in Gauge.sol will fail when calling notifyRewardAmount() on InternalBribe.sol\nbecause SatinVoter.sol does not set the gauge parameter in the internal bribe when a new\ngauge is created via createGauge()."
    ],
    "Mitigation review 2": [
        "\nThe introduced issue has been fixed, now notifyRewardAmount() in Gauge.sol is only callable\nby SatinVoter.sol and the $CASH rebase handler while notifyRewardAmount() in\nInternalBribe.sol is only callable by Ve.sol and the associated gauge."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-5-creategauge4pool-lacks-proper-checks-andor-access-control-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    function createGauge4pool(\n       address _4pool,\n          address _dai,\n            address _usdc,\n               address _usdt,\n             address _cash\n       ) external returns (address) {\n"
    ],
    "Description": [
        "\nThe function createGauge4Pool() can be called by anybody at any time and is used to create\na Gauge for a special pool, the 4pool. It takes 5 parameters as inputs:"
    ],
    "_dai, _usdc, _usdt, _cash": [
        "None of the parameters are properly sanitized, meaning  could be\nany whitelisted token and not necessarily DAI, USDC, USDT, and cash while _4pool could\nbe any custom contract, including a malicious one.\nThe function also sets the variable FOUR_POOL_GAUGE_ADDRESS to the newly created gauge,\noverwriting the previous value."
    ],
    "Recommended Mitigation": [
        "\nMake the function only callable by an admin, and if it can be called multiple times, turn the\nvariable FOUR_POOL_GAUGE_ADDRESS to a mapping from address to boolean to support\nmultiple 4 pools."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has been resolved as suggested, createGauge4Pool() is now only callable by the\ncontract owner and FOUR_POOL_GAUGE_ADDRESS has been turned into a mapping,\nis4PoolGauge."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-6-_vote-doesnt-check-the-pool-a-user-is-voting-for-has-a-valid-gauge-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nThe function _vote() allows veSatin holders to vote to which pool the weekly emissions\nshould be redirected to but it doesn\u2019t check the pool a user is voting for has a gauge\nassociated, which could lead to emissions being lost."
    ],
    "Recommended Mitigation": [
        "\nEnsure that the pool a user is trying to vote for has a valid gauge before voting on it by\nchecking if isGauge[pool] it\u2019s true:"
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has been resolved as suggested, now the function _vote() skips the vote for pools\nthat don\u2019t have a valid associated gauge."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-7-its-possible-to-freely-detach-tokens-from-a-gauge-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nwithdrawToken() is a public function that takes as an input an amount and a tokenId. It then\nproceeds to detach the token from the gauge it\u2019s associated with and withdraw the amount.\nA user could pass 0 as an amount with the tokenId he wants to detach, which will withdraw\nnothing and detach the token. The function was meant to be called by withdraw() internally\nwhich only detaches the token if the full amount deposited is being withdrawn.\nIn addition to this, withdrawToken() doesn\u2019t emit the Withdraw event."
    ],
    "Recommended mitigation": [
        "\nMake withdrawToken() internal instead of public."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has been resolved as suggested, now withdrawToken() is declared as an internal\nfunction."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-8-calculation-of-the-new-emissions-amount-is-not-75255-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    uint _weekly = WEEKLY_EMISSION;\n         WEEKLY_EMISSION =(_weekly * _WEEKLY_EMISSION_DECREASE) / _WEEKLY_EMISSION_DECREASE_DENOMINATOR;\n    uint _growth = _calculateGrowth(_weekly);\n        uint _required = _growth + _weekly;\n",
        "        uint _required = _weekly;\n    // \u2026snippet\u2026\n           token.approve(address(_voter()), _weekly - _growth - _toTeam);\n    _voter().notifyRewardAmount(_weekly - _growth - _toTeam);\n"
    ],
    "Description": [
        "\nThe calculations of the emissions directed to SatinVoter.sol, VeDist.sol, and the treasury are\ndone on top of the weekly emissions instead as part of it, resulting in a different percentage\ndistribution. The calculations are as follows:"
    ],
    "growthDivider": [
        "Where ** is set to 20, toTreasuryDivider is set to 5 and _required is the total\namount of tokens that will be distributed. Let\u2019s suppose _weekly is 1000, _growth will be set\nto 50, _toTeam to 200, and _required to 1250. The distribution would result in 80% to\nSatinVoter.sol, 16% to the treasury, and 4% to VeDist.sol. This results in veSatin holders\nreceiving fewer rewards (in relative value) than voters."
    ],
    "Recommended mitigation": [
        "\nSet _required equal to _weekly and calculate the amount of emissions to send to\nSatinVoter.sol as the _weekly amount minus the emissions sent to treasury and VeDist.sol:"
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe issue has been resolved as suggested, now the calculations of the emissions are done as\npart of the weekly emissions amount instead of on top of it."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-9-users-have-to-lock-satincash-lp-in-vesol-to-vote-but-they-lose-on-fees-while-doing-so-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nTo get veSatin tokens and be able to vote users are expected to lock Satin/$CASH LP in\nVe.sol. When this happens, Ve.sol will start accumulating the fees deriving from the\nSatin/$CASH pool but there is no way for users to collect them, unlike in Gauge.sol. This has\nthe effect of having fees locked in Ve.sol and can disincentivize users from locking their LP in\nthe system."
    ],
    "Recommended mitigation": [
        "\nAdd functionality that allows users to withdraw the fees deriving from the LP they locked\nlike it\u2019s done in Gauge.sol. Another option is to have an admin function that can collect the\nfees."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe proposed fix adds the function claimFees() to Ve.sol, which collects the accumulated\nfees from the Satin/$CASH pool and transfers them to the associated bribe. The fees\ndestined to a bribe can only be claimed by users that voted for the pool associated with that\nbribe, the Satin/$CASH pool in this scenario. This means that even if the fees are generated\nby the Satin/$CASH LP locked by every user, they can only be claimed by the subset that\nvoted for the Satin/$CASH pool."
    ],
    "Mitigation Review 2": [
        "\nThe team acknowledges the issue raised by the mitigation review as intended behavior."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-10-updateperiod-distributes-the-same-amount-of-emissions-regardless-of-the-time-passed-from-the-last-distribution-trust-security-none-satinexchange-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        _period = (block.timestamp / _WEEK) * _WEEK;\n           uint sinceLast = _period - activePeriod;\n         uint emissionsMultiplier = sinceLast / _WEEK;\n      uint _weekly = WEEKLY_EMISSION * emissionsMultiplier;\n"
    ],
    "Description": [
        "\nThe function updatePeriod() distributes new rewards when it\u2019s called more than one week\nafter the last distribution. However, if a distribution only happens after two weeks or more,\nthe distributed amount is the same as if only one week passed. This can lead to users\nearning fewer rewards than they would expect."
    ],
    "Recommended mitigation": [
        "\nAdjust the amount of emissions to the amount of full weeks passed since the last\ndistribution."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe proposed fix multiplies the current amount of WEEKLY_EMISSION by the number of\nwhole weeks (periods) passed since the last activePeriod, but the number of emissions\nshould decrease by a percentage for every period passed.\nAs an example, if 3 periods passed from the last call to updatePeriod() and\nWEEKLY_EMISSION is set to 1000 SATIN, then the amount of emissions would be calculated\nas 1000 * 3 = 3000 SATIN:",
        "However because every period the emissions should decrease by 2% the total amount\nshould be 1000 + 1000 * (98/100) + 1000 * (98/100)^2 = 2940 SATIN"
    ],
    "Mitigation Review 2": [
        "\nThe issue introduced by the fix has been resolved as suggested."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-1-more-than-one-hat-of-the-same-hatid-can-be-assigned-to-a-user-trust-security-none-hats-protocol-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        /// @notice Internal call to mint a Hat token to a wearer\n        /// @dev Unsafe if called when `_wearer` has a non-zero balance of `_hatId`\n        /// @param _wearer The wearer of the Hat and the recipient of the  newly minted token\n        /// @param _hatId The id of the Hat to mint\n        function _mintHat(address _wearer, uint256 _hatId) internal {\n            unchecked {\n        // should not overflow since `mintHat` enforces max balance of 1\n            _balanceOf[_wearer][_hatId] = 1;\n        // increment Hat supply counter\n        // should not overflow given AllHatsWorn check in `mintHat` ++_hats[_hatId].supply;\n        }\n        emit TransferSingle(msg.sender, address(0), _wearer, _hatId, 1);\n        }\n",
        "        function mintHat(uint256 _hatId, address _wearer) public returns (bool) {\n        Hat memory hat = _hats[_hatId];\n            if (hat.maxSupply == 0) revert HatDoesNotExist(_hatId);\n        // only the wearer of a hat's admin Hat can mint it\n             _checkAdmin(_hatId);\n            if (hat.supply >= hat.maxSupply) {\n                 revert AllHatsWorn(_hatId);\n                     }\n        if (isWearerOfHat(_wearer, _hatId)) {\n                revert AlreadyWearingHat(_wearer, _hatId);\n                      }\n        _mintHat(_wearer, _hatId);\n             return true;\n                  }\n"
    ],
    "Description": [
        "\nHats are minted internally using _mintHat()."
    ],
    "_wearer": [
        "The function validates  doesn't currently wear the hat, but its balance could still be\nover 0, if the hat is currently toggled off or the wearer is not eligible.\nThe impact is that the hat supply is forever spent, while nobody actually received the hat.\nThis could be used maliciously or occur by accident. When the hat is immutable, the max\nsupply can never be corrected for this leak. It could be used to guarantee no additional,\nunfriendly hats can be minted to maintain permanent power."
    ],
    "Recommended Mitigation": [
        "\nInstead of checking if user currently wears the hat, check if its balance is over 0."
    ],
    "Team response": [
        "\nAccepted."
    ],
    "Mitigation review": [
        "\nFixed by checking the static hat balance of wearer."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-2-txs-can-be-executed-by-less-than-the-minimum-required-signatures-trust-security-none-hats-protocol-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        uint256 safeOwnerCount = safe.getOwners().length;\n             if (safeOwnerCount < minThreshold) {\n                 revert BelowMinThreshold(minThreshold, safeOwnerCount);\n        }\n",
        "           uint256 validSigCount = countValidSignatures(txHash, signatures, signatures.length / 65);\n        // revert if there aren't enough valid signatures\n             if (validSigCount < safe.getThreshold()) {\n              revert InvalidSigners();\n                  }\n"
    ],
    "Description": [
        "\nIn HatsSignerGateBase, checkTransaction() is the function called by the Gnosis safe to\napprove the transaction. Several checks are in place."
    ],
    "minThreshold": [
        "The first check is that the number of owners registered on the safe is at least .\nThe second check is that the number of valid signatures (wearers of relevant hats) is not\nbelow the safe's threshold. However, it turns out these requirements are not sufficient. A\npossible situation is that there are plenty of owners registered, but currently most do not\nwear a hat. reconcileSignerCount() could be called to reduce the safe's threshold to the\ncurrent validSigCount, which can be below . That would make both the first\nand second check succeed. However,  is defined to be the smallest number of\nsigners that must come together to make a TX. The result is that a single signer could\nexecute a TX on the safe, if the other signers are not wearers of hats (for example, their\ntoggle has been temporarily set off in the case of multi-hat signer gate."
    ],
    "Recommended Mitigation": [
        "\nAdd another check in checkTransaction(), which states that validSigCount >= minThreshold."
    ],
    "Team Response": [
        "\nAccepted."
    ],
    "Mitigation review": [
        "\nFixed"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-3-target-signature-threshold-can-be-bypassed-leading-to-minority-txs-trust-security-none-hats-protocol-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        uint256 validSigCount = countValidSignatures(txHash, signatures, signatures.length / 65);\n                // revert if there aren't enough valid signatures\n        if (validSigCount < safe.getThreshold()) {\n                     revert InvalidSigners();\n         }\n"
    ],
    "Description": [
        "\ncheckTransaction() is the enforcer of the HSG logic, making sure signers are wearers of hats\nand so on. The check below makes sure sufficient hat wearers signed the TX:"
    ],
    "targetThreshold": [
        "The issue is that the safe's threshold is not guaranteed to be up to date. For example,\ninitially there were 5 delegated signers. At some point, three lost eligibility.\nreconcileSignerCount() is called to update the safe's threshold to now have 2 signers. At a\nlater point, the three signers which lost eligibility regained it. At this point, the threshold is\nstill two, but there are 5 valid signers, so if  is not below 5, they should all\nsign for a TX to be executed. That is not the case, as the old threshold is used. There are\nvarious scenarios which surface the lack of synchronization between the wearer status and\nsafe's stored threshold."
    ],
    "Recommended Mitigation": [
        "\nCall reconcileSignerCount() before the validation code in checkTransaction()."
    ],
    "Team response": [
        "\nFixed"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-4-maxsigners-can-be-bypassed-trust-security-none-hats-protocol-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        function claimSigner() public virtual {\n             if (signerCount == maxSigners) {\n                revert MaxSignersReached();\n        }\n        if (safe.isOwner(msg.sender)) {\n                revert SignerAlreadyClaimed(msg.sender);\n            }\n        if (!isValidSigner(msg.sender)) {\n             revert NotSignerHatWearer(msg.sender);\n         }\n         _grantSigner(msg.sender);\n           }\n",
        "    address[] memory owners = safe.getOwners();\n         uint256 ownerCount = owners.length;\n    if (ownerCount >= maxSigs) {\n        _swapSigner(owners, ownerCount, maxSigs, currentSignerCount, msg.sender);\n    } else {\n        _grantSigner(owners, currentSignerCount, msg.sender);\n        }\n"
    ],
    "Description": [
        "\nmaxSigners is specified when creating an HSG and is left constant. It is enforced in two ways\n\u2013targetThreshold may never be set above it, and new signers cannot register to the HSG\nwhen the signer count reached maxSigners. Below is the implementation code in\nHatsSignerGate."
    ],
    "signerCount": [
        "An issue that arises is that this doesn't actually limit the number of registered signers.\nIndeed,  is a variable that can fluctuate when wearers lose eligibility or a hat is\ninactive. At this point, reconcileSignerCount() can be called to update the  to the\ncurrent valid wearer count. A simple attack which achieves unlimited claims is as follows:"
    ],
    "maxSigners": [],
    "Recommended Mitigation": [
        "\nThe root cause is that users which registered but lose their hat are still stored in the safe's\nowners array, meaning they can always get re-introduced and bump the signerCount.\nInstead of checking the signerCount, a better idea would be to compare with the list of\nowners saved on the safe. If there are owners that are no longer holders, removeSigner() can\nbe called to vacate space for new signers."
    ],
    "Team response": [
        "\nAccepted; added a swapSigner() flow to claimSigner()."
    ],
    "Mitigation review": [
        "\nFixed but introduced a new issue. The new code will swap the new signer with an invalid old\nsigner.",
        "However, it's possible that all current owners are valid signers, in this case _swapSigner() will\ncomplete the loop and return gracefully. A user will think they have claimed signer\nsuccessfully, but nothing has changed."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-5-minority-may-be-able-to-call-safe-operations-trust-security-none-hats-protocol-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        function reconcileSignerCount() public {\n            address[] memory owners = safe.getOwners();\n                 uint256 validSignerCount = _countValidSigners(owners);\n        // update the signer count accordingly\n        signerCount = validSignerCount;\n        if (validSignerCount <= targetThreshold && validSignerCount != safe.getThreshold())\n             {\n        bytes memory data =  abi.encodeWithSignature(\"changeThreshold(uint256)\", validSignerCount);\n        bool success = safe.execTransactionFromModule(\n        address(safe), // to 0, \n        // value data, // data\n        Enum.Operation.Call // operation\n        );\n        if (!success) {\n                   revert FailedExecChangeThreshold();\n                }\n             }\n         }\n"
    ],
    "Description": [
        "\nUsers can update the HSG's view of signers using reconcileSignerCount()"
    ],
    "validSignerCount": [
        "Notice that the safe's registered threshold is only updated if the new  is\nlower than the targetThreshold. Actually, that is not desired behavior, because if signers\nhave reactivated or have become eligible again, it's possible this condition doesn't hold, and\nthe previous threshold could be lower than targetThreshold. In this scenario, a small\nminority could still execute TXs when targetThreshold signatures are needed"
    ],
    "Recommended mitigation": [
        "\nAdd an else clause, stating that if the new validSignerCount > targetThreshold and\nsafe.getThreshold() < targetThreshold, the threshold changes to targetThreshold."
    ],
    "Team response": [
        "\nAccepted."
    ],
    "Mitigation review": [
        "\nFixed by restructuring conditions in reconcileSignerCount()"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-1-hats-token-breaks-erc1155-specifications-trust-security-none-hats-protocol-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nThe Hats token implements ERC1155 (https://eips.ethereum.org/EIPS/eip-1155). It implements safeTransferFrom() and\nbatchSafeTransferFrom() as revert-only functions, so tokens cannot be transferred using\nstandard ERC1155 means. However, hats can still be transferred using mintHat(),\nmintTopHat() and transferHat(). Whenever there is a transfer, the standard requires\nchecking the receiver accepts the transfer:\n\"If an implementation specific API function is used to transfer ERC-1155\ntoken(s) to a contract, the safeTransferFrom or safeBatchTransferFrom (as\nappropriate) rules MUST still be followed if the receiver implements\nthe ERC1155TokenReceiver interface. If it does not the non-standard\nimplementation SHOULD revert but MAY proceed.\"\nBy not checking a contract receiver accepts the transfer, Hats token does not adhere to\nERC1155."
    ],
    "Recommended Mitigation": [
        "\nIf the recipient implements ERC1155TokenReceiver, require that it accepts the transfer. If\nthe recipient is a contract that does not implement a receiver, reject the operation."
    ],
    "Team Response": [
        "\nAcknowledged; changed documentation to ERC1155-similar and to explicitly clarify that Hats\nimplements the ERC1155 interface but does not conform to the full standard."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-2-attacker-can-dos-minting-of-new-top-hats-in-low-fee-chains-trust-security-none-hats-protocol-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "          // uint32 lastTopHatId will overflow in brackets\n             topHatId = uint256(++lastTopHatId) << 224;\n"
    ],
    "Description": [
        "\nIn Hats protocol, anyone can be assigned a top hat via the mintTopHat() function. The top\nhats are structured with top 32 bits acting as a domain ID, and the lower 224 bits are\ncleared. There are therefore up to 2^32 = ~ 4 billion top hats. Once they are all consumed,\nmintTopHat() will always fail:",
        "This behavior exposes the project to a DOS vector, where an attacker can mint 4 billion top\nhats in a loop and make the function unusable, forcing a redeploy of Hats protocol. This is\nunrealistic on ETH mainnet due to gas consumption, but definitely achievable on the\ncheaper L2 networks. As the project will be deployed on a large variety of EVM blockchains,\nthis poses a significant risk."
    ],
    "Recommended Mitigation": [
        "\nRequire a non-refundable deposit fee (paid in native token) when minting a top hat. Price it\nso that consuming the 32-bit space will be impossible. This can also serve as a revenue\nstream for the Hats project."
    ],
    "Team Response": [
        "\nAcknowledged; electing not to address in v1 for several reasons:"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-3-linking-of-hat-trees-can-freeze-hat-operations-trust-security-none-hats-protocol-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        /// @notice Identifies the level a given hat in its hat tree\n        /// @param _hatId the id of the hat in question\n        /// @return level (0 to type(uint8).max)\n     function getHatLevel(uint256 _hatId) public view returns (uint8) {\n",
        "        if (treeAdmin != 0) {\n                 return 1 + uint8(i) + getHatLevel(treeAdmin);\n            }\n"
    ],
    "Description": [
        "\nHats support tree-linking, where hats from one node link to the first level of a different\ndomain. This way, the amount of levels for the linked-to tree increases by the linked-from\nlevel count. This is generally fine, however lack of checking of the new total level introduces\nsevere risks.",
        "The getHatLevel() function can only return up to level 255. It is used by the checkAdmin() call\nused in many of the critical functions in the Hats contract. Therefore, if for example, 17 hat\ndomains are joined together in the most stretched way possible, It would result in a correct\nhat level of 271, making this calculation revert:",
        "The impact is that intentional or accidental linking that creates too many levels would freeze\nthe higher hat levels from any interaction with the contract."
    ],
    "Recommended Mitigation": [
        "\nIt is recommended to add a check in _linkTopHatToTree(), that the new accumulated level\ncan fit in uint8. Another option would be to change the maximum level type to uint32."
    ],
    "Team Response": [
        "\nAccepted; increased max level type to uint32."
    ],
    "Mitigation review": [
        "\nFixed."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-4-admin-can-transfer-hat-to-a-non-eligible-target-potentially-burning-the-hat-trust-security-none-hats-protocol-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        // Check if recipient is already wearing hat; also checks storage to  maintain balance == 1 invariant\n        if (_balanceOf[_to][_hatId] > 0) {\n            revert AlreadyWearingHat(_to, _hatId);\n         }\n"
    ],
    "Description": [
        "\nHat admins may transfer child hats using transferHat(). It checks the hat receiver does not\ncurrently have a balance for this hatId."
    ],
    "hatId": [
        "The issue is that it does not also check that the recipient is eligible for the . Therefore,\nan admin could transfer a hat and then it could be immediately burnt by anyone using the\ncheckHatWearerStatus() call."
    ],
    "Recommended mitigation": [
        "\nVerify the recipient is eligible for the hatId before transferring it"
    ],
    "Team response": [
        "\nAccepted."
    ],
    "Mitigation review": [
        "\nFixed"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-5-attacker-can-make-a-signer-gate-creation-fail-trust-security-none-hats-protocol-markdown
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    bytes memory initializeParams = abi.encode(_ownerHatId, _signersHatId, _safe, hatsAddress, _minThreshold, \n    _targetThreshold, _maxSigners, version );\n        hsg = moduleProxyFactory.deployModule(hatsSignerGateSingleton, abi.encodeWithSignature(\"setUp(bytes)\", \n    initializeParams), _saltNonce );\n",
        "    proxy = createProxy( masterCopy, keccak256(abi.encodePacked(keccak256(initializer), saltNonce)) );\n",
        "        function createProxy(address target, bytes32 salt)  internal  returns (address result)\n        {\n            if (address(target) == address(0)) revert ZeroAddress(target);\n            if (address(target).code.length == 0) revert \n        TargetHasNoCode(target);\n                bytes memory deployment = abi.encodePacked(\n                  hex\"602d8060093d393df3363d3d373d3d3d363d73\", target, hex\"5af43d82803e903d91602b57fd5bf3\" );\n            // solhint-disable-next-line no-inline-assembly\n                assembly {\n                     result := create2(0, add(deployment, 0x20), \n        mload(deployment), salt)\n              }\n                  if (result == address(0)) revert TakenAddress(result);\n             }\n"
    ],
    "Description": [
        "\nDAOs can deploy a HSG using deployHatsSignerGateAndSafe() or\ndeployMultiHatsSignerGateAndSafe().The parameters are encoded and passed to\nmoduleProxyFactory.deployModule():",
        "This function will call createProxy():",
        "The second parameter is the generated salt, which is created from the initializer and passed\nsaltNonce. Finally createProxy() will use CREATE2 to create the contract:",
        "An issue could be that an attacker can frontrun the creation TX with their own creation\nrequest, with the same parameters. This would create the exact address created by the\nCREATE2 call, since the parameters and therefore the final salt will be the same. When the\nvictim's transaction would be executed, the address is non-empty so the EVM would reject\nits creation. This would result in a bad UX for a user, who thinks the creation did not\nsucceed. The result contract would still be usable, but would be hard to track as it was\ncreated in another TX."
    ],
    "Recommended Mitigation": [
        "\nUse an ever-increasing nonce counter to guarantee unique contract addresses."
    ],
    "Team response": [
        "\nAccepted."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-6-signers-can-backdoor-the-safe-to-execute-any-transaction-in-the-future-without-consensus-trust-security-none-hats-protocol-markdown
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        function checkAfterExecution(bytes32, bool) external override {\n            if (abi.decode(StorageAccessible(address(safe)).getStorageAt(uint256(GUARD_STORAGE_SLOT), 1), (address))\n                    != address(this)) \n                    {\n                revert CannotDisableThisGuard(address(this));\n            }\n            if (!IAvatar(address(safe)).isModuleEnabled(address(this))) {\n                    revert CannotDisableProtectedModules(address(this));\n            }\n            if (safe.getThreshold() != _correctThreshold()) {\n                     revert SignersCannotChangeThreshold();\n            }\n            // leave checked to catch underflows triggered by re-erntry\n        attempts\n            --guardEntries;\n        }\n"
    ],
    "Description": [
        "\nThe function checkAfterExecution() is called by the safe after signer's request TX was\nexecuted (and authorized). It mainly checks that the linkage between the safe and the HSG\nhas not been compromised.",
        "However, it is missing a check that no new modules have been introduced to the safe. When\nmodules execute TXs on a Gnosis safe, the guard safety callbacks do not get called. As a\nresult, any new module introduced is free to execute whatever it wishes on the safe. It\nconstitutes a serious backdoor threat and undermines the HSG security model."
    ],
    "Recommended Mitigation": [
        "\nCheck that no new modules have been introduced to the safe, using the\ngetModulesPaginated() utility."
    ],
    "Team response": [
        "\nAccepted; added a method for HSG owner to add modules, and an enabled modules counter\nto check against in checkAfterTransaction()"
    ],
    "Mitigation review": [
        "\nFix is not bulletproof. A malicious transaction can remove an existing module and replace it\nwith their own malicious module. In addition to a length check on the modules array, it is\nnecessary to do a full comparison before and after the TX execution."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-7-hats-cant-be-renounced-when-not-worn-leading-to-abuse-concerns-trust-security-none-hats-protocol-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nHats can be renounced by the owner using renounceHat() call. They can only be renounced\nwhen currently worn, regardless if they have a positive balance. Issues can arise from abuse\nby toggle or eligibility delegates. They can temporarily disable or sanction the wearer so\nthat it cannot be renounced. At a later point, when the wearer is to be made accountable for\ntheir responsibilities, they could be toggled back on and penalize an innocent hat wearer."
    ],
    "Recommended mitigation": [
        "\nAllow hats to be renounced even when they are not worn right now. A different event\nparameter can be used to display if they were renounced while worn or not"
    ],
    "Team response": [
        "\nAccepted."
    ],
    "Mitigation review": [
        "\nFixed by applying the suggested mitigation."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-8-safety-checks-compare-safes-threshold-with-a-stale-value-trust-security-none-hats-protocol-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nIn HatsSignerGateBase, _correctThreshold() calculates what the safe's threshold should be.\nHowever, it uses signerCount without updating it by calling reconcileSignerCount().\nTherefore, in checkAfterExecution(), the safe's current threshold will be compared to potentially the wrong value. This may trip valid transactions or allow malicious ones to go\nthrough, where the threshold should end up being higher."
    ],
    "Recommended mitigation": [
        "\nCall reconcileSignerCount() before making use of the signerCount value."
    ],
    "Team response": [
        "\nAccepted; added _countValidSigners() rather than reconcileSignerCount()."
    ],
    "Mitigation review": [
        "\nFixed."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-1-operator-can-spoof-query-fees-to-make-net-profit-from-pool-trust-security-none-the-graph-operator-decentralization-markdown
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nOperators call collect() to pay query fees to the indexer. The fees are accumulated for all allocations that end in the same epoch in a Rebates.Pool structure, later to be split per indexer using the Cobb-Douglas production function.\nThis fee structure should be resistant to query fee donations that:\n\u2981\tLower another indexer's total rebate amount\n\u2981\tResult in a net positive for the donator (query fee MEV)\nHowever, stress testing of the function found that guarantee 2 is not held. Operators, which are transitioning to be a decentralized role, can fake queries and increase their portion of the pool. This does not directly harm other indexers, because their share of the pool increases as well. However, the share of the rebate pool that stays in the protocol decreases.\nAn example is provided below. The rewards per indexer are calculated as follows:",
        "\ud835\udc5f\ud835\udc52\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51(i) = totalRewards * (fee/totalFees)^\ud835\udefc * (stake/totalStake)^1-\ud835\udefc",
        "Suppose \ud835\udefc = 0.4523, and the layout of pool participants is as follows:",
        "The calculated rewards are:\n\ud835\udc5f\ud835\udc52\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51(1) = 1305 \u2217 ( 511/1305 )^0.4523 \u2217 ( 515/516 )^1\u22120.4523 \u2245 853",
        "r\ud835\udc52\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51(2) = 1305 \u2217 ( 794/1305 )^0.4523 \u2217 ( 1/516 )^1\u22120.4523 \u2245 34",
        "Fees of the rebate pool not rewarded:\nr\ud835\udc52\ud835\udc5a\ud835\udc4e\ud835\udc56\ud835\udc5b\ud835\udc56\ud835\udc5b\ud835\udc54 = 1305 \u2212 853 \u2212 34 = 418\nAt this point, participant 1 donates 720. The new layout is:",
        "The calculated rewards are:",
        "r\ud835\udc52\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51(1) = 2025 \u2217 ( 1231/1305 )^0.4523 \u2217 ( 515/516 )^1\u22120.4523 \u2245 1615",
        "r\ud835\udc52\ud835\udc64\ud835\udc4e\ud835\udc5f\ud835\udc51(2) = 2025 \u2217 ( 794/1305 )^0.4523 \u2217 ( 1/516 )^1\u22120.4523 \u2245 43",
        "Fees of the rebate pool not rewarded:\n\ud835\udc5f\ud835\udc52\ud835\udc5a\ud835\udc4e\ud835\udc56\ud835\udc5b\ud835\udc56\ud835\udc5b\ud835\udc54 = 2025 \u2212 1615 \u2212 43 = 367",
        "Calculating pool loss (of profits) from donation:\n\ud835\udc59\ud835\udc5c\ud835\udc60\ud835\udc60 = 418 \u2212 367 = 51",
        "Profit was split between the participants:",
        "\ud835\udc5d\ud835\udc5f\ud835\udc5c\ud835\udc53\ud835\udc56\ud835\udc61(1) = 1615 \u2212 720 \u2212 853 = 42",
        "\ud835\udc5d\ud835\udc5f\ud835\udc5c\ud835\udc53\ud835\udc56\ud835\udc61(2) = 43 \u2212 34 = 9",
        "Attackers can donate query fees at any point before the allocation is finalized, which is when\na certain number of epochs have passed since it was closed. This means in the final block\nthere will be incentives for large amounts of MEV activity of the different participants, to the\nloss of the protocol.\nA python script that fuzzes the Cobb-Douglas formula has been provided separately."
    ],
    "Recommended Mitigation": [
        "\nConsider making use of a different awarding formula, which would disincentivize forging of\nquery activities."
    ],
    "Team Response": [
        "\nAcknowledged. There is ongoing economic research on alternatives to Cobb-Douglas, but for\nnow we think this is an acceptable consequence of decentralizing gateways."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-1-canhedge-may-return-wrong-result-when-there-is-a-pending-position-request-trust-security-none-lyra-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nLyra\u2019s security model relies on being able to hedge and achieve delta-neutrality when opening\na user position. The check is done in canHedge() in GMXFuturesPoolHedger. The current\nhedge is calculated using _getCurrentHedgedNetDeltaWithSpot(). However, this function only\ntakes the current position and ignores the pending increase/decrease position request.\nTherefore, canHedge result can be wrong - users may be rejected from interacting with the\nmarket, while attackers or innocent users may put the protocol in an unchangeable position."
    ],
    "Recommended Mitigation": [
        "\nIncluding the pending position in the current hedge calculation."
    ],
    "Team response": [
        "\nWhile this is a valid issue, canHedge is an added safety rail rather than a critical component\nof the system. Unwanted option positions being opened to expose LPs to unwanted delta risk\nwill cost attackers the fees to open option positions and all they achieve is exposing LPs to\nsome limited directional/delta risk. Adding additional complexity to an already complex\nsystem feels unnecessary at this stage so this will not be implemented."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-2-canhedge-will-return-true-when-hedging-requirement-would-be-above-the-defined-hedgecap-trust-security-none-lyra-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nLyra\u2019s security model relies on being able to hedge and achieve delta-neutrality when opening\na user position. The check is done in canHedge() in GMXFuturesPoolHedger. The expected\nhedge is fetched using _getCappedExpectedHedge(). However, it is never checked that the\nhedge has reached capacity, which should disqualify the hedge from taking place. Any hedge\nabove the cap will never be hedged, so whenever canHedge() wrongly approves a hedge that\nis beyond the cap, the protocol will be guaranteed not to be delta-neutral."
    ],
    "Recommended Mitigation": [
        "\nIf expectedHedge is, in absolute value, equal to the hedgeCap, return false"
    ],
    "Team Response": [
        "\nThis is more a design choice than an issue. To account for all cases (as in the flagged issue) an\nadditional parameter would need to be added to allow opening above the cap which is the\ncurrent intended design."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-3-disordered-fee-calculated-causes-collateral-changes-to-be-inaccurate-trust-security-none-lyra-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "      if (isLong) {\n          uint swapFeeBP = getSwapFeeBP(isLong, true, collateralDelta);\n           collateralDelta = (collateralDelta * (BASIS_POINTS_DIVISOR + swapFeeBP)) / BASIS_POINTS_DIVISOR;\n      }\n      // add margin fee\n      // when we increase position, fee always got deducted from collateral\n          collateralDelta += _getPositionFee(currentPos.size, sizeDelta, currentPos.entryFundingRate);\n"
    ],
    "Description": [
        "\n_increasePosition() changes the Hedger\u2019s GMX position by sizeDelta amount and\ncollateralDelta collateral. There are two collateralDelta corrections - one for swap fees and\none for position fees. Since the swap fee depends on up-to-date collateralDelta, it\u2019s important\nto calculate it after the position fee, contrary to the current state. In practice, it may lead to\nthe leverage ratio being higher than intended as collateralDelta sent to GMX is lower than it\nshould be."
    ],
    "Recommended Mitigation": [
        "\nFlip the order of getSwapFeeBP() and _getPositionFee()."
    ],
    "Team response": [
        "\nFixed"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-1-small-lp-providers-may-be-unable-to-withdraw-their-deposits-trust-security-none-lyra-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "      if (withdrawalValue < lpParams.minDepositWithdraw && \n          amountLiquidityToken < lpParams.minDepositWithdraw) {\n      revert MinimumWithdrawNotMet(address(this), withdrawalValue, lpParams.minDepositWithdraw);\n      }\n"
    ],
    "Description": [
        "\nIn LiquidityPool\u2019s initiateWithdraw(), it\u2019s required that withdrawn value is above a minimum\nparameter, or that withdrawn tokens is above the minimum parameter."
    ],
    "minDepositWithdraw": [
        "The issue is that  is measured in dollars while amountLiquidityToken is\nLP tokens. The intention was that if LP tokens lost value and a previous deposit is now worth\nless than , it would still be withdrawable. However, the current\nimplementation doesn\u2019t check for that correctly, since the LP to dollar exchange rate at\ndeposit time is not known, and is practically being hardcoded as 1:1 here. The impact is that\nusers may not be able to withdraw LP with the token amount that was above the minimum at\ndeposit time, or vice versa"
    ],
    "Recommended Mitigation": [
        "\nConsider calculating an average exchange rate at which users have minted and use it to verify\nwithdrawal amount is satisfactory."
    ],
    "Team Response": [
        "\nWhile valid, the proposed solution adds far more complexity to the system than the benefit it\nwould provide. Small (<$1) LPs will need to find an alternative place to liquidate their holdings\nlike a uniswap pool. This will not be resolved at the protocol level.\nAs keepers process deposits and withdrawals, the minimums are necessary to prevent\nunwanted spam."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-2-shortcollateral-settleoptions-may-fail-due-to-insolvency-settled-out-of-loop-trust-security-none-lyra-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nsettleOptions() loops over the input positionIds array and either sends proceeds to the user\nor consumes their collateral. If there\u2019s any insolvency, it is appended to\nbaseInsolventAmount/quoteInsolventAmount. Only after the settlement loop is the entire\ninsolvent portion claimed from the liquidity pool. The issue is that delaying the insolvency\ncollection may cause ShortCollateral to have insufficient funds to pay for user proceeds."
    ],
    "Recommended Mitigation": [
        "\nInsert _reclaimInsolvency() call to the end of the for loop."
    ],
    "Team Response": [
        "\nNot really an issue if insolvent positions are settled in a separate transaction prior to solvent\npositions. Keepers can easily handle this situation. As insolvent positions are very rare (0 in all\nof the 6 months of the Avalon release) no changes to this logic seem appropriate."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-3-base-to-quote-swaps-trust-gmx-provided-minprice-and-maxprice-to-be-correct-which-may-be-manipulated-trust-security-none-lyra-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    uint tokenInPrice = _getMinPrice(address(baseAsset));\n        uint tokenOutPrice = _getMaxPrice(address(quoteAsset));\n    ...\n    uint minOut = tokenInPrice\n      .multiplyDecimal(marketPricingParams[_optionMarket].minReturnPercent)\n        .multiplyDecimal(_amountBase)\n          .divideDecimal(tokenOutPrice);\n"
    ],
    "Description": [
        "\nexchangeFromExactBase() in GMXAdapter converts an amount of base to quote. It\nimplements slippage protection by using the GMX vault\u2019s getMinPrice() and getMaxPrice()\nutilities. However, such protection is insufficient because GMX prices may be manipulated.\nIndeed, GMX supports \u201cAMM pricing\u201d mode where quotes are calculated from Uniswap\nreserves. A possible attack would be to drive up the base token (e.g. ETH) price, sell a large\nETH amount to the GMXAdapter, and repay the flashloan used for manipulation.\nexchangeFromExactBase() is attacker-reachable from LiquidityPool\u2019s exchangeBase()."
    ],
    "Recommended Mitigation": [
        "\nVerify getMinPrice(), getMinPrice() outputs are close to Chainlink-provided prices as done in\ngetSpotPriceForMarket()."
    ],
    "Team Response": [
        "\nFixed for exchangeFromExactBase() here, by using Chainlink price instead of gmxMinPrice of\nbaseAsset. This way if the price is favorable for the LPs (given they rely on CL) it will not revert."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-4-sendallfundstolp-does-not-handle-popular-erc20-tokens-like-bnb-trust-security-none-lyra-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    if (baseBal > 0) {\n       if (!baseAsset.transfer(address(liquidityPool), baseBal)) {\n    revert AssetTransferFailed(address(this), baseAsset, baseBal, \n         address(liquidityPool));\n     }\n    emit BaseReturnedToLP(baseBal);\n"
    ],
    "Description": [
        "\nsendAllFundsToLP() is used to transfer quote and base tokens to the LP after interaction with\nGMX. It uses an unsafe transfer call:",
        "There are a great many tokens such as BNB and USDT that for historical reasons, don\u2019t return\na value in transfer(). Since Lyra aims to support blue-chip tokens, it should refactor and use\nthe safe transfer variant."
    ],
    "Recommended mitigation": [
        "\nUse Open Zeppelin\u2019s SafeERC20 encapsulation of ERC20 transfer functions."
    ],
    "Team response": [
        "\nUSDT/BNB will not be supported for this set of contracts. Tokens supported will be limited to\nonly those that do not return boolean values."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-5-recoverfunds-does-not-handle-popular-erc20-tokens-like-bnb-trust-security-none-lyra-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "  if (token == quoteAsset || token == baseAsset || token == weth) {\n      revert CannotRecoverRestrictedToken(address(this));\n    }\n        token.transfer(recipient, token.balanceOf(address(this)));\n"
    ],
    "Description": [
        "\nrecoverFunds() is used for recovery in case of mistakenly-sent tokens. However, it uses unsafe\ntransfer to send tokens back, which will not support 100s of non-compatible ERC20 tokens.\nTherefore it is likely unsupported tokens will be unrecoverable."
    ],
    "Recommended Mitigation": [
        "\nUse Open Zeppelin\u2019s SafeERC20 encapsulation of ERC20 transfer functions."
    ],
    "Team response": [
        "\nThis function exists purely as an additional recovery mechanism that should never really be\nused - it is not core to the functionality of the protocol. Will not be changed at this stage."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-6-option-board-will-be-settled-with-incorrect-prices-when-settled-after-a-delay-trust-security-none-lyra-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nsettleExpiredBoard() runs after a board expires to perform accounting. It uses\ngetSettlementPriceForMarket() to get the settlement price, which simply returns the current\nprice. It does not account for the possibility that the function was called after some delay, and\nthat the current price does not reflect the option\u2019s expiry value. This situation could arise from\nmany different reasons. For example, keepers may have been offline, or the network was\nhalted for some time."
    ],
    "Recommended Mitigation": [
        "\nOnly accept the spot price if the time elapsed since expiry is smaller than some parameter.\nOtherwise, update the settlement value using a gov-only function."
    ],
    "Team response": [
        "\nThis is more a design choice. The first seen spot price after a large outage feels like a better\nalternative than to rely on a centralized source for the settlement price."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-7-attackers-can-delay-or-disrupt-hedging-activity-by-abusing-mutual-exclusion-with-updatecollateral-trust-security-none-lyra-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nhedgeDelta() is the engine behind the PoolHedger.sol used to offset exposure.\nGMX increase / decrease position requests are performed in two steps to minimize slippage attacks. Firstly,\nusers call increasePositionRequest(). Every short period (usually several seconds), GMX keeper\nwill execute all requests in a batch. The PoolHedger deals with this pending state using the\npendingOrderKey parameter. When it is not 0, it is the key received from the last GMX\nposition request. When there is a pending action, hedgeDelta() as well as updateCollateral()\ncannot be called. The latter function is another permissionless entry point, which triggers the\ncorrection of the leverage ratio on GMX to the target. The issue stems from the fact there are\nno DOS-preventions put in place, which allow attackers to continually call updateCollateral()\nas soon as the previous request completes, keeping the Hedger ever busy perfecting the\nleverage ratio, albeit not hedging properly. If done for a long enough period, the impact is an\nincreased insolvency risk for the protocol as it is not delta-neutral."
    ],
    "Recommended mitigation": [
        "\nOne option is to make sure the delta correction is significant for it to succeed, preventing the\nDOS. Another option is to refactor the code to have only one entry point. This will guarantee\nthe prioritization of delta-neutrality over reaching the target leverage ratio."
    ],
    "Team response": [
        "\nFixed"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-8-protectedquote-can-be-manipulated-by-calling-processdepositqueue-when-large-price-moves-in-base-asset-occur-trust-security-none-lyra-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "       protectedQuote = (liquidity.NAV - withdrawalValue).multiplyDecimal(\n       DecimalMath.UNIT - lpParams.adjustmentNetScalingFactor\n      );\n"
    ],
    "Description": [
        "\nThe protectedQuote storage variable ensures that a portion of the liquidity pool is preserved\neven in the case of a \u201ccontract adjustment event\u201d (i.e. when the pool has become insolvent).\nHowever, the protectedQuote is updated on deposits and withdraws using the following\ncalculation:"
    ],
    "protectedQuote": [
        "The new value depends on the Net Asset Value (NAV) of the pool which, in turn, depends on\nthe current hedge and price of the base asset. If the base asset moves sharply the NAV can\ndrop, which can lead to a large drop in the .\nAn attacker could call initiateDeposit with a small amount periodically. After a week\u2019s delay\nthey are then able to call processQueuedDeposit with the same periodicity. They can watch\nfor a sharp drop in NAV and manipulate the  down. If the price of the base\nasset moves even further this will most likely trigger the circuit breaker for contract\nadjustments and then lock in the reduced  leading to losses for LPs."
    ],
    "Recommended mitigation": [
        "\nIt\u2019s not entirely clear what a good mitigation would be. The protectedQuote needs to be\nupdated as the pool makes profits or losses. Perhaps a calculation that limits the magnitude\nby which it can change in a single step should be considered."
    ],
    "Team response": [
        "\nNot really problematic that the values are being updated. The idea behind the timing of\nupdates being when deposits/withdrawals are processed is they will be blocked when circuit\nbreakers are running. The free liquidity circuit breaker in particular really helps with\npreventing any potential value manipulation as flagged in this issue."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-9-canhedge-may-return-true-when-there-is-insufficient-gmx-liquidity-to-facilitate-hedging-causing-insolvency-risks-trust-security-none-lyra-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "      uint absHedgeDiff = (Math.abs(expectedHedge) - Math.abs(currentHedge));\n      if (remainingDeltas < \n           absHedgeDiff.multiplyDecimal(futuresPoolHedgerParams.marketDepthBuffer)) {\n        return false;\n      }\n\n"
    ],
    "Description": [
        "\nLyra\u2019s security model relies on being able to hedge and achieve delta-neutrality when opening\na user position. The check is done in canHedge() in GMXFuturesPoolHedger. After expected\nhedge delta and current hedge delta are fetched, remainingDeltas is assigned the amount of\nliquidity of the side that will be bought. Then this check is made:"
    ],
    "expectedHedge": [
        "The issue is that the checked requirement for GMX liquidity is not strict enough. If\n and currentHedge have different signs, remainingDeltas needs to be above\n. That\u2019s because the current holdings can\u2019t be deducted from the necessary\ndelta. The impact is that the function would approve sign-switching hedges more leniently\nthan it should."
    ],
    "Recommended mitigation": [
        "\nCheck if expectedHedge and currentHedge have different signs and change logic accordingly."
    ],
    "Team response": [
        "\nValid; but similar to H-1 canHedge is more a safety rail than a core requirement of system\noperation. The deltaThreshold parameter will cause the hedger to be updated more\nfrequently if the hedged delta and expected delta diverge by a large enough amount - which\nwill make these checks operate as expected. Will not be resolved at this stage."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-10-canhedge-will-return-true-when-trade-moves-delta-in-same-direction-as-expectedhedge-even-when-that-leads-to-more-risk-trust-security-none-lyra-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    // expected hedge is positive, and trade increases delta of the pool - risk is reduced, so accept trade\n    if (increasesPoolDelta && expectedHedge >= 0) {\n        return true;\n          }\n"
    ],
    "Description": [
        "\nLyra\u2019s security model relies on being able to hedge and achieve delta-neutrality when opening\na user position. The check is done in canHedge() in GMXFuturesPoolHedger. The function will\nreturn true when the delta of the trade has the same sign as the expectedHedge. For example:"
    ],
    "expectedHedge": [
        "However, this will not always reduce the pool delta. For example an  of 5\nwould indicate the pool delta is -5. A trade which increases pool delta by 11 would mean the\nsubsequent  would be -6. In general, if the  is equal to n/-n\nthen a trade which increases/decreases pool delta by greater than 2*n will increase risk."
    ],
    "Recommended mitigation": [
        "\nTake the magnitude of the trade size into account when performing this check."
    ],
    "Team response": [
        "\nValid, but the additional complexity is too much to add at this stage when benefits are\nminimal. The inclusion of strikeId to the canHedge function will enable more detailed checks\nthat check the exact delta risk added to be added in the future."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-11-decreasing-a-losing-hedge-position-could-make-it-overly-leveraged-trust-security-none-lyra-finance-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "      if (currentPos.unrealisedPnl < 0) {\n          uint adjustedDelta = Math.abs(currentPos.unrealisedPnl).multiplyDecimal(sizeDelta)divideDecimal      (currentPos.size);\n      if (adjustedDelta > collateralDelta) {\n          collateralDelta = 0;\n      } else {\n            collateralDelta -= adjustedDelta;\n           }\n       }\n"
    ],
    "Description": [
        "\nIt may be necessary to decrease a position in order to be delta neutral. When\nGMXFuturesPoolHedger does that, it also decreases the collateral so that the leverage ratio\nwould equal the set targetLeverage. In GMX, fees are deducted from collateral when losses\nare realized. Therefore, the code takes into account that additional collateral needs to be sent,\nto make up for the fees deducted. It\u2019s done in this block:"
    ],
    "adjustedDelta > collateralDelta": [
        "Notably, when  is true, collateralDelta is zero-ed out. Since\nGMX decreasePositionRequest() receives a uint as the collateral delta and decreases by that\namount, the function is not able to add the delta difference. However, that collateral debt is\neffectively forgotten, and as a result, the leverage ratio could be higher than intended. The\nimpact is an increased liquidation risk which is not part of the Lyra risk model."
    ],
    "Recommended mitigation": [
        "\nIf adjustedDelta > collateralDelta holds, make a positionRouter.createIncreasePosition() call\nwith the difference in deltas."
    ],
    "Team response": [
        "\nIf the hedger is over-leveraged after the decrease position request; keepers will be able to\nfollow up with a updateCollateral() request almost immediately to increase the collateral.\nWhilst valid, it is a very unlikely case with minimal impact. The recommendation would break\nthe concept of only one pending position request for the hedger at any time. As the risk is very\ntemporary and there is no easy fix, this will not be resolved."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-1-attacker-can-freeze-profit-withdrawals-from-v3-vaults-trust-security-none-ninja-yield-farming-v3-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "   if (block.timestamp <= lastProfitTime) {\n      revert NYProfitTakingVault__ProfitTimeOutOfBounds();\n      }\n\n",
        "      function harvest() external override whenNotPaused returns (uint256 callerFee) {\n            require(lastHarvestTimestamp != block.timestamp);\n                uint256 harvestSeconds = lastHarvestTimestamp > 0 ? block.timestamp \n            - lastHarvestTimestamp : 0;\n      lastHarvestTimestamp = block.timestamp;\n                uint256 sentToVault;\n          uint256 underlyingTokenCount;\n     (callerFee, underlyingTokenCount, sentToVault) = _harvestCore();\n            emit StrategyHarvest(msg.sender, underlyingTokenCount, \n                   harvestSeconds, sentToVault);\n                }\n",
        "      function _harvestCore() internal override returns (uint256 callerFee, uint256 underlyingTokenCount,      uint256 sentToVault)\n            {\n        IMasterChef(SPOOKY_SWAP_FARM_V2).deposit(POOL_ID, 0);\n            _swapFarmEmissionTokens();\n                callerFee = _chargeFees();\n                    underlyingTokenCount = balanceOf();\n                       sentToVault = _sendYieldToVault();\n            } \n",
        "      function _sendYieldToVault() internal returns (uint256 sentToVault) {\n         sentToVault = IERC20Upgradeable(USDC).balanceOf(address(this));\n            if (sentToVault > 0) {\n               IERC20Upgradeable(USDC).approve(vault, sentToVault);\n            IVault(vault).depositProfitTokenForUsers(sentToVault);\n                }\n                  }\n",
        "      function depositProfitTokenForUsers(uint256 _amount) external nonReentrant {\n         if (_amount == 0) {\n            revert NYProfitTakingVault__ZeroAmount();\n         }\n        if (block.timestamp <= lastProfitTime) {\n            revert NYProfitTakingVault__ProfitTimeOutOfBounds();\n         }\n        if (msg.sender != strategy) {\n            revert NYProfitTakingVault__OnlyStrategy();\n        }\n            uint256 totalShares = totalSupply();\n        if (totalShares == 0) {\n            lastProfitTime = block.timestamp;\n            return;\n          }\n            accProfitTokenPerShare += ((_amount * PROFIT_TOKEN_PER_SHARE_PRECISION) / totalShares);\n               lastProfitTime = block.timestamp;\n            // Now pull in the tokens (Should have permission)\n            // We only want to pull the tokens with accounting\n               profitToken.transferFrom(strategy, address(this), _amount);\n            emit ProfitReceivedFromStrategy(_amount);\n                }\n"
    ],
    "Description": [
        "\nUsers of Ninja can use Vault's withdrawProfit() to withdraw profits. It starts with the\nfollowing check:"
    ],
    "lastProfitTime": [
        "If attacker can front-run user's withdrawProfit() TX and set  to\nblock.timestamp, they would effectively freeze the user's yield. That is indeed possible using\nthe Vault paired strategy's harvest() function. It is permissionless and calls _harvestCore().\nThe attack path is shown in bold."
    ],
    "Recommended Mitigation": [
        "\nDo not prevent profit withdrawals during lastProfitTime block."
    ],
    "Team response": [
        "\nAccepted and removed."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-2-lack-of-child-rewarder-reserves-could-lead-to-freeze-of-funds-trust-security-none-ninja-yield-farming-v3-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "   function onReward(uint _pid, address _user, address _to, uint, uint _amt) external override onlyParent nonReentrant {\n      PoolInfo memory pool = updatePool(_pid);\n         if (pool.lastRewardTime == 0) return;\n            UserInfo storage user = userInfo[_pid][_user];\n            uint pending;\n         if (user.amount > 0) {\n              pending = ((user.amount * pool.accRewardPerShare) / ACC_TOKEN_PRECISION) - user.rewardDebt;\n      rewardToken.safeTransfer(_to, pending);\n         }\n         user.amount = _amt;\n         user.rewardDebt = (_amt * pool.accRewardPerShare) / \n            ACC_TOKEN_PRECISION;\n      emit LogOnReward(_user, _pid, pending, _to);\n      }\n",
        "      uint len = childrenRewarders.length();\n         for (uint i = 0; i < len; ) {\n      IRewarder(childrenRewarders.at(i)).onReward(_pid, _user, _to, 0, \n         _amt);\n      unchecked {\n         ++i;\n         }\n      }\n"
    ],
    "Description": [
        "\nIn ComplexRewarder.sol, onReward() is used to distribute rewards for previous time period,\nusing the complex rewarder and any child rewarders. If the complex rewarder does not have\nenough tokens to hand out the reward, it correctly stores the rewards owed in storage.\nHowever, child rewarded will attempt to hand out the reward and may revert:",
        "Importantly, if the child rewarder fails, the parent's onReward() reverts too:",
        "In the worst-case scenario, this will lead the user's withdraw() call to V3 Vault, to revert."
    ],
    "Recommended Mitigation": [
        "\nIntroduce sufficient exception handling in the CompexRewarder.sol contract, so that\nonReward() would never fail."
    ],
    "Team Response": [
        "\nRejected. Child rewarders are not being used in the protocol and are out of the scope. We\nhave kept the ability for them if needed, and they will be included in a future audit before\nuse. We appreciate this being pointed out and will take care of the issue in future updates."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-3-wrong-accounting-of-users-holdings-allows-theft-of-reward-trust-security-none-ninja-yield-farming-v3-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "      user.amount = _amt;\n      user.rewardDebt = (_amt * pool.accRewardPerShare) / ACC_TOKEN_PRECISION;\n      user.rewardsOwed = rewardsOwed;\n",
        "      // Update rewarder for this user\n          if (address(rewarder) != address(0)) {\n      rewarder.onReward(0, msg.sender, msg.sender, pending, user.amount);\n      }\n      // Burn baby burn\n            _burn(msg.sender, _shares);\n      // User accounting\n                uint256 userAmount = balanceOf(msg.sender);\n      // - Underlying (Frontend ONLY)\n            if (userAmount == 0) {\n               user.amount = 0;\n         } else {\n            user.amount -= r;\n         }\n"
    ],
    "Description": [
        "\nIn deposit(), withdraw() and withdrawProfit(), rewarder.onReward() is called for reward\nbookkeeping. It will transfer previous eligible rewards and update the current amount user\nhas:",
        "In withdraw(), there is a critical issue where onReward() is called too early:"
    ],
    "_amt": [
        "The new  which will be stored in reward contract's user.amount is vault's user.amount,\nbefore decrementing the withdrawn amount. Therefore, the withdrawn amount is still\ngaining rewards even though it's no longer in the contract. Effectively it is stealing the\nrewards of others, leading to reward insolvency.\nIn order to exploit this flaw, attacker will deposit a larger amount and immediately withdraw\nit, except for one wei. When they would like to receive the rewards accrued for others, they\nwill withdraw the remaining wei, which will trigger onReward(), which will calculate and\nsend pending awards for the previously withdrawn amount."
    ],
    "Recommended Mitigation": [
        "\nMove the onReward() call to after user.amount is updated."
    ],
    "Team response": [
        "\nAccepted and updated."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-1-unsafe-transferfrom-breaks-compatibility-with-100s-of-erc20-tokens-trust-security-none-ninja-yield-farming-v3-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "         // Now pull in the tokens (Should have permission)\n          // We only want to pull the tokens with accounting\n                profitToken.transferFrom(strategy, address(this), _amount);\n          emit ProfitReceivedFromStrategy(_amount);\n\n"
    ],
    "Description": [
        "\nIn Ninja vaults, the delegated strategy sends profit tokens to the vault using\ndepositProfitTokenForUsers(). The vault transfers the tokens in using:",
        "The issue is that the code doesn't use the safeTransferFrom() utility from SafeERC20.\nTherefore, profitTokens that don't return a bool in transferFrom() will cause a revert which\nmeans they are stuck in the strategy.\nExamples of such tokens are USDT, BNB, among hundreds of other tokens."
    ],
    "Recommended Mitigation": [
        "\nUse safeTransferFrom() from SafeERC20.sol"
    ],
    "Team Response": [
        "\nAccepted. Excellent find. I can't believe we missed this."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-2-attacker-can-force-partial-withdrawals-to-fail-trust-security-none-ninja-yield-farming-v3-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "      uint256 userAmount = balanceOf(msg.sender);\n         // - Underlying (Frontend ONLY)\n            if (userAmount == 0) {\n            user.amount = 0;\n         } else {\n         user.amount -= r;\n      }\n",
        "      uint256 r = (balance() * _shares) / totalSupply();\n",
        "      function deposit(uint256 _amount) public nonReentrant {\n      \u2026\n            user.amount += _amount;\n      \u2026\n         }\n"
    ],
    "Description": [
        "\nIn Ninja vaults, users call withdraw() to take back their deposited tokens. There is\nbookkeeping on remaining amount:",
        "If the withdraw is partial (some tokens are left), user.amount is decremented by r.",
        "Above, r is calculated as the relative share of the user's _shares of the total balance kept in\nthe vault.",
        "We can see that user.amount is incremented in deposit().",
        "The issue is that the calculated r can be more than _amount , causing an overflow in\nwithdraw() and freezing the withdrawal. All attacker needs to do is send a tiny amount of\nunderlying token directly to the contract, to make the shares go out of sync."
    ],
    "Recommended Mitigation": [
        "\nRedesign user structure, taking into account that balance of underlying can be externally\nmanipulated"
    ],
    "Team Response": [
        "\nAccepted after further investigation. we agreed to remove the double accounting\n(user.amount) and to dynamically calculate the value from the users share balance * price\nper share. We added the public view function getUserUnderlyingBalance to assist (which\nalso allows dynamic underlying decimals)."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-3-rewards-may-be-stuck-due-to-unchangeable-slippage-parameter-trust-security-none-ninja-yield-farming-v3-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "      function _swapFarmEmissionTokens() internal { IERC20Upgradeable boo = IERC20Upgradeable(BOO);\n            uint256 booBalance = boo.balanceOf(address(this));\n      if (booToUsdcPath.length < 2 || booBalance == 0) {\n         return;\n      }\n         boo.safeIncreaseAllowance(SPOOKY_ROUTER, booBalance);\n             uint256[] memory amounts = \n      IUniswapV2Router02(SPOOKY_ROUTER).getAmountsOut(booBalance, booToUsdcPath);\n          uint256 amountOutMin = (amounts[amounts.length - 1] * MAX_SLIPPAGE) / PERCENT_DIVISOR;\n            IUniswapV2Router02(SPOOKY_ROUTER).swapExactTokensForTokensSupportingFeeOnTransferTokens( booBalance, amountOutMin, booToUsdcPath, address(this), block.timestamp );\n                }\n"
    ],
    "Description": [
        "\nIn NyPtvFantomWftmBooSpookyV2StrategyToUsdc.sol, MAX_SLIPPAGE is used to limit\nslippage in trades of BOO tokens to USDC, for yield:"
    ],
    "MAX_SLIPPAGE": [
        "If slippage is not satisfied the entire transaction reverts. Since  is constant, it\nis possible that harvesting of the strategy will be stuck, due to operations leading to too high\nof a slippage. For example, strategy might accumulate a large amount of BOO, or harvest()\ncan be sandwich-attacked."
    ],
    "Recommended Mitigation": [
        "\nAllow admin to set slippage after some timelock period."
    ],
    "Team Response": [
        "\nAccepted. We converted MAX_SLIPPAGE to maxSlippage, a uint256 that the ADMIN Multisig\nrole can update. We decided against a timelock, as we may need to change it once, unlock\nan individual harvest issue and put it back before the next harvest."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-4-truncation-in-reward-calculation-could-cause-leakage-of-rewards-trust-security-none-ninja-yield-farming-v3-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "      uint lpSupply = IVault(VAULT).balance();\n          if (lpSupply > 0) {\n      uint time = block.timestamp - pool.lastRewardTime;\n                uint reward = totalAllocPoint == 0 ? 0 : ((time * rewardPerSecond * \n                  pool.allocPoint) / totalAllocPoint);\n               pool.accRewardPerShare = pool.accRewardPerShare + uint128((reward * \n          ACC_TOKEN_PRECISION) / lpSupply);\n      }\n",
        "         ACC_TOKEN_PRECISION = 10 ** (30 - decimalsRewardToken);\n"
    ],
    "Description": [
        "\nIn ComplexRewarder.sol, updatePool() call updates values in the specified pool."
    ],
    "reward": [
        " could be a fairly large number. The decimals of  * ACC_TOKEN_PRECISION is\n10**30, because of how ACC_TOKEN_PRECISION is defined:"
    ],
    "lpSupply": [
        " is given in LP's decimals, but could be as small as 1. If  is 1, reward of\n2**28 = 268435456 will be enough to cause uint128 overflow of the product (10 * * 30 is 100\nbits). Therefore, it is shown that this calculation is not safe under 128-bit math. The impact\nwould be pool.accRewardPerShare increasing by a tiny amount in relation to the correct\namount."
    ],
    "Recommendation": [
        "\nUse a larger int type to handle the above calculation."
    ],
    "Team response": [
        "\nAccepted. We updated to uint192 and can move to uint256 if you prefer"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-5-potential-overflow-in-reward-accumulator-may-freeze-functionality-trust-security-none-ninja-yield-farming-v3-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "      struct PoolInfo {\n          uint128 accRewardPerShare;\n            uint64 lastRewardTime;\n               uint64 allocPoint;\n"
    ],
    "Description": [
        "\nNote the above description of updatePool() functionality. We can see that accRewardPerShare is only allocated 128 bits in PoolInfo:"
    ],
    "accRewardPerShare": [
        "Therefore, even if truncation issues do not occur, it is likely that continuous incrementation\nof the counter would cause  to overflow, which would freeze vault\nfunctionalities such as withdrawal."
    ],
    "Recommended Mitigation": [
        "\nSteal 32 bits from lastRewardTime and 32 bits from allocPoint to make the accumulator have\n192 bits, which should be enough for safe calculations."
    ],
    "Team response": [
        "\nAccepted. We updated PoolInfo.accRewardPerShare to uint256."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-1-createuniswaprangeorder-charges-manager-instead-of-pool-trust-security-none-rysk-uniswapv3rangeorderreactor-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "        if (inversed && balance < amountDesired) {\n             // collat = 0\n        uint256 transferAmount = amountDesired - balance;\n         uint256 parentPoolBalance = \n             ILiquidityPool(parentLiquidityPool).getBalance(address(token0));\n        if (parentPoolBalance < transferAmount) { revert \n            CustomErrors.WithdrawExceedsLiquidity(); \n        }\n        SafeTransferLib.safeTransferFrom(address(token0), msg.sender, \n         address(this), transferAmount);\n            } \n",
        "    function createUniswapRangeOrder(\n         RangeOrderParams calldata params,\n             uint256 amountDesired\n              ) external {\n           require(!_inActivePosition(), \"RangeOrder: active position\");\n         _onlyManager();\n    bool inversed = collateralAsset == address(token0);\n    _createUniswapRangeOrder(params, amountDesired, inversed);\n    }\n"
    ],
    "Description": [
        "\n_createUniswapRangeOrder() can be called either from manager flow, with createUniswapRangeOrder(), or pool-induced from hedgeDelta(). The issue is that the\nfunction assumes the sender is the parentLiquidityPool, for example:",
        "Balance check is done on pool, but money is transferred from sender. It will cause the order\nto use manager's funds."
    ],
    "Recommended Mitigation": [
        "\nEnsure safeTransfer from uses parentLiquidityPool as source."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe transfers are now implemented in _transferFromParentPool() which ensures from is\nalways parentLiquidityPool."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-h-2-hedgedelta-pricetouse-is-calculated-wrong-which-causes-bad-hedges-trust-security-none-rysk-uniswapv3rangeorderreactor-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    // buy wETH\n    // lowest price is best price when buying\n        uint256 priceToUse = quotePrice < underlyingPrice ? quotePrice : \n            underlyingPrice;\n    RangeOrderDirection direction = inversed ? RangeOrderDirection.ABOVE \n        : RangeOrderDirection.BELOW;\n    RangeOrderParams memory rangeOrder = \n        _getTicksAndMeanPriceFromWei(priceToUse, direction);\n",
        "    int24 lowerTick = direction == RangeOrderDirection.ABOVE ? \n         nearestTick + tickSpacing : nearestTick - (2 * tickSpacing);\n     int24 tickUpper = direction ==RangeOrderDirection.ABOVE ? lowerTick + \n        tickSpacing : nearestTick - tickSpacing;\n"
    ],
    "Description": [
        "\nWhen _delta parameter is negative for hedgeDelta(), priceToUse will be the minimum\nbetween quotePrice and underlyingPrice.",
        "This works fine when direction is BELOW, because the calculated lowerTick and upperTick\nfrom _getTicksAndMeanPriceFromWei are guaranteed to be lower than current price.",
        "Therefore, the fulfill condition is not true and we mint from the correct base. However,\nwhen direction is ABOVE, it is possible that the oracle supplied price (underlyingPrice) is low\nenough in comparison to pool price, that the fulfill condition is already active. In that case,\nthe contract tries to mint from the wrong asset which will cause the wrong tokens to be sent\nin. In effect, the contract is not hedging.\nA similar situation occurs when _delta parameter is greater than zero."
    ],
    "Recommended Mitigation": [
        "\nVerify the calculated priceToUse is on the same side as pool-calculated tick price."
    ],
    "Team Response": [
        "\nFixed"
    ],
    "Mitigation review": [
        "\nThe issue has been solved in the _delta < 0 branch of hedgeDelta(), however it still exists in\nthe else clause. Make sure to use the new getPriceToUse() utility in both cases."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-1-multiplication-overflow-in-getpoolprice-likely-trust-security-none-rysk-uniswapv3rangeorderreactor-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    function getPoolPrice() public view returns (uint256 price, uint256 \n         inversed){\n            (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n        uint256 p = uint256(sqrtPriceX96) * uint256(sqrtPriceX96) * (10 \n        ** token0.decimals());\n     // token0/token1 in 1e18 format\n          price = p / (2 ** 192);\n              inversed = 1e36 / price;\n         }\n\n"
    ],
    "Description": [
        "\ngetPoolPrice() is used in hedgeDelta to get the price directly from Uniswap v3 pool:",
        "The issue is that calculation of p is likely to overflow. sqrtPriceX96 has 96 bits for decimals,\n10** token0.decimals() will have 60 bits when decimals is 18, therefore there is only\n(256 \u2013 2 * 96 \u2013 60) / 2 = 2 bits for non-decimal part of sqrtPriceX96."
    ],
    "Recommended Mitigation": [
        "\nConsider converting the sqrtPrice to a 60x18 format and performing arithmetic operations\nusing the PRBMathUD60x18 library."
    ],
    "Team Response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nCalculations are now performed safely using the standard FullMath library"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-2-hedging-wont-work-if-token1decimals-token0decimals-trust-security-none-rysk-uniswapv3rangeorderreactor-markdown
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    uint256 intermediate = inWei.div(10**(token1.decimals() -\n         token0.decimals()));\n",
        "    meanPrice = OptionsCompute.convertFromDecimals(meanPrice, \n         token0.decimals(), token1.decimals());\n",
        "    function convertFromDecimals(uint256 value, uint8 decimalsA, uint8 decimalsB) internal pure\n        returns (uint256) {\n    if (decimalsA > decimalsB) {\n          revert();\n        }\n        \u2026\n"
    ],
    "Description": [
        "\ntickToToken0PriceInverted() performs some arithmetic calculations. It's called by\n_getTicksAndMeanPriceFromWei(), which is called by hedgeDelta(). This line can overflow:",
        "Also, this line would revert even if the above calculation was done correctly:",
        "The impact is that when token1.decimals() < token0.decimals(), the contract's main function\nis unusable."
    ],
    "Recommended Mitigation": [
        "\nRefactor the calculation to support different decimals combinations. Additionally, add more\ncomprehensive tests to detect similar issues in the future."
    ],
    "Team Response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nThe code has been refactored, there is no longer risk of overflow."
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-3-overflow-danger-in-_sqrtpricex96touint-trust-security-none-rysk-uniswapv3rangeorderreactor-markdown_
--------------------------------------------------
----Start JSON----
{
    "code": [
        "    function _sqrtPriceX96ToUint(uint160 sqrtPriceX96) private pure returns (uint256)\n    {\n        uint256 numerator1 = uint256(sqrtPriceX96) * \n         uint256(sqrtPriceX96);\n    return FullMath.mulDiv(numerator1, 1, 1 << 192);\n         }\n",
        "        if (sqrtPrice > Q96) {\n             uint256 sqrtP = FullMath.mulDiv(sqrtPrice, 10 ** token0Decimals, \n                Q96);\n        return FullMath.mulDiv(sqrtP, sqrtP, 10 ** token0Decimals);\n            } else {\n        uint256 numerator1 = FullMath.mulDiv(sqrtPrice, sqrtPrice, 1);\n        uint256 numerator2 = 10 ** token0Decimals;\n             return FullMath.mulDiv(numerator1, numerator2, 1 << 192);\n            }\n"
    ],
    "Description": [
        "\n_sqrtPriceX96ToUint will only work when the non-fractional component of sqrtPriceX96\ntakes up to 32 bits. This represents a price ratio of 18446744073709551616. With different\ntoken digits it is not unlikely that this ratio will be crossed which will make hedgeDelta()\nrevert."
    ],
    "Recommended Mitigation": [
        "\nPerform the multiplication after converting the numbers to 60x18 variables"
    ],
    "Team Response": [
        "\nFixed"
    ],
    "Mitigation review": [
        "\nNew utility function sqrtPriceX96ToUint correctly uses SafeMath, and also multiplies in a\ndifferent order depending on price size to ensure no overflows occur:"
    ]
}
----End JSON----

https://solodit.xyz/issues/trst-m-4-hedgedelta0-doesnt-behave-properly-trust-security-none-rysk-uniswapv3rangeorderreactor-markdown_--------------------------------------------------
----Start JSON----
{
    "code": [],
    "Description": [
        "\nhedgeDelta() is called again by the pool when the exposure to underlying asset needs to\nchange. If it was previously non-zero and the pool wishes to reset the delta to zero,\nhedgeDelta(0) would be called. Unfortunately, it will never execute.",
        "Flow will enter the sell wETH branch and call _createUniswapRangeOrder() with 0 delta.\nEventually it will try minting a UniswapV3 position with 0 liquidity, which reverts at the\nUniswap level.",
        "As a result, the previous exposure remains as _yankRangeOrderLiquidity() is not called."
    ],
    "Recommendation": [
        "\nAdd branching logic for hedgeDelta. If delta is 0, do nothing."
    ],
    "Team response": [
        "\nFixed"
    ],
    "Mitigation Review": [
        "\nhedgeDelta() now correctly implements an early-exit in case _delta is 0."
    ]
}
----End JSON----
